function ep_artifactCorrection(varargin);%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% ep_artifactCorrection(varargin);% Handles the process of splitting up parts of the files, doing the correction, and then rejoining them.%%	Reads in file chunks generated by readEGISses function (should be set at a size small%	enough to fit in memory.  100,000 samples of 128chan data can be processed with ICA in a 1GB.%	Function runs through all the files given and outputs them as fixed chunks.%	chunks will still need to be rejoined.  It will need a channel%	coordinates file in the EEGlab .ced format.  It will assume that the%	first three entries are fiducials and drop them.  It will assume that%	the next set of entries are the electrodes and will ignore any extras%	at the end.  It will also assume that all the files in a given batch have the same electrode montage.%%Keywords - all optional (defaults in parentheses)%   files: followed by cell array of file names to correct.  Assumes active directory if path not specified.  (default: will ask for files)%   inputFormat: followed by input file format.%   outputFormat: followed by output file format.%   baseline: followed by array of sample numbers to permanently baseline correct the trials with.  [] means don't correct. (default: [])%   timePoints:     followed by array of sample numbers to retain.  [] means don't drop any timepoints. (default: [])%   template: followed by source of blink template (fileTemplate: load blink format file.  autoTemplate: automatically generate blink template.%               bothTemplate: use both file and automatic template at the same time) (default: autotemplate)%   sacctemplate: followed by source of saccade template (fileTemplate: load saccade format file.(default: fileTemplate)%   blinkFile: path and name of the blink file if using the FileTemplate or bothTemplate options.%   saccadeFile: path and name of the saccade file if using the FileTemplate option.%   badChans: followed by cell array of bad channels to exclude from blink detection process (default: [])%   saturation: followed by range of acceptable data values (default: -1000 to +1000)%   eog: followed by structured array with EOG channels (LUVEOG, RUVEOG, LLVEOG, RLVEOG, LHEOG, RHEOG)%               (must be provided by either eog keyword or by auto-detection of montage from original file.)%   window:    moving average window for smoothing during bad channel detection only (default: 80 ms)%   minmax:    difference from minimum to maximum for bad channel (default: 100 였)%   badnum:    percent of bad channels exceeded to declare bad trial, rounding down (default: 10)%   neighbors: number of electrodes considered to be neighbors (default: 6)%   maxneighbor:   maximum microvolt difference allowed from best matching neighbor (default: 30 였)%   badchan:   minimum predictability from neighbors to not be considered globally bad (default: .4)%   blink:     threshold correlation with blink template, 0 to 1 (default: .9)%   saccade:     threshold correlation with saccade template, 0 to 1 (default: .8)%   saccademin:  였 Saccade Fac is the minimum HEOG voltage difference required to constitute a possible saccade. (default: 20)%   sacpot:  였 saccade potential amplitude to trigger detection. (default: 100)%   trialminmax:  difference from minimum to maximum for bad trial (default: 100 였)%   detrend:   1 to detrend (0).  Not recommended for ERP data as can attenuate ERP components.  Can be useful for continuous data or spectral data in general.%              Credit to Hyunseok Kook.%   fMRI:   1 to perform gradient and ballistocardiogram artifact corrections (0).%   badtrials: percentage of good trials chan is bad to declare a channel globally bad (default: 20)%   channelMode:   'replace' to interpolate bad channels, 'mark' to mark them with a spike, and 'none' to do nothing. (default: replace)%   trialMode:   'fix' to fix bad trial data and 'none' to do nothing. (default: fix)%   noadjacent:1 to not allow adjacent bad channels (trial or subject declared bad) (default: 1)%   chunkSize: Number of timepoints to read in.  Roughly 100000 per GB of memory available. (default: 100,000)%   minTrialsPerCell: Minimum number of good trials per cell to avoid warning message. (default: 15)%   movefacs  : number of factors to retain during movement correction.%   noFigure  : 1 to disable summary figures of artifact detection (to help cope with low memory situations).%   editMode  : How to identify artifacts (automatic: use automatic criteria and enter marks into file; manual: use%               existing marks in file; both: use existing marks in file and add additional ones based on automatic criteria)%               (default: both)%%Outputs%	Saves files with blinks removed.  Uses original name with "_e" appended to the stem.%   If baseline option is used (provides better results, particularly when%   there are large DC swings in the recordings), then the output will be%   baselined.%   finalLog: output messages from blink process%% History:%% by Joseph Dien (2/17/08)% jdien07@mac.com%%% modified 11/20/08 JD% Changed to keyword approach.  Made baseline specification more flexible.% Changed to use FieldTrip I/O in order to be able to read more formats.%% modified and bugfix 2/11/09 JD% Changed to allow selection of multiple files from selector.  Problematic% files do not stop entire batch.  More information added to log file.  Bad% channel and trial detection implemented.  Blinkfile template option crash fixed.% Fixed crash when selecting a single file with the file requestor.%% modified 3/25/09 JD% Changed to use readData and writeData functions to provide more flexibility with I/O functions.% Now relies on readData to obtain the .ced file name.%% modified 4/17/09 JD% eloc and ced now handled by readData.%% modified 7/14/09 JD% Added none option to blink template.  Changed 'replace' keyword to 'channelMode'.  Added 'trialMode'.% Single summary figure for full artifact correction procedure.  Changing name of function to% artifactCorrection from blinkCorrecction.  Doesn't require two vertical EOG channels% if using file template.  Uses updated blink template format.%% bugfix 8/27/09 JD% Location of windows appearing partly off screen on some systems.  Fixed.%% bugfix & modified 8/30/09 JD% Was setting all data formats to EGIS.  Added support for continuous data.%% bugfix & modified 9/16/09 JD% Added refChan input to deal with mean mastoid data where the presence of the two reference channels (correlated -1)% was causing ICA problems.% Slashes in log file being interpreted as control characters.% Trialwise bad channel detection deactivated for continuous data.%% bugfix 9/23/09 JD% When input files were split into multiple chunks, only the final one's progress window was being closed.% In batch runs the windows would accumulate and eventually result in a memory error.%% bugfix 10/17/09 JD% Continuous data crashed artifact correction.%% modified 10/28/09 JD% Added option to disable preprocessing figure for low memory situations.%% bugfix 10/31/09 JD% When there are multiple chunks, only saving the figure for the final one.%% bugfix 12/5/09 JD% Avoid performing trialwise bad channel detection entirely unless both minmax and maxneighbor parameters are inactive.% Fixed crash when more than one bad channel.% Now assumes montages are all the same, not just the channel coordinates.%% modified & bugfix 2/24/10 JD% No longer treating shorted channels as being bad channels as this was proving too conservative a criterion.  Instead% it now just provides a warning message.% Will now work with subject average files with multiple subjects.% Turning off bad channel preferences affects only the relevant bad channel criteria rather than turning off all bad% channel detection.% Now uses file's reference settings if not specified in the Preprocess pane.% Added log to bad channel detection function output.%% modified 6/15/10 JD% Added name of first session file to the name of the log file if just one or the number of files if more.%% modified 8/31/10 JD% Added message about time taken for artifact run.%%  modified 10/28/10 JD%  Added support for HEOG saccade correction.%%  modified 1/18/11 JD%  Added support for selecting timepoints.%%  modified 1/20/11 JD%  Added support for manually specifying EOG channels in the preferences.%%  modified 2/10/11 JD%  Finished taking out hmin saccade code.%% modified 1/27/12 JD% Eliminated REF channel type and added reference field to keep track of original and current reference scheme.%% modified 1/28/13 JD% Added options for using manual edit marks instead of or in addition to automatic marking for bad channel and trials.% If baseline correction chosen, will occur even if blink correction not performed and it will be applied prior to bad% channel and trial detection.  Detrending now performed prior to bad channel and trial correction but before baseline% correction.%% bugfix 5/9/13 JD% Fixed crash when using Points option with continuous data.%% bugfix 5/13/13 JD% Fixed automatic global bad channel detection being performed even when editMode set to Manual.%% modified 9/24/13 JD% Restricted blink correction to EEG channels.%% bugfix 9/26/13 JD% Fixed not finding files past the first when batched and they are not in the active directory.%%  modified 11/15/13 JD%  Added fMRI artifact correction option to Preprocess data function using fMRIb EEGlab plugin.%%  modified 11/23/13 JD%  Does not write over existing files.%% bugfix 11/25/13 JD% Fixed crashes when there are multiple bad channels.%%  modified 11/27/13 JD%  Added fMRI artifact correction option to Preprocess data function using AMRI EEG fMRI Toolbox.%%  bugfix 1/12/14 JD%  Workaround for Matlab bug periodically causing screen size to register as having zero size.%% modified 3/18/14 JD% Changed uses of "temp" as a variable name to "tempVar" due to other Matlab programmers often using it as a function% name, resulting in collisions.%% modified 6/2/14 JD% Movement correction function call now includes current reference channel info.%% modified 6/3/14 JD% Added support for SMI eye tracking files.% If current reference not specified, default to original reference.%% bugfix 6/12/14 JD% Fixed blank keys field of events being produced without .key (e.g., .keys.keyCod instead of .keys.key.keyCode)%% modified 7/16/14 JD% Simplified keys code field structure.%% bugfix 8/27/14 JD% Fixed crash for files where event values are all numbers rather than% strings.%% modified 8/29/14 JD% Moved SMI file support to the readData function.%% modified 8/31/14 JD% Added support for adding additional keys information to events in continuous data and trial specs in single-trial% data.%%  modified 5/25/14 JD%  Set colormap to jet even for Matlab 2014b onwards.%% bugfix 8/14/15 JD% Fixed unable to save artifact correction summary figure starting with% Matlab 2014b.%% modified 12/18/15 JD% Preprocessing function allows EEG files with different numbers of non-EEG channels to be batched together.%% modified 2/16/16 JD% Artifact figure files no longer overwrite prior such files with same name.%% modified 9/16/16 JD% Added automatic detection and correction of saccade potentials.% Added template summary figure to saved files.% Implemented improved saccade correction routines, dropping blink points from saccade potential and saccade corrections.%% modified 11/5/16 JD% Added support for writing out subject spec text files.%% modified 1/3/17 JD% Added eyeTracker option to blink and saccade correction routines.%% modified 2/5/17 JD% Added Subtracted topography to template jpeg output.%% modified 4/18/17 JD% Excludes time points beyond a certain range from global bad channel detection, blink, and saccade routines.%% modified 10/3/17 JD% Interpolates bad EOG channels instead of aborting artifact correction when too many are bad.%% bugfix 10/11/17 JD% Fixed crashes due to Matlab changing their graphics objects AGAIN in 2017b.%% bugfix 10/20/17 JD% Eliminated x tick labels to address problem with subplots in summary% artifact figure getting squeezed by formatting problem on PCs.%% modified 2/4/18 JD% Made subplot specification for summary figure output more flexible.%% bugfix 2/12/18 JD% Fixed crash when detrend option used.%% modified 4/2/18 JD% Only interpolate EOG channels if blink or saccade correcting.% Consolidated summary figure for average files so no longer one per subject.%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%     Copyright (C) 1999-2018  Joseph Dien%%     This program is free software: you can redistribute it and/or modify%     it under the terms of the GNU General Public License as published by%     the Free Software Foundation, either version 3 of the License, or%     (at your option) any later version.%%     This program is distributed in the hope that it will be useful,%     but WITHOUT ANY WARRANTY; without even the implied warranty of%     MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the%     GNU General Public License for more details.%%     You should have received a copy of the GNU General Public License%     along with this program.  If not, see <http://www.gnu.org/licenses/>.%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%global EPmainbaseline=[];timePoints=[];montage=[];sessionFiles=[];outputFormat='egi_egis';inputFormat='egi_egis';blinkTemplate='autoTemplate';sacctemplate='fileTemplate';blinkFile=[];saccadeFile=[];badChans=[];chunkSize=100000;eog=[];origRefChan=[];currRefChan=[];noFigure=0;ced = 'none';editMode='both';badDataCriteria.window=80;badDataCriteria.minmax=100;badDataCriteria.trialminmax=200;badDataCriteria.badnum=10;badDataCriteria.neighbors=6;badDataCriteria.badchan=.4;badDataCriteria.maxneighbor=30;badDataCriteria.blink=.9;badDataCriteria.detrend=0;badDataCriteria.badtrials=20;badDataCriteria.channelMode='replace';badDataCriteria.trialMode='fix';badDataCriteria.noadjacent=1;badDataCriteria.movefacs=20;badDataCriteria.sacpot=100;badDataCriteria.saturation=[-1000 1000];minTrialsPerCell=15;scrsz = EPmain.scrsz;if ~isempty(varargin)    if isa(varargin{1},'cell') && nargin==1 %if keywords were input as a single cell string        inputSet=varargin{1};    else        inputSet=varargin;    end;else    inputSet=[];end;argNum=length(inputSet);if mod(argNum,2) ~= 0    msg{1}='The keywords need to all be in pairs, with a keyword followed by the keyword information.';    [msg]=ep_errorMsg(msg);    returnend;readArg=[];argCount=1;while argCount <= argNum    switch inputSet{argCount}        case 'files'            argCount=argCount+1;            if argCount > argNum                msg{1}='The ''files'' keyword must be followed by a set of file names.';                [msg]=ep_errorMsg(msg);                return            end;            if ~iscell(inputSet{argCount})                msg{1}='The ''files'' keyword must be followed by a set of file names.';                [msg]=ep_errorMsg(msg);                return            end;            sessionFiles=inputSet{argCount};            argCount=argCount+1;        case 'inputFormat'            argCount=argCount+1;            if argCount > argNum                msg{1}='The ''inputFormat'' keyword must be followed by a format name.';                [msg]=ep_errorMsg(msg);                return            end;            if ~ischar(inputSet{argCount})                msg{1}='The ''inputFormat'' keyword must be followed by a format name.';                [msg]=ep_errorMsg(msg);                return            end;            inputFormat=inputSet{argCount};            readArg{end+1}='format';            readArg{end+1}=inputSet{argCount};            argCount=argCount+1;        case 'outputFormat'            argCount=argCount+1;            if argCount > argNum                msg{1}='The ''outputFormat'' keyword must be followed by a format name.';                [msg]=ep_errorMsg(msg);                return            end;            if ~ischar(inputSet{argCount})                msg{1}='The ''outputFormat'' keyword must be followed by a format name.';                [msg]=ep_errorMsg(msg);                return            end;            outputFormat=inputSet{argCount};            argCount=argCount+1;        case 'baseline'            argCount=argCount+1;            if argCount > argNum                msg{1}='The ''baseline'' keyword must be followed by a list of samples.';                [msg]=ep_errorMsg(msg);                return            end;            if ~isnumeric(inputSet{argCount})                msg{1}='The ''baseline'' keyword must be followed by a set of numbers (e.g., [1:50]).';                [msg]=ep_errorMsg(msg);                return            end;            baseline=inputSet{argCount};            argCount=argCount+1;        case 'timePoints'            argCount=argCount+1;            if argCount > argNum                msg{1}='The ''timePoints'' keyword must be followed by a list of samples.';                [msg]=ep_errorMsg(msg);                return            end;            if ~isnumeric(inputSet{argCount})                msg{1}='The ''timePoints'' keyword must be followed by a set of numbers (e.g., [1:50]).';                [msg]=ep_errorMsg(msg);                return            end;            timePoints=inputSet{argCount};            argCount=argCount+1;        case 'template'            argCount=argCount+1;            if argCount > argNum                msg{1}='The ''template'' keyword must be followed by the template option.';                [msg]=ep_errorMsg(msg);                return            end;            if ~any(strcmp(inputSet{argCount},{'autoTemplate','fileTemplate','bothTemplate','eyeTracker','none'}))                msg{1}='The ''template'' keyword must be followed by ''autoTemplate'', ''fileTemplate'', ''bothTemplate'',''eyeTracker'', ''none''.';                [msg]=ep_errorMsg(msg);                return            end;            blinkTemplate=inputSet{argCount};            argCount=argCount+1;        case 'sacctemplate'            argCount=argCount+1;            if argCount > argNum                msg{1}='The ''sacctemplate'' keyword must be followed by the saccade template option.';                [msg]=ep_errorMsg(msg);                return            end;            if ~any(strcmp(inputSet{argCount},{'autoTemplate','fileTemplate','bothTemplate','eyeTracker','none'}))                msg{1}='The ''template'' keyword must be followed by ''autoTemplate'', ''fileTemplate'', ''bothTemplate'',''eyeTracker'', ''none''.';                [msg]=ep_errorMsg(msg);                return            end;            sacctemplate=inputSet{argCount};            argCount=argCount+1;        case 'blinkFile'            argCount=argCount+1;            if argCount > argNum                msg{1}='The ''blinkFile'' keyword must be followed by the blink file name.';                [msg]=ep_errorMsg(msg);                return            end;            if ~ischar(inputSet{argCount})                msg{1}='The ''blinkFile'' keyword must be followed by the blink file name.';                [msg]=ep_errorMsg(msg);                return            end;            blinkFile=inputSet{argCount};            argCount=argCount+1;        case 'saccadeFile'            argCount=argCount+1;            if argCount > argNum                msg{1}='The ''saccadeFile'' keyword must be followed by the saccade file name.';                [msg]=ep_errorMsg(msg);                return            end;            if ~ischar(inputSet{argCount})                msg{1}='The ''saccadeFile'' keyword must be followed by the saccade file name.';                [msg]=ep_errorMsg(msg);                return            end;            saccadeFile=inputSet{argCount};            argCount=argCount+1;        case 'badChans'            argCount=argCount+1;            if argCount > argNum                msg{1}='The ''badChans'' keyword must be followed by a set of numbers (e.g., [1 3]).';                [msg]=ep_errorMsg(msg);                return            end;            if ~iscell(inputSet{argCount})                msg{1}='The ''badChans'' keyword must be followed by a set of numbers (e.g., [1 3]).';                [msg]=ep_errorMsg(msg);                return            end;            badChans=inputSet{argCount};            argCount=argCount+1;        case 'saturation'            argCount=argCount+1;            if argCount > argNum                msg{1}='The ''saturation'' keyword must be followed by a range of permissible values (e.g., [-32768 32767]).';                [msg]=ep_errorMsg(msg);                return            end;            if ~isnumeric(inputSet{argCount}) || length(inputSet{argCount}) ~= 2                msg{1}='The ''saturation'' keyword must be followed by a range of permissible values (e.g., [-32768 32767]).';                [msg]=ep_errorMsg(msg);                return            end;            badDataCriteria.saturation=inputSet{argCount};            argCount=argCount+1;        case 'eog'            argCount=argCount+1;            if argCount > argNum                msg{1}='The ''eog'' keyword must be followed by an array with the six EOG channels.';                [msg]=ep_errorMsg(msg);                return            end;            eog2=inputSet{argCount};            if ~isempty(eog2)                if ~isnumeric(eog2) || length(eog2) ~= 6                    msg{1}='The ''eog'' keyword must be followed by an array with the six EOG channels.';                    [msg]=ep_errorMsg(msg);                    return                end;            end;            eog.LUVEOG = eog2(1);            eog.RUVEOG = eog2(2);            eog.LLVEOG = eog2(3);            eog.RLVEOG = eog2(4);            eog.LHEOG = eog2(5);            eog.RHEOG = eog2(6);            argCount=argCount+1;        case 'window'            argCount=argCount+1;            if argCount > argNum                msg{1}='The ''window'' keyword must be followed by the criterion number.';                [msg]=ep_errorMsg(msg);                return            end;            if ~isnumeric(inputSet{argCount})                msg{1}='The ''window'' keyword must be followed by the criterion number.';                [msg]=ep_errorMsg(msg);                return            end;            badDataCriteria.window=inputSet{argCount};            argCount=argCount+1;        case 'minmax'            argCount=argCount+1;            if argCount > argNum                msg{1}='The ''minmax'' keyword must be followed by the criterion number.';                [msg]=ep_errorMsg(msg);                return            end;            if ~isnumeric(inputSet{argCount})                msg{1}='The ''minmax'' keyword must be followed by the criterion number.';                [msg]=ep_errorMsg(msg);                return            end;            badDataCriteria.minmax=inputSet{argCount};            argCount=argCount+1;        case 'trialminmax'            argCount=argCount+1;            if argCount > argNum                msg{1}='The ''trialminmax'' keyword must be followed by the criterion number.';                [msg]=ep_errorMsg(msg);                return            end;            if ~isnumeric(inputSet{argCount})                msg{1}='The ''trialminmax'' keyword must be followed by the criterion number.';                [msg]=ep_errorMsg(msg);                return            end;            badDataCriteria.trialminmax=inputSet{argCount};            argCount=argCount+1;        case 'badnum'            argCount=argCount+1;            if argCount > argNum                msg{1}='The ''badnum'' keyword must be followed by the criterion number.';                [msg]=ep_errorMsg(msg);                return            end;            if ~isnumeric(inputSet{argCount})                msg{1}='The ''badnum'' keyword must be followed by the criterion number.';                [msg]=ep_errorMsg(msg);                return            end;            if badDataCriteria.badnum < 0 || badDataCriteria.badnum > 100                msg{1}='The ''badnum'' number must be between 0 and 100.';                [msg]=ep_errorMsg(msg);                return            end;            badDataCriteria.badnum=inputSet{argCount};            argCount=argCount+1;        case 'neighbors'            argCount=argCount+1;            if argCount > argNum                msg{1}='The ''neighbors'' keyword must be followed by the criterion number.';                [msg]=ep_errorMsg(msg);                return            end;            if ~isnumeric(inputSet{argCount})                msg{1}='The ''neighbors'' keyword must be followed by the criterion number.';                [msg]=ep_errorMsg(msg);                return            end;            badDataCriteria.neighbors=inputSet{argCount};            argCount=argCount+1;        case 'maxneighbor'            argCount=argCount+1;            if argCount > argNum                msg{1}='The ''maxneighbor'' keyword must be followed by the criterion number.';                [msg]=ep_errorMsg(msg);                return            end;            if ~isnumeric(inputSet{argCount})                msg{1}='The ''maxneighbor'' keyword must be followed by the criterion number.';                [msg]=ep_errorMsg(msg);                return            end;            badDataCriteria.maxneighbor=inputSet{argCount};            argCount=argCount+1;        case 'badchan'            argCount=argCount+1;            if argCount > argNum                msg{1}='The ''badchan'' keyword must be followed by the criterion number.';                [msg]=ep_errorMsg(msg);                return            end;            if ~isnumeric(inputSet{argCount})                msg{1}='The ''badchan'' keyword must be followed by the criterion number.';                [msg]=ep_errorMsg(msg);                return            end;            if badDataCriteria.badchan < 0 || badDataCriteria.badchan > 1                msg{1}='The ''badchan'' number must be between 0 and 1.';                [msg]=ep_errorMsg(msg);                return            end;            badDataCriteria.badchan=inputSet{argCount};            argCount=argCount+1;        case {'blink', 'blinks'}            argCount=argCount+1;            if argCount > argNum                msg{1}='The ''blink'' keyword must be followed by the criterion number.';                [msg]=ep_errorMsg(msg);                return            end;            if ~isnumeric(inputSet{argCount})                msg{1}='The ''blink'' keyword must be followed by the criterion number.';                [msg]=ep_errorMsg(msg);                return            end;            badDataCriteria.blink=inputSet{argCount};            if badDataCriteria.blink < 0 || badDataCriteria.blink > 1                msg{1}='The ''blink'' number must be between 0 and 1.';                [msg]=ep_errorMsg(msg);                return            end;            argCount=argCount+1;        case {'saccade', 'saccades'}            argCount=argCount+1;            if argCount > argNum                msg{1}='The ''saccade'' keyword must be followed by the criterion number.';                [msg]=ep_errorMsg(msg);                return            end;            if ~isnumeric(inputSet{argCount})                msg{1}='The ''saccade'' keyword must be followed by the criterion number.';                [msg]=ep_errorMsg(msg);                return            end;            badDataCriteria.saccade=inputSet{argCount};            if badDataCriteria.saccade < 0 || badDataCriteria.blink > 1                msg{1}='The ''saccade'' number must be between 0 and 1.';                [msg]=ep_errorMsg(msg);                return            end;            argCount=argCount+1;        case 'saccademin'            argCount=argCount+1;            if argCount > argNum                msg{1}='The ''saccademin'' keyword must be followed by the criterion number.';                [msg]=ep_errorMsg(msg);                return            end;            if ~isnumeric(inputSet{argCount})                msg{1}='The ''saccademin'' keyword must be followed by the criterion number.';                [msg]=ep_errorMsg(msg);                return            end;            badDataCriteria.saccademin=inputSet{argCount};            argCount=argCount+1;        case 'sacpot'            argCount=argCount+1;            if argCount > argNum                msg{1}='The ''sacpot'' keyword must be followed by the criterion number.';                [msg]=ep_errorMsg(msg);                return            end;            if ~isnumeric(inputSet{argCount})                msg{1}='The ''sacpot'' keyword must be followed by the criterion number.';                [msg]=ep_errorMsg(msg);                return            end;            badDataCriteria.sacpot=inputSet{argCount};            argCount=argCount+1;        case 'detrend'            argCount=argCount+1;            if argCount > argNum                msg{1}='The ''detrend'' keyword must be followed by the criterion number.';                [msg]=ep_errorMsg(msg);                return            end;            if ~isnumeric(inputSet{argCount})                msg{1}='The ''detrend'' keyword must be followed by the criterion number.';                [msg]=ep_errorMsg(msg);                return            end;            badDataCriteria.detrend=inputSet{argCount};            if badDataCriteria.detrend ~= 0 && badDataCriteria.detrend ~= 1                msg{1}='The ''detrend'' number must be either 0 or 1.';                [msg]=ep_errorMsg(msg);                return            end;            if badDataCriteria.detrend ==1                disp('Warning: detrending can distribute an effect across the entire epoch.  Use with care.');            end;            argCount=argCount+1;        case 'fMRI'            argCount=argCount+1;            if argCount > argNum                msg{1}='The ''fMRI'' keyword must be followed by the algorithm number.';                [msg]=ep_errorMsg(msg);                return            end;            if ~isnumeric(inputSet{argCount})                msg{1}='The ''fMRI'' keyword must be followed by the algorithm number.';                [msg]=ep_errorMsg(msg);                return            end;            badDataCriteria.fMRI=inputSet{argCount};            if badDataCriteria.fMRI < 0 || badDataCriteria.fMRI > 2                msg{1}='The ''fMRI'' number must be 0-2.';                [msg]=ep_errorMsg(msg);                return            end;            argCount=argCount+1;        case 'EMG'            argCount=argCount+1;            if argCount+2 > argNum                msg{1}='The ''EMG'' keyword must be followed by three parameters.';                [msg]=ep_errorMsg(msg);                return            end;            if ~isnumeric(inputSet{argCount})                msg{1}='The ''EMG'' keyword must be followed by the criterion number.';                [msg]=ep_errorMsg(msg);                return            end;            badDataCriteria.EMG=inputSet{argCount};            if badDataCriteria.EMG ~= 0 && badDataCriteria.EMG ~= 1                msg{1}='The ''EMG'' number must be either 0 or 1.';                [msg]=ep_errorMsg(msg);                return            end;            argCount=argCount+1;            if ~isnumeric(inputSet{argCount})                msg{1}='The ''EMG'' criterion number must be followed by an EMG ratio parameter.';                [msg]=ep_errorMsg(msg);                return            end;            badDataCriteria.EMGratio=inputSet{argCount};            if badDataCriteria.EMGratio < 0                msg{1}='The ''EMGratio'' number must be positive.';                [msg]=ep_errorMsg(msg);                return            end;            argCount=argCount+1;            if ~isnumeric(inputSet{argCount})                msg{1}='The ''EMG'' ratio number must be followed by an EMG threshold parameter.';                [msg]=ep_errorMsg(msg);                return            end;            badDataCriteria.EMGthresh=inputSet{argCount};            if badDataCriteria.EMGthresh < 0                msg{1}='The ''EMG'' threshold number must be positive.';                [msg]=ep_errorMsg(msg);                return            end;            argCount=argCount+1;        case 'alpha'            argCount=argCount+1;            if argCount > argNum                msg{1}='The ''alpha'' keyword must be followed by the criterion number.';                [msg]=ep_errorMsg(msg);                return            end;            if ~isnumeric(inputSet{argCount})                msg{1}='The ''alpha'' keyword must be followed by the criterion number.';                [msg]=ep_errorMsg(msg);                return            end;            badDataCriteria.alpha=inputSet{argCount};            if badDataCriteria.alpha ~= 0 && badDataCriteria.alpha ~= 1                msg{1}='The ''alpha'' number must be either 0 or 1.';                [msg]=ep_errorMsg(msg);                return            end;            if badDataCriteria.alpha ==1                disp('Warning: alpha correction is experimental.  Should not be used with frequency-domain analysis.  Use with care.');                disp('**It can require a great deal of RAM to function and can crash the computer if there is not enough.**');            end;            argCount=argCount+1;        case 'badtrials'            argCount=argCount+1;            if argCount > argNum                msg{1}='The ''badtrials'' keyword must be followed by the criterion number.';                [msg]=ep_errorMsg(msg);                return            end;            if ~isnumeric(inputSet{argCount})                msg{1}='The ''badtrials'' keyword must be followed by the criterion number.';                [msg]=ep_errorMsg(msg);                return            end;            if badDataCriteria.badtrials < 0 || badDataCriteria.badtrials > 100                msg{1}='The ''badtrials'' number must be between 0 and 100.';                [msg]=ep_errorMsg(msg);                return            end;            badDataCriteria.badtrials=inputSet{argCount};            argCount=argCount+1;        case 'channelMode'            argCount=argCount+1;            if argCount > argNum                msg{1}='The ''channelMode'' keyword must be followed by ''replace'' or ''mark'' or ''none''.';                [msg]=ep_errorMsg(msg);                return            end;            if ~ischar(inputSet{argCount})                msg{1}='The ''channelMode'' keyword must be followed by ''replace'' or ''mark'' or ''none''.';                [msg]=ep_errorMsg(msg);                return            end;            if ~any(strcmp(inputSet{argCount},{'replace','mark','none'}))                msg{1}='The ''channelMode'' keyword must be followed by ''replace'' or ''mark'' or ''none''.';                [msg]=ep_errorMsg(msg);                return            end;            badDataCriteria.channelMode=inputSet{argCount};            argCount=argCount+1;        case 'trialMode'            argCount=argCount+1;            if argCount > argNum                msg{1}='The ''trialMode'' keyword must be followed by ''fix'' or ''none''.';                [msg]=ep_errorMsg(msg);                return            end;            if ~ischar(inputSet{argCount})                msg{1}='The ''trialMode'' keyword must be followed by ''fix'' or ''none''.';                [msg]=ep_errorMsg(msg);                return            end;            if ~any(strcmp(inputSet{argCount},{'fix','none'}))                msg{1}='The ''trialMode'' keyword must be followed by ''fix'' or ''none''.';                [msg]=ep_errorMsg(msg);                return            end;            badDataCriteria.trialMode=inputSet{argCount};            argCount=argCount+1;        case 'noadjacent'            argCount=argCount+1;            if argCount > argNum                msg{1}='The ''noadjacent'' keyword must be followed by 0 or 1.';                [msg]=ep_errorMsg(msg);                return            end;            if ~isnumeric(inputSet{argCount})                msg{1}='The ''noadjacent'' keyword must be followed by 0 or 1.';                [msg]=ep_errorMsg(msg);                return            end;            badDataCriteria.noadjacent=inputSet{argCount};            if badDataCriteria.noadjacent ~= 0 && badDataCriteria.noadjacent ~= 1                msg{1}='The ''noadjacent'' keyword must be followed by 0 or 1.';                [msg]=ep_errorMsg(msg);                return            end;            argCount=argCount+1;        case 'chunkSize'            argCount=argCount+1;            if argCount > argNum                msg{1}='The ''chunkSize'' keyword must be followed by the chunk size number.';                [msg]=ep_errorMsg(msg);                return            end;            if ~isnumeric(inputSet{argCount})                msg{1}='The ''chunkSize'' keyword must be followed by the chunk size number.';                [msg]=ep_errorMsg(msg);                return            end;            chunkSize=inputSet{argCount};            argCount=argCount+1;        case 'minTrialsPerCell'            argCount=argCount+1;            if argCount > argNum                msg{1}='The ''minTrialsPerCell'' keyword must be followed by a number of trials.';                [msg]=ep_errorMsg(msg);                return            end;            if ~isnumeric(inputSet{argCount})                msg{1}='The ''minTrialsPerCell'' keyword must be followed by a number of trials.';                [msg]=ep_errorMsg(msg);                return            end;            minTrialsPerCell=inputSet{argCount};            argCount=argCount+1;        case 'movefacs'            argCount=argCount+1;            if argCount > argNum                msg{1}='The ''movefacs'' keyword must be followed by a number of factors.';                [msg]=ep_errorMsg(msg);                return            end;            if ~isnumeric(inputSet{argCount})                msg{1}='The ''movefacs'' keyword must be followed by a number of factors.';                [msg]=ep_errorMsg(msg);                return            end;            badDataCriteria.movefacs=inputSet{argCount};            argCount=argCount+1;        case 'origReference'            readArg{end+1}=inputSet{argCount};            argCount=argCount+1;            if argCount > argNum                msg{1}='The ''origReference'' keyword must be followed by the reference channel(s).';                [msg]=ep_errorMsg(msg);                return            end;            if ~isnumeric(inputSet{argCount}) && ~any(ismember(inputSet{argCount},{'AVG','CSD'}))                msg{1}='The ''origReference'' keyword must be followed by the reference channel(s).';                [msg]=ep_errorMsg(msg);                return            end;            origRefChan=inputSet{argCount};            readArg{end+1}=inputSet{argCount};            argCount=argCount+1;        case 'currReference'            readArg{end+1}=inputSet{argCount};            argCount=argCount+1;            if argCount > argNum                msg{1}='The ''currReference'' keyword must be followed by the reference channel(s).';                [msg]=ep_errorMsg(msg);                return            end;            if ~isnumeric(inputSet{argCount}) && ~any(ismember(inputSet{argCount},{'AVG','CSD'}))                msg{1}='The ''currReference'' keyword must be followed by the reference channel(s).';                [msg]=ep_errorMsg(msg);                return            end;            currRefChan=inputSet{argCount};            readArg{end+1}=inputSet{argCount};            argCount=argCount+1;        case 'noFigure'            argCount=argCount+1;            if argCount > argNum                msg{1}='The ''noFigure'' keyword must be followed by 0 or 1.';                [msg]=ep_errorMsg(msg);                return            end;            if ~isnumeric(inputSet{argCount})                msg{1}='The ''noFigure'' keyword must be followed by 0 or 1.';                [msg]=ep_errorMsg(msg);                return            end;            noFigure=inputSet{argCount};            if noFigure ~= 0 && noFigure ~= 1                msg{1}='The ''noFigure'' keyword must be followed by 0 or 1.';                [msg]=ep_errorMsg(msg);                return            end;            argCount=argCount+1;        case 'editMode'            argCount=argCount+1;            if argCount > argNum                msg{1}='The ''editMode'' keyword must be followed by the edit mode option.';                [msg]=ep_errorMsg(msg);                return            end;            if ~any(strcmp(inputSet{argCount},{'automatic','manual','both'}))                msg{1}='The ''editMode'' keyword must be followed by ''automatic'' or ''manual'' or ''both''.';                [msg]=ep_errorMsg(msg);                return            end;            editMode=inputSet{argCount};            argCount=argCount+1;        otherwise            readArg{end+1}=inputSet{argCount};            argCount=argCount+1;            readArg{end+1}=inputSet{argCount};            argCount=argCount+1;    end;end;if any(strcmp(blinkTemplate, {'fileTemplate','bothTemplate'})) && isempty(blinkFile)    blinkFile = 'blinks';end;if ~strcmp('format',readArg)    readArg{end+1}='format';    readArg{end+1}='egi_egis';end;if isempty(sessionFiles)    [sessionFiles, pathname]=ep_getFilesUI(inputFormat);    if sessionFiles{1}==0        msg{1}='No filenames selected. You have to click on a name';        [msg]=ep_errorMsg(msg);        return    end    for theFile=1:size(sessionFiles,2)        sessionFiles{theFile}=[activeDirectory sessionFiles{theFile}];    end;else    files=dir;    for theFile=1:size(sessionFiles,2)        [activeDirectory, name, ext] = fileparts(sessionFiles{theFile});        if isempty(activeDirectory)            activeDirectory=pwd;            sessionFiles{theFile}=[activeDirectory filesep sessionFiles{theFile}];        end;        if ~exist(sessionFiles{theFile},'file')            msg{1}=['Error: The file ' sessionFiles{theFile} ' is not in the directory.'];            [msg]=ep_errorMsg(msg);            return        end;    end;end;sessionFiles=sessionFiles';sessionNum = size(sessionFiles,1);finalLog{1}='ARTIFACT CORRECTION SUMMARY';if isempty(badChans) || (length(badChans) == 1) && (isempty(badChans{1}))    badChans=num2cell(zeros(sessionNum,1));end;if (size(sessionFiles,1) ~= size(badChans,1))    msg{1}='Must specify a set of bad channels for each subject.';    [msg]=ep_errorMsg(msg);    returnend;if exist('icadefs','file') ~= 2    msg{1}='Error: ICA not available.  You need to download EEGlab and then add it to Matlab''s path list.';    msg{2}='See tutorial file for details.';    [msg]=ep_errorMsg(msg);    returnend;icadefs;if any(isspace(pwd)) && exist(ICABINARY,'file') == 2    disp(['Binary ICA does not work if any part of the pathname (' pwd ') has a space in it.']);    disp('Will use regular ICA instead.');end;%assume the first session file is representative of the rest.Name=deblank(sessionFiles{1});thisReadArg=readArg;thisReadArg{end+1}='file';[pathstr, fileName, ext]=fileparts(Name);thisReadArg{end+1}=Name;data=ep_readData(thisReadArg);if isempty(data)    msg{1}=['Error: The file ' sessionFiles{1} ' was not read successfully.'];    [msg]=ep_errorMsg(msg);    returnend;[data]=ep_stripAdds(data);if isempty(data.eloc)    msg{1}=['Error: The file ' sessionFiles{1} ' has no information on channel locations.  .ced file needed.'];    [msg]=ep_errorMsg(msg);    returnend;EEGchans=find(strcmp('EEG',data.chanTypes));if (length([data.eloc(EEGchans).theta]) < length(data.eloc(EEGchans))) || (length([data.eloc(EEGchans).radius]) < length(data.eloc(EEGchans)))    msg{1}=['Error: Aborting preprocessing run.  The file ' sessionFiles{1} ' is missing coordinates for channels:'];    msg{2}=[];    for i=1:length(data.eloc)        if isempty(data.eloc(i).theta) || isempty(data.eloc(i).radius)            msg{2}=[msg{2} data.eloc(i).labels ';'];        end;    end;    [msg]=ep_errorMsg(msg);    returnend;if isempty(data.data)    msg{1}=['Error: The file ' sessionFiles{1} ' had no data left to correct after additions were removed.'];    [msg]=ep_errorMsg(msg);    returnend;if ~isempty(eog) && ~isempty(data.montage)    disp('Montage info will override eog channel settings.');end;nChans=length(data.chanNames);if badDataCriteria.fMRI    if ~strcmp(data.dataType,'continuous')        msg{1}=['Error: Files must be continuous data type to correct for fMRI artifacts.'];        [msg]=ep_errorMsg(msg);        return    end;    switch badDataCriteria.fMRI        case 1            disp('Using fMRIb EEGlab plugin to perform fMRI artifact correction.');            disp('R.K. Niazy, C.F. Beckmann, G.D. Iannetti, J.M. Brady, and S.M. Smith (2005) Removal of FMRI environment artifacts from EEG data using optimal basis sets. NeuroImage 28 (3), pages 720-737.');            if ~exist('firls')                msg{1}=['Error: Must have Signal Processing Toolbox installed to perform fMRI artifact correction.'];                msg{2}=['Consider switching to AMRI option using Preprocessing Preferences setting.'];                [msg]=ep_errorMsg(msg);                return            end;            if ~exist('fmrib_pas','file')                msg{1}=['Error: Must have fMRIb EEGlab plugin installed to perform fMRI artifact correction.'];                [msg]=ep_errorMsg(msg);                return            end;        case 2            disp('Using AMRI EEG fMRI Toolbox to perform fMRI artifact correction.');            disp('Liu Z, de Zwart JA, van Gelderen P, Kuo L-W, Duyn JH, Statistical feature extraction for artifact removal from concurrent fMRI-EEG recordings, NeuroImage (2011), doi:10.1016/j.neuroimage.2011.10.042.');            if ~exist('amri_eeg_rpeak','file')                msg{1}=['Error: Must have AMRI EEG fMRI Toolbox installed to perform fMRI artifact correction.'];                [msg]=ep_errorMsg(msg);                return            end;        otherwise            msg{1}=['Error: fMRI option now recognized.'];            [msg]=ep_errorMsg(msg);            return    end;    eventValues={data.events{1}.value}';    eventValues=unique(cellfun(@num2str,eventValues(find(~cellfun(@isempty,eventValues))),'UniformOutput',false'));    eventValues=sort(eventValues);    [selected,ok] = listdlg('PromptString',['Choose TR event marker.'],'ListString',eventValues,'SelectionMode','single');    if ~ok        disp('Cancelling preprocessing run.');        return    end;    TRmarker=eventValues{selected};end;if ~strcmp(blinkTemplate,'none') && ~strcmp(data.dataType,'single_trial')    disp('Warning: blink correction works best with single trial data.');end;if ~strcmp(blinkTemplate,'none') && strcmp(data.dataType,'single_trial') && isempty(baseline)    disp('Warning: blink correction works best with baseline corrected single trial data.');end;if strcmp(badDataCriteria.trialMode,'fix') && ~strcmp(data.dataType,'single_trial')    disp('Warning: movement correction works best with single trial data.');    disp('Otherwise the epochs used for movement correction may not correspond to the segments, if the intention is to segment the data, resulting in discontinuities.');    disp('Likewise, such discontinuities could affect spectral measures if the epochs do not correspond with the spectral windows.');end;%Check to make sure the files all have the same number of channels.badList=[];for theFile=2:length(sessionFiles)    Name2=deblank(sessionFiles{theFile});    thisReadArg2=readArg;    thisReadArg2{end+1}='file';    thisReadArg2{end+1}=Name2;    thisReadArg2{end+1}='silent';    thisReadArg2{end+1}='on';    thisReadArg2{end+1}='ced';    thisReadArg2{end+1}=data.ced; %assume they all have the same channel coordinates    thisReadArg2{end+1}='montage';    thisReadArg2{end+1}=data.montage; %assume they all have the same montage    data2=ep_readData(thisReadArg2);    if ~isempty(data2)        [data2]=ep_stripAdds(data2);        if (nChans ~= length(data2.chanNames))            logMsg=['Warning: The file ' sessionFiles{theFile} ' has a different set of electrodes from ' sessionFiles{1} '.'];            finalLog{end+1}=logMsg;        end;    else        logMsg=['Warning: The file ' sessionFiles{theFile} ' was not successfully read.  Dropping from batch run.'];        disp(logMsg);        finalLog{end+1}=logMsg;        badList(end+1)=theFile;    end;end;sessionFiles(badList)=[];if ~isempty(eog)    logMsg=['Using manually specified EOG channels.'];    disp(logMsg);    finalLog{end+1}=logMsg;    if max(eog2) > length(data.chanNames)        msg{1}='EOG channel numbers larger than number of channels in the data.';        [msg]=ep_errorMsg(msg);        return    end;else    eog=ep_findEOGchans(data.eloc);end;elecDistances=ep_closestChans(data.eloc);if isempty(eog)    msg{1}='No EOG channels specified.';    [msg]=ep_errorMsg(msg);    returnend;logMsg=['The blink channels are: LUVEOG(' num2str(eog.LUVEOG) ') RUVEOG(' num2str(eog.RUVEOG) ') LLVEOG(' num2str(eog.LLVEOG) ') RLVEOG(' num2str(eog.RLVEOG) ').'];disp(logMsg);finalLog{end+1}=logMsg;logMsg=['The saccade channels are: LHEOG(' num2str(eog.LHEOG) ') RHEOG(' num2str(eog.RHEOG) ').'];disp(logMsg);finalLog{end+1}=logMsg;logMsg=['Minimum number of good trials per cell to avoid warning message is: ' num2str(minTrialsPerCell) '.'];disp(logMsg);finalLog{end+1}=logMsg;if badDataCriteria.window    logMsg=['Moving average window for smoothing during bad channel detection: ' num2str(badDataCriteria.window) ' ms.'];else    logMsg='Moving average window for smoothing during bad channel detection: OFF.';end;disp(logMsg);finalLog{end+1}=logMsg;if badDataCriteria.window    logMsg=['Difference from minimum to maximum for bad channel: ' num2str(badDataCriteria.minmax) ' 였.'];else    logMsg='Difference from minimum to maximum for bad channel: OFF.';end;disp(logMsg);finalLog{end+1}=logMsg;if badDataCriteria.window    logMsg=['Percent of bad channels exceeded to declare bad trial, rounding down: ' num2str(badDataCriteria.badnum) '%.'];else    logMsg='Percent of bad channels exceeded to declare bad trial, rounding down: OFF.';end;disp(logMsg);finalLog{end+1}=logMsg;if badDataCriteria.neighbors    logMsg=['Number of electrodes considered to be neighbors: ' num2str(badDataCriteria.neighbors) '.'];else    logMsg='Number of electrodes considered to be neighbors: NONE.';end;disp(logMsg);finalLog{end+1}=logMsg;if badDataCriteria.badchan    logMsg=['Minimum predictability from neighbors to not be considered globally bad: ' num2str(badDataCriteria.badchan) '.'];else    logMsg='Minimum predictability from neighbors to not be considered globally bad: OFF.';end;disp(logMsg);finalLog{end+1}=logMsg;if badDataCriteria.maxneighbor    logMsg=['Maximum difference from most similar neighboring electrode to be considered bad: ' num2str(badDataCriteria.maxneighbor) ' 였.'];else    logMsg='Maximum difference from most similar neighboring electrode to be considered bad: OFF.';end;disp(logMsg);finalLog{end+1}=logMsg;logMsg=['Blink template option is: ' blinkTemplate '.'];disp(logMsg);finalLog{end+1}=logMsg;if badDataCriteria.blink && ~strcmp(blinkTemplate,'none')    logMsg=['Threshold correlation with blink template: ' num2str(badDataCriteria.blink) '.'];else    logMsg='Blink correction: OFF.';end;disp(logMsg);finalLog{end+1}=logMsg;if badDataCriteria.sacpot && ~strcmp(sacctemplate,'none')    logMsg=['Saccade Potential Threshold: ' num2str(badDataCriteria.sacpot) '.'];else    logMsg='Saccade correction: OFF.';end;disp(logMsg);finalLog{end+1}=logMsg;if badDataCriteria.detrend    logMsg=['Detrend data: ON.'];else    logMsg='Detrend data: OFF.';end;disp(logMsg);finalLog{end+1}=logMsg;if badDataCriteria.badtrials    logMsg=['Percentage of good trials chan is bad to declare a channel globally bad: ' num2str(badDataCriteria.badtrials) '%.'];else    logMsg='Percentage of good trials chan is bad to declare a channel globally bad: NONE.';end;disp(logMsg);finalLog{end+1}=logMsg;if badDataCriteria.movefacs && strcmp(badDataCriteria.trialMode,'fix')    logMsg=['Number of factors to retain when correcting movement artifacts: ' num2str(badDataCriteria.movefacs) '.'];else    logMsg='Movement artifact correction: NONE.';end;disp(logMsg);finalLog{end+1}=logMsg;if strcmp(badDataCriteria.trialMode,'fix')    logMsg=['Maximum voltage difference allowed when correcting movement artifacts: ' num2str(badDataCriteria.trialminmax) '.'];    disp(logMsg);    finalLog{end+1}=logMsg;end;if badDataCriteria.EMG    logMsg=['Minimum ratio of signal power to EMG noise to retain during EMG correction: ' num2str(badDataCriteria.EMGratio) '.'];    disp(logMsg);    finalLog{end+1}=logMsg;    logMsg=['Hz threshold considered to be the lower bound of possible EMG frquencies during EMG correction: ' num2str(badDataCriteria.EMGthresh) '.'];    disp(logMsg);    finalLog{end+1}=logMsg;end;logMsg=['Bad channels and trials: ' badDataCriteria.channelMode '.'];disp(logMsg);finalLog{end+1}=logMsg;if ~isempty(baseline)    if ~any(diff(baseline)>1)        logMsg=['Samples used to baseline epochs: ' num2str(baseline(1)) ':' num2str(baseline(end)) '.'];    else        logMsg=['Samples used to baseline epochs: ' num2str(baseline) '.'];    end;    disp(logMsg);    finalLog{end+1}=logMsg;end;if ~isempty(timePoints)    if ~any(diff(baseline)>1)        logMsg=['Samples used to baseline epochs: ' num2str(timePoints(1)) ':' num2str(timePoints(end)) '.'];    else        logMsg=['Samples used to baseline epochs: ' num2str(timePoints) '.'];    end;    disp(logMsg);    finalLog{end+1}=logMsg;end;logMsg=['Editing mode option is: ' editMode '.'];disp(logMsg);finalLog{end+1}=logMsg;tempVar=fix(clock);if length(sessionFiles) > 1    fid=fopen([activeDirectory filesep 'Artifact_Correction_Log ' num2str(length(sessionFiles)) '-files ' date sprintf('-%d-%d-%d',tempVar(4:6)) '.txt'],'w');else    [pathstr, fileName, ext]=fileparts(sessionFiles{1});    fid=fopen([activeDirectory filesep 'Artifact_Correction_Log ' deblank(fileName) ' ' date sprintf('-%d-%d-%d',tempVar(4:6)) '.txt'],'w');end;if (fid == -1)    disp('Error: Unable to start log file.');    returnend;baselineChanged=0;pointsChanged=0;for session = 1:sessionNum    Name=deblank(sessionFiles{session});    [pathstr, fileName, ext]=fileparts(Name);        logMsg='**************************************************************';    disp(logMsg);    finalLog{end+1}=logMsg;    logMsg=['Working on: ' Name '.'];    disp(logMsg);    finalLog{end+1}=logMsg;        if session > 1        thisReadArg=readArg;        thisReadArg{end+1}='file';        thisReadArg{end+1}=Name;        thisReadArg{end+1}='ced';        thisReadArg{end+1}=data.ced; %assume they all have the same channel coordinates        thisReadArg{end+1}='montage';        thisReadArg{end+1}=data.montage; %assume they all have the same montage        SMIsuffix=EPmain.preferences.general.SMIsuffix;        if ~isempty(SMIsuffix)            thisReadArg{end+1}='SMIsuffix';            thisReadArg{end+1}=SMIsuffix;        end;        specSuffix=EPmain.preferences.general.specSuffix;        if ~isempty(specSuffix)            thisReadArg{end+1}='specSuffix';            thisReadArg{end+1}=specSuffix;        end;        subjectSpecSuffix=EPmain.preferences.general.subjectSpecSuffix;        if ~isempty(subjectSpecSuffix)            thisReadArg{end+1}='subjectSpecSuffix';            thisReadArg{end+1}=subjectSpecSuffix;        end;        data=ep_readData(thisReadArg);        [data]=ep_stripAdds(data);    end;    if ~any(strcmp(data.dataType,{'single_trial','continuous','average'}))        logMsg=['Error: The file type ' data.dataType ' is not currently supported by this function.'];        disp(logMsg);        finalLog{end+1}=logMsg;        continue    end;        if length(data.facNames) > 1        logMsg=['Error: This function is not intended for application to factor data.'];        disp(logMsg);        finalLog{end+1}=logMsg;        continue    end;        if badDataCriteria.fMRI        if ~strcmp(data.dataType,'continuous')            logMsg=['Error: Files must be continuous data type to correct for fMRI artifacts.'];            disp(logMsg);            finalLog{end+1}=logMsg;            continue        end;    end;        if ~isempty(data.freqNames)        logMsg=['Error: This function is not intended for application to FFT data.'];        disp(logMsg);        finalLog{end+1}=logMsg;        continue    end;        if strcmp(data.reference.type,'CSD')        logMsg=['Error: This function is not intended for application to CSD data.'];        disp(logMsg);        finalLog{end+1}=logMsg;        continue    end;        if isempty(data.data)        logMsg=['Error: The file had no data left to correct after additions were removed.'];        disp(logMsg);        finalLog{end+1}=logMsg;        continue    end;        if baselineChanged        baselineChanged=0;        baseline=baselineTemp;    end;    if strcmp(data.dataType,'continuous') && ~isempty(baseline)        baselineTemp=baseline;        baseline=[];        baselineChanged=1;        logMsg=['This is continuous data so baseline correction is being deactivated.'];        disp(logMsg);        finalLog{end+1}=logMsg;    end;        if pointsChanged        pointsChanged=0;        timePoints=timePointsTemp;    end;    if strcmp(data.dataType,'continuous') && ~isempty(timePoints)        timePointsTemp=timePoints;        timePoints=[];        pointsChanged=1;        logMsg=['This is continuous data so Points is being deactivated.'];        disp(logMsg);        finalLog{end+1}=logMsg;    end;        if isempty(strcmp(data.trialSpecNames,'edit'))        data.trialSpecNames{end+1}='edit';        data.trialSpecs(:,end+1)=-1;    end;        numSamples=length(data.timeNames);    numChans=length(data.chanNames);    numSubs=length(data.subNames);        if (max(timePoints) > numSamples)        logMsg=['Timepoints samples larger than epoch size itself for ' Name '.\n  Setting equal to the epoch size.'];        disp(logMsg);        finalLog{end+1}=logMsg;        timePoints=timePoints(find(timePoints<=numSamples));    end;        if (max(timePoints) < 1)        logMsg=['Timepoints samples less than one for ' Name '.\n  Ignoring numbers less than one.'];        disp(logMsg);        finalLog{end+1}=logMsg;        timePoints=timePoints(find(timePoints>=1));    end;        %trim data to selected time points    if ~isempty(timePoints)        [data]=ep_selectData(data,{[],[timePoints],[],[],[],[]});        numSamples=length(data.timeNames);    end;        if (min(baseline) < 1)        logMsg=['Baseline samples less than one for ' Name '.\n  Ignoring numbers less than one.'];        disp(logMsg);        finalLog{end+1}=logMsg;        baseline=baseline(find(baseline>=1));    end;        if (max(baseline) > numSamples)        logMsg=['Baseline samples larger than epoch size itself for ' Name '.\n  Setting equal to the epoch size.'];        disp(logMsg);        finalLog{end+1}=logMsg;        baseline=baseline(find(baseline<=numSamples));    end;        if ~any(strcmp('origReference',inputSet)) %if reference not specified, default to data file's settings.        origRefChan= data.reference.original;    end;        if ~any(strcmp('currReference',inputSet)) %if reference not specified, default to data file's settings.        currRefChan= data.reference.current;        if isempty(currRefChan)            currRefChan=origRefChan;        end;    end;        if ~isempty(origRefChan)        if length(origRefChan) > 1            logMsg=['The channels ' num2str(origRefChan(:)') ' are marked as being the original references.'];        elseif length(origRefChan) ==1            logMsg=['The channel ' num2str(origRefChan) ' is marked as being the original reference.'];        end;        data.reference.type='REG';        data.reference.original=origRefChan;        disp(logMsg);        finalLog{end+1}=logMsg;    else        logMsg=['No channels marked as being the original reference channel.'];        disp(logMsg);        finalLog{end+1}=logMsg;    end;        if ~isempty(currRefChan)        data.reference.type='REG';        if strcmp(currRefChan,'AVG')            logMsg=['The current reference is the average reference.'];            data.reference.type='AVG';            data.reference.current=[];        elseif length(currRefChan) > 1            logMsg=['The channels ' num2str(currRefChan(:)') ' are marked as being the current references.'];            data.reference.current=currRefChan;            if max(currRefChan) > length(data.chanTypes)                disp(['Error: One or more of the reference channels do not exist.  Skipping file: ' Name]);                continue            end;            if any(~strcmp('EEG',data.chanTypes(currRefChan)))                disp(['Error: One or more of the reference channels are labeled as not being EEG channels.  Skipping file: ' Name]);                continue            end;        elseif length(currRefChan) ==1            logMsg=['The channel ' num2str(currRefChan) ' is marked as being the current reference.'];            data.reference.current=currRefChan;            if currRefChan > length(data.chanTypes)                disp(['Error: The indicated reference channel does not exist.  Skipping file: ' Name]);                continue            end;            if ~strcmp('EEG',data.chanTypes(currRefChan))                disp(['Error: The reference channel is labeled as not being an EEG channel.  Skipping file: ' Name]);                continue            end;        end;        disp(logMsg);        finalLog{end+1}=logMsg;    else        logMsg=['No channels marked as being the current reference channel.'];        disp(logMsg);        finalLog{end+1}=logMsg;    end;        if ~noFigure        %determine number of subplots needed for summary figure        numGraphs=1; %start        if badDataCriteria.detrend || ~isempty(baseline)            numGraphs=numGraphs+1; %baseline correction graph        end;        if badDataCriteria.fMRI            numGraphs=numGraphs+1; %fMRI correction graph        end;        if ~strcmp(sacctemplate,'none')            numGraphs=numGraphs+4; %saccade correction graph        end;        if badDataCriteria.blink && ~strcmp(blinkTemplate,'none')            numGraphs=numGraphs+2; %blink correction graph        end;        if badDataCriteria.trialminmax && strcmp(badDataCriteria.trialMode,'fix')            numGraphs=numGraphs+2; %movement correction graph        end;        if badDataCriteria.EMG            numGraphs=numGraphs+2; %EMG correction graph        end;        if badDataCriteria.alpha            numGraphs=numGraphs+2; %alpha correction graph        end;        if any(strcmp(editMode,{'automatic','both'}))            numGraphs=numGraphs+2; %bad data correction graph        end;        origData=data;    end;        %correct FMRI artifacts    if badDataCriteria.fMRI        if ~strcmp(data.dataType,'continuous')            disp(['Error: Files must be continuous data type to correct for fMRI artifacts.  Skipping file: ' Name]);            continue        end;                %correct gradient artifact        correctChans=setdiff(find(ismember(data.chanTypes,{'EEG','ECG'})),data.reference.current);        if isempty(correctChans)            disp(['Error: No non-reference EEG channels for correcting fMRI artifacts.  Skipping file: ' Name]);            continue        end;                tic        disp('Correcting gradient artifact');        try            switch badDataCriteria.fMRI                case 1                    lpf=0;                    L=10;                    window=30;                    Trigs=[data.events{1}(find(strcmp(TRmarker,{data.events{1}.value}))).sample];                    strig=1;                    anc_chk=1;                    tc_chk=0;                    Volumes=0;                    Slices=0;                    pre_frac=0.0300;                    exc=[];                    npc='auto';                    fmriEEG=fmrib_fastr(ep_ep2alleeg(ep_selectData(data,{correctChans,[],[],[],[],[]})),lpf,L,window,Trigs,strig,anc_chk,tc_chk,Volumes,Slices,pre_frac,exc,npc);                case 2                    fmriEEG = amri_eeg_gac(ep_ep2alleeg(ep_selectData(data,{correctChans,[],[],[],[],[]})),'trigger.name',TRmarker);                otherwise                    msg{1}=['Error: fMRI option not recognized.'];                    [msg]=ep_errorMsg(msg);                    return            end;        catch            disp(['Error: Unable to complete removing gradient artifacts.  Skipping file: ' Name]);            continue        end;                data.data(correctChans,:,1,1,1,1)=fmriEEG.data;                %find qrs peaks in ECG        ECGchan=find(strcmp('ECG',data.chanTypes));        EEGchan=find(strcmp('EEG',data.chanTypes));        if isempty(ECGchan)            disp(['Error: No ECG channel for correcting fMRI artifacts.  Skipping file: ' Name]);            continue        end;        if length(ECGchan) >1            disp(['Warning: Multiple ECG channels in file ' Name '.  Using only first ECG channel.']);            ECGchan=ECGchan(1);        end;                disp('Finding pulse beats');        try            switch badDataCriteria.fMRI                case 1                    ECGchan=find(strcmp('ECG',data.chanTypes(correctChans)));                    Peaks=fmrib_qrsdetect(ep_ep2alleeg(ep_selectData(data,{correctChans,[],[],[],[],[]})),ECGchan);                    for iPeak=1:length(Peaks)                        data.events{1}(end+1).value='qrs';                        data.events{1}(end).type='trigger';                        data.events{1}(end).duration=0;                        data.events{1}(end).sample=Peaks(iPeak);                        data.events{1}(end).keys=struct('code','','data','','datatype','','description','');                    end;                case 2                    addedField=0;                    if ~isfield(data.events{1},'urevent')                        data.events{1}(1).urevent=[];                        addedField=1;                    end;                    fmriEEG = amri_eeg_rpeak(ep_ep2alleeg(ep_selectData(data,{EEGchan,[],[],[],[],[]})),ep_ep2alleeg(ep_selectData(data,{ECGchan,[],[],[],[],[]})));                    if addedField                        data.events{1}=rmfield(data.events{1},'urevent');                    end;                    eventIndex=find(strcmp('R',{fmriEEG.event.type}));                    for iEvent=1:length(eventIndex)                        data.events{1}(end+1).value='R';                        data.events{1}(end).type='artifact';                        data.events{1}(end).duration=fmriEEG.event(eventIndex(iEvent)).duration;                        data.events{1}(end).sample=fmriEEG.event(eventIndex(iEvent)).latency;                        data.events{1}(end).keys=struct('code','','data','','datatype','','description','');                    end;                otherwise                    msg{1}=['Error: fMRI option not recognized.'];                    [msg]=ep_errorMsg(msg);                    return            end;        catch            disp(['Error: Unable to complete detecting pulse beats.  Skipping file: ' Name]);            continue        end;                %correct BCG artifact        disp('Correcting ballistocardiogram artifact');        correctChans=setdiff(find(strcmp('EEG',data.chanTypes)),data.reference.current);        try            switch badDataCriteria.fMRI                case 1                    fmriEEG = fmrib_pas(ep_ep2alleeg(ep_selectData(data,{correctChans,[],[],[],[],[]})),Peaks,'obs',4);                case 2                    fmriEEG = amri_eeg_cbc(ep_ep2alleeg(ep_selectData(data,{correctChans,[],[],[],[],[]})),ep_ep2alleeg(ep_selectData(data,{ECGchan,[],[],[],[],[]})));                    eventIndex=find(strcmp('R',{data.events{1}.value}));                    for iEvent=1:length(eventIndex)                        data.events{1}(eventIndex(iEvent)).value='qrs';                    end;                otherwise                    msg{1}=['Error: fMRI option not recognized.'];                    [msg]=ep_errorMsg(msg);                    return            end;        catch            disp(['Error: Unable to complete removing BCG artifacts.  Skipping file: ' Name]);            continue        end;        data.data(correctChans,:,1,1,1,1)=fmriEEG.data;                subjectTime = floor(toc/60);        logMsg=['The file took ' num2str(subjectTime) ' minutes to process for fMRI artifacts.'];        disp(logMsg);        finalLog{end+1}=logMsg;    end;        tic %start clock    [chunkSizes] = ep_chunkInputFile(data, Name, chunkSize);    chunkNum=length(chunkSizes);    if chunkNum > 1        logMsg=['The file is being split into ' num2str(chunkNum) ' files due to its size.'];        disp(logMsg);        finalLog{end+1}=logMsg;        logMsg=['If you think your computer has enough RAM to process the file without splitting it, change the Size of Chunks preference setting.'];        disp(logMsg);        finalLog{end+1}=logMsg;    end;        if ~noFigure        graphCounter=1;        trialdata=reshape(origData.data,numChans,[]);        if badDataCriteria.fMRI            fmriEEGtrialdata=reshape(fmriEEG.data,length(correctChans),[]);        end;        for iChunk=1:chunkNum            butterflyFig(iChunk)=figure('Name',[deblank(fileName) '-' num2str(iChunk)],'NumberTitle','off','Position',[201 1 400 scrsz(4)], 'MenuBar', 'none');            colormap jet;                        displayPeriod=chunkSizes(iChunk);    %Number of timepoints to graph in display.            decimateSamples=ceil(max(1,displayPeriod/10000));                        for iGraph=1:numGraphs                %                 subplot(numGraphs,1,iGraph), plot([1:decimateSamples:displayPeriod],zeros(1,length([1:decimateSamples:displayPeriod])));                axis([1 displayPeriod -200 200])                set(gca,'XTickLabel','','XTick',[]);            end;                        subplot(numGraphs,1,graphCounter), plot([1:decimateSamples:displayPeriod],trialdata(EEGchans,sum(chunkSizes(1:iChunk-1))+1:decimateSamples:sum(chunkSizes(1:iChunk-1))+displayPeriod));            axis([1 displayPeriod -200 200])            set(gca,'XTickLabel','','XTick',[]);            title('raw data','Interpreter','none');            if badDataCriteria.fMRI                subplot(numGraphs,1,graphCounter+1), plot([1:decimateSamples:displayPeriod],fmriEEGtrialdata(correctChans,sum(chunkSizes(1:iChunk-1))+1:decimateSamples:sum(chunkSizes(1:iChunk-1))+displayPeriod));                axis([1 displayPeriod -200 200])                set(gca,'XTickLabel','','XTick',[]);                title('fMRI arifact corrected','Interpreter','none');            end;            drawnow        end;        graphCounter=graphCounter+1;        if badDataCriteria.fMRI            graphCounter=graphCounter+1;            clear fmriEEGtrialdata fmriEEG;        end;        clear trialdata origData;    end;        startCounter=graphCounter;    for theSubject=1:numSubs        graphCounter=startCounter;        badSubject=0;        if numSubs > 1            logMsg=['   Subject: ' data.subNames{theSubject}];            disp(logMsg);            finalLog{end+1}=logMsg;        end;                %detrend and baseline correct data        if badDataCriteria.detrend || ~isempty(baseline)            [outputLog, graphCounter] = ep_detrendChunk(Name, 1, chunkNum, theSubject, badDataCriteria.detrend, baseline, butterflyFig, graphCounter, numGraphs);            finalLog(end+1:end+length(outputLog))=outputLog;        end;                %detect global bad and shorted channels        if any(strcmp(editMode,{'automatic','both'}))            [badChansDetected shortChansDetected, outputLog]=ep_detectBadChans(data, badDataCriteria, theSubject);            finalLog(end+1:end+length(outputLog))=outputLog;        else            shortChansDetected=[];            badChansDetected=[];        end;        if badChansDetected == -1            logMsg=['This file encountered an error while trying to detect bad channels and so will not be artifact corrected.'];            disp(logMsg);            finalLog{end+1}=logMsg;            badSubject=1;        end;                theBadChans=unique([badChansDetected; badChans{theFile}]);        theBadChans=theBadChans(find(theBadChans>0)); %exclude zero as a bad channel        if ~isempty(theBadChans)            logMsg=['Global bad channels: ' num2str(theBadChans')];        else            logMsg='Global bad channels: None';        end;        finalLog{end+1}=logMsg;        if ~any(strcmp(editMode,{'automatic','both'}))            logMsg='(automatic bad channel detection was deactivated)';            finalLog{end+1}=logMsg;        end;                if badDataCriteria.badnum            if length(theBadChans) > floor(numChans*(badDataCriteria.badnum/100))                if length(data.subNames) > 1                    logMsg=['For subject ' data.subNames{theSubject} ' there were too many bad channels.'];                else                    logMsg=['This file has too many bad channels.'];                end;                disp(logMsg);                finalLog{end+1}=logMsg;                badSubject=1;            end;        end;                if badDataCriteria.neighbors && badDataCriteria.noadjacent && ~isempty(theBadChans) %neighboring bad channels?            warn=0;            for iChan=1:length(theBadChans)                chan=theBadChans(iChan);                [B IX]=sort(elecDistances(chan,:));                neighbors=IX(2:badDataCriteria.neighbors+1);                if ~isempty(intersect(theBadChans,neighbors))                    warn=1;                    break                end;            end;            if warn                if length(data.subNames) > 1                    logMsg=['Warning: Subject ' data.subNames{theSubject} ' has neighboring globally bad channels.'];                else                    logMsg=['Warning: Subject has neighboring globally bad channels.'];                end;                disp(logMsg);                finalLog{end+1}=logMsg;            end;        end;                if ~badSubject                        %interp bad EOG channels if either saccade or blink correcting.            interpChans=[];            if ~strcmp(sacctemplate,'none') || (badDataCriteria.blink && ~strcmp(blinkTemplate,'none'))                if any(ismember(eog.LHEOG,theBadChans))                    logMsg='Temporarily interpolating left HEOG channel to enable artifact correction.';                    disp(logMsg);                    finalLog{end+1}=logMsg;                    theBadChans=setdiff(theBadChans,eog.LHEOG);                    interpChans(end+1,1)=eog.LHEOG;                end;                if any(ismember(eog.RHEOG,theBadChans))                    logMsg='Temporarily interpolating right HEOG channel to enable artifact correction.';                    disp(logMsg);                    finalLog{end+1}=logMsg;                    theBadChans=setdiff(theBadChans,eog.RHEOG);                    interpChans(end+1,1)=eog.RHEOG;                end;                if any(ismember(eog.LUVEOG,theBadChans))                    logMsg='Temporarily interpolating left upper VEOG channel to enable artifact correction.';                    disp(logMsg);                    finalLog{end+1}=logMsg;                    theBadChans=setdiff(theBadChans,eog.LUVEOG);                    interpChans(end+1,1)=eog.LUVEOG;                end;                if any(ismember(eog.RUVEOG,theBadChans))                    logMsg='Temporarily interpolating right upper VEOG channel to enable artifact correction.';                    disp(logMsg);                    finalLog{end+1}=logMsg;                    theBadChans=setdiff(theBadChans,eog.RUVEOG);                    interpChans(end+1,1)=eog.RUVEOG;                end;                if any(ismember(eog.LLVEOG,theBadChans))                    logMsg='Temporarily interpolating left lower VEOG channel to enable artifact correction.';                    disp(logMsg);                    finalLog{end+1}=logMsg;                    theBadChans=setdiff(theBadChans,eog.LLVEOG);                    interpChans(end+1,1)=eog.LLVEOG;                end;                if any(ismember(eog.RLVEOG,theBadChans))                    logMsg='Temporarily interpolating right lower VEOG channel to enable artifact correction.';                    disp(logMsg);                    finalLog{end+1}=logMsg;                    theBadChans=setdiff(theBadChans,eog.RLVEOG);                    interpChans(end+1,1)=eog.RLVEOG;                end;                                for iChunk=1:chunkNum                    eval(['load ''' deblank(Name) '''-' num2str(iChunk) '.mat']);                    trialdata=reshape(dataChunk.data(:,:,:,theSubject),numChans,[]);                    EEGchans=find(strcmp('EEG',dataChunk.chanTypes));                    chans = setdiff(EEGchans,theBadChans);                                        if ~isempty(interpChans)                        disp(['Interpolating ' num2str(size(trialdata,2)) ' time points.']);                        dataChunk.interpChans=trialdata(interpChans,:);                        [trialdata(interpChans,:)]=ep_interpChans(trialdata(chans,:), dataChunk.eloc(chans), dataChunk.eloc(interpChans));                    end;                                        dataChunk.data(:,:,:,theSubject)=reshape(trialdata,size(dataChunk.data(:,:,:,theSubject)));                    eval (['save ''' deblank(Name) '''-' num2str(iChunk) '.mat dataChunk;']);                end;            end;                        templates.sacPot=[];            templates.hSaccades=[];            templates.vSaccades=[];            templates.blinks=[];            excludePoints=cell(chunkNum,1);            blinkDetect=0;            %fix saccade potentials            if ~strcmp(sacctemplate,'none')                %identify blink time points to exclude them from the saccade potential correction procedure                if badDataCriteria.blink && ~strcmp(blinkTemplate,'none')                    logMsg=['Starting preliminary saccade potential scan to exclude them from the preliminary blink detection routine.'];                    disp(logMsg);                    finalLog{end+1}=logMsg;                                        [totsaccadeTrialNum, temp, outputLog, graphCounter] = ep_fixSaccadePotential(Name, [Name 'SP'], 1, chunkNum, badDataCriteria, theBadChans, eog, sacctemplate, saccadeFile, currRefChan, excludePoints, [], graphCounter, numGraphs, theSubject);                    finalLog(end+1:end+length(outputLog))=outputLog;                    inFileName=[Name 'SP'];                    if isempty(temp)                        logMsg=['Something went wrong with the preliminary saccade potential run of file ' Name '.  Skipping the operation.'];                        disp(logMsg);                        finalLog{end+1}=logMsg;                        inFileName=Name;                    end;                                        logMsg=['Starting preliminary blink scan to identify which time points to exclude from the saccade and the saccade potential corrections.'];                    disp(logMsg);                    finalLog{end+1}=logMsg;                    disp('Using EEGlab function runica to perform Infomax rotation to identify blink periods.');                    [blinkTrialNum, excludePoints, temp, outputLog, graphCounter] = ep_fixBlink(inFileName, [Name 'SP'], 1, chunkNum, badDataCriteria, theBadChans, eog, blinkTemplate, blinkFile, baseline, currRefChan, [], graphCounter, numGraphs, theSubject);                    blinkDetect=1;                    finalLog(end+1:end+length(outputLog))=outputLog;                    if isempty(temp)                        logMsg=['Something went wrong with the preliminary blink detection run of file ' Name '.  Skipping the operation.'];                        disp(logMsg);                        finalLog{end+1}=logMsg;                    end;                                        for iChunk = 1:chunkNum                        delete([Name 'SP-' num2str(iChunk) '.mat']); %clean up temporary work files                    end;                end;                                if blinkDetect                    logMsg=['Starting final saccade potential correction, excluding blink time points.'];                else                    logMsg=['Starting final saccade potential correction.'];                end;                disp(logMsg);                finalLog{end+1}=logMsg;                [totsaccadeTrialNum, outTemplate, outputLog, graphCounter] = ep_fixSaccadePotential(Name, Name, 1, chunkNum, badDataCriteria, theBadChans, eog, sacctemplate, saccadeFile, currRefChan, excludePoints, butterflyFig, graphCounter, numGraphs, theSubject);                finalLog(end+1:end+length(outputLog))=outputLog;                if isempty(outTemplate)                    logMsg=['Something went wrong with the saccade potential correction run of file ' Name '.  Skipping the operation.'];                    disp(logMsg);                    finalLog{end+1}=logMsg;                    outTemplate.sacPot=[];                end;                templates.sacPot=outTemplate.sacPot;                                %fix saccade artifacts                if blinkDetect                    logMsg=['Starting saccade correction, interpolating blink time points.'];                else                    logMsg=['Starting saccade correction.'];                end;                disp(logMsg);                finalLog{end+1}=logMsg;                [outTemplate, outputLog, graphCounter] = ep_fixSaccade(Name, 1, chunkNum, theBadChans, eog, sacctemplate, saccadeFile, badDataCriteria, currRefChan, excludePoints, butterflyFig, graphCounter, numGraphs, theSubject);                finalLog(end+1:end+length(outputLog))=outputLog;                if isempty(outTemplate)                    logMsg=['Something went wrong with the saccade correction run of file ' Name '.  Skipping the operation.'];                    disp(logMsg);                    finalLog{end+1}=logMsg;                    outTemplate.hSaccades=[];                    outTemplate.vSaccades=[];                end;                templates.hSaccades=outTemplate.hSaccades;                templates.vSaccades=outTemplate.vSaccades;            end;                        %fix blink artifacts            if badDataCriteria.blink && ~strcmp(blinkTemplate,'none')                if blinkDetect                    logMsg=['Starting final blink correction.'];                else                    logMsg=['Starting blink correction.'];                end;                disp('Using EEGlab function runica to perform Infomax rotation.');                [blinkTrialNum, blinkPoints, outTemplate, outputLog, graphCounter] = ep_fixBlink(Name, Name, 1, chunkNum, badDataCriteria, theBadChans, eog, blinkTemplate, blinkFile, baseline, currRefChan, butterflyFig, graphCounter, numGraphs, theSubject);                finalLog(end+1:end+length(outputLog))=outputLog;                if isempty(outTemplate)                    logMsg=['Something went wrong with the blink correction run of file ' Name '.  Skipping the operation.'];                    disp(logMsg);                    finalLog{end+1}=logMsg;                    outTemplate.blinks=[];                end;                templates.blinks=outTemplate.blinks;            end;                        %fix movement artifacts            if badDataCriteria.trialminmax && strcmp(badDataCriteria.trialMode,'fix')                [moveTrialNum outputLog, graphCounter] = ep_fixMovement(Name, 1, chunkNum, badDataCriteria, theBadChans, currRefChan, butterflyFig, graphCounter, numGraphs, theSubject, eog);                finalLog(end+1:end+length(outputLog))=outputLog;            else                moveTrialNum=[];            end;                        %fix EMG artifacts            if badDataCriteria.EMG                logMsg=['Starting EMG correction.'];                disp(logMsg);                finalLog{end+1}=logMsg;                if isempty(ver('signal'))                    logMsg=['EMG correction requires Signal Processing Toolbox'];                    disp(logMsg);                    finalLog{end+1}=logMsg;                else                    [outputLog, graphCounter] = ep_fixEMG(Name, 1, chunkNum, badDataCriteria, theBadChans, currRefChan, butterflyFig, graphCounter, numGraphs, theSubject);                end;            end;                        %fix alpha artifacts            if badDataCriteria.alpha                logMsg=['Starting alpha correction.'];                disp(logMsg);                finalLog{end+1}=logMsg;                [outputLog, graphCounter] = ep_fixAlpha(Name, 1, chunkNum, badDataCriteria, theBadChans, currRefChan, butterflyFig, graphCounter, numGraphs, theSubject);            end;                        %detect bad channels and trials            if any(strcmp(editMode,{'automatic','both'}))                [outputLog, theBadChans, badChanNum, badTrialNum] = ep_detectBadDataChunk(Name, 1, chunkNum, badDataCriteria, theBadChans, editMode, theSubject);                finalLog(end+1:end+length(outputLog))=outputLog;            else                badTrialNum=[];                badChanNum=[];            end;                        if badDataCriteria.badnum                if length(theBadChans) > floor(numChans*(badDataCriteria.badnum/100))                    logMsg=['This subject has too many bad channels.'];                    disp(logMsg);                    finalLog{end+1}=logMsg;                    badSubject=1;                end;            end;                        if badDataCriteria.neighbors && badDataCriteria.noadjacent %neighboring bad channels?                warn=0;                for iChan=1:length(theBadChans)                    chan=theBadChans(iChan);                    [B IX]=sort(elecDistances(chan,:));                    neighbors=IX(2:badDataCriteria.neighbors+1);                    if ~isempty(intersect(theBadChans,neighbors))                        warn=1;                        break                    end;                end;                if warn                    logMsg='Warning: Subject has neighboring globally bad channels.';                    disp(logMsg);                    finalLog{end+1}=logMsg;                end;            end;                        if strcmp(data.dataType,'single_trial')                [uniqueCellNames, m, CellNameIndex] = unique(data.cellNames);                cellGoodTrialCount=hist(CellNameIndex,length(unique(data.cellNames)));                for theTrial=1:length(badTrialNum)                    if badTrialNum(theTrial)                        cellGoodTrialCount(CellNameIndex(theTrial))=cellGoodTrialCount(CellNameIndex(theTrial))-1;                    end;                end;                                for theCell=1:length(cellGoodTrialCount)                    if cellGoodTrialCount(theCell) < minTrialsPerCell                        if cellGoodTrialCount(theCell) == 0                            logMsg=['Warning: Cell ' uniqueCellNames{theCell} ' has no good trials.'];                        elseif cellGoodTrialCount(theCell) == 1                            logMsg=['Warning: Cell ' uniqueCellNames{theCell} ' has only 1 good trial.'];                        else                            logMsg=['Warning: Cell ' uniqueCellNames{theCell} ' has only ' num2str(cellGoodTrialCount(theCell)) ' good trials.'];                        end;                        disp(logMsg);                        finalLog{end+1}=logMsg;                    end;                end;            end;                        if ~badSubject                theDots=findstr(Name,'.');                outName=Name;                if ~isempty(theDots)                    outName=Name(1:theDots(end)-1); %drop the suffix                end;                                %replace or mark bad channels                if ~isempty(interpChans)                    theBadChans=unique([interpChans; theBadChans]);                    for iChunk=1:chunkNum                        eval(['load ''' deblank(Name) '''-' num2str(iChunk) '.mat']);                        trialdata=reshape(dataChunk.data(:,:,:,theSubject),length(dataChunk.chanNames),[]);                        trialdata(interpChans,:)=dataChunk.interpChans;                        dataChunk=rmfield(dataChunk,'interpChans');                        dataChunk.data(:,:,:,theSubject)=reshape(trialdata,size(dataChunk.data(:,:,:,theSubject)));                        eval (['save ''' deblank(Name) '''-' num2str(iChunk) '.mat dataChunk;']);                    end;                end;                                if strcmp(badDataCriteria.channelMode,'replace')                    [outputLog, graphCounter] = ep_replaceBadDataChunks(Name, 1, chunkNum, theBadChans, butterflyFig, graphCounter, numGraphs, theSubject);                    finalLog(end+1:end+length(outputLog))=outputLog;                elseif strcmp(badDataCriteria.channelMode,'mark')                    [outputLog] = ep_markBadDataChunks(Name, 1, chunkNum, theBadChans, theSubject);                    finalLog(end+1:end+length(outputLog))=outputLog;                end;            end;                        if ~noFigure                if ~strcmp(sacctemplate,'none') || ~strcmp(blinkTemplate,'none')                    templateFig=figure('Name','Templates','NumberTitle','off','Position',[201 1 900 600], 'MenuBar', 'none');                    colormap jet;                    uicontrol('Style','text','String','Auto','FontSize',EPmain.fontsize,'Position',[100 500 50 20]);                    uicontrol('Style','text','String','File','FontSize',EPmain.fontsize,'Position',[300 500 50 20]);                    uicontrol('Style','text','String','Subtracted','FontSize',EPmain.fontsize,'Position',[500 500 50 20]);                    if ~isempty(templates.sacPot)                        uicontrol('Style','text','String','L Sac Pot','FontSize',EPmain.fontsize,'Position',[10 450 80 20]);                        uicontrol('Style','text','String','R Sac Pot','FontSize',EPmain.fontsize,'Position',[10 350 80 20]);                        if ~isempty(templates.sacPot.autoL)                            axes('Units','pixel','position',[100 400 100 100]);                            el_topoplot(templates.sacPot.autoL, data.eloc(EEGchans));                        end;                        if ~isempty(templates.sacPot.autoR)                            axes('Units','pixel','position',[100 300 100 100]);                            el_topoplot(templates.sacPot.autoR, data.eloc(EEGchans));                        end;                        if ~isempty(templates.sacPot.manual)                            axes('Units','pixel','position',[300 400 100 100]);                            el_topoplot(templates.sacPot.manual, data.eloc(EEGchans));                        end;                        if ~isempty(templates.sacPot.sacPotTopo)                            axes('Units','pixel','position',[500 400 100 100]);                            el_topoplot(templates.sacPot.sacPotTopo, data.eloc(EEGchans));                        end;                    end;                    if ~isempty(templates.hSaccades)                        uicontrol('Style','text','String','H Sacc','FontSize',EPmain.fontsize,'Position',[10 250 80 20]);                        if ~isempty(templates.hSaccades.auto)                            axes('Units','pixel','position',[100 200 100 100]);                            el_topoplot(templates.hSaccades.auto, data.eloc(EEGchans));                        end;                        if ~isempty(templates.hSaccades.manual)                            axes('Units','pixel','position',[300 200 100 100]);                            el_topoplot(templates.hSaccades.manual, data.eloc(EEGchans));                        end;                        if ~isempty(templates.hSaccades.hSaccadesTopo)                            axes('Units','pixel','position',[500 200 100 100]);                            el_topoplot(templates.hSaccades.hSaccadesTopo, data.eloc(EEGchans));                        end;                    end;                    if ~isempty(templates.vSaccades)                        uicontrol('Style','text','String','V Sacc','FontSize',EPmain.fontsize,'Position',[10 150 80 20]);                        if ~isempty(templates.vSaccades.auto)                            axes('Units','pixel','position',[100 100 100 100]);                            el_topoplot(templates.vSaccades.auto, data.eloc(EEGchans));                        end;                        if ~isempty(templates.vSaccades.manual)                            axes('Units','pixel','position',[300 100 100 100]);                            el_topoplot(templates.vSaccades.manual, data.eloc(EEGchans));                        end;                        if ~isempty(templates.vSaccades.vSaccadesTopo)                            axes('Units','pixel','position',[500 100 100 100]);                            el_topoplot(templates.vSaccades.vSaccadesTopo, data.eloc(EEGchans));                        end;                    end;                    if ~isempty(templates.blinks)                        uicontrol('Style','text','String','Blink','FontSize',EPmain.fontsize,'Position',[10 50 80 20]);                        if ~isempty(templates.blinks.auto)                            axes('Units','pixel','position',[100 1 100 100]);                            el_topoplot(templates.blinks.auto, data.eloc(EEGchans));                        end;                        if ~isempty(templates.blinks.manual)                            axes('Units','pixel','position',[300 1 100 100]);                            el_topoplot(templates.blinks.manual, data.eloc(EEGchans));                        end;                        if ~isempty(templates.blinks.blinkTopo)                            axes('Units','pixel','position',[500 1 100 100]);                            el_topoplot(templates.blinks.blinkTopo, data.eloc(EEGchans));                        end;                    end;                    if numSubs > 1                        stemName = [fileName '(' data.subNames{theSubject} ')'];                    else                        stemName = fileName;                    end;                                        try                        if isnumeric(templateFig)                            if ~isprop(templateFig,'Number')                                eval (['print -f' num2str(templateFig) ' -djpeg ''' pathstr filesep stemName '_templates.jpg''']);                            else                                eval (['print -f' num2str(templateFig.Number) ' -djpeg ''' pathstr filesep stemName '_templates.jpg''']);                            end;                        else                            print(templateFig,'-djpeg',[pathstr filesep stemName '_templates.jpg'])                        end;                    catch                        disp('Couldn''t save a copy of the template figure.  Perhaps your version of Matlab is not current.');                    end;                    close(templateFig);                end;            end;        end; %~bad subject    end; %subject        if ~noFigure        [pathstr, theName, ext]=fileparts(Name);        for iChunk=1:chunkNum            stemName = theName;            if chunkNum > 1                stemName=[stemName '-chunk' num2str(iChunk)];            end;            sameName=1;            theNumber=0;            fileName=stemName;            while sameName                sameName=0;                if exist([pathstr filesep fileName '.jpg'],'file')                    sameName=1;                end;                if sameName                    theNumber=theNumber+1;                    fileName=[stemName '-' num2str(theNumber)];                end;            end;                        if ishandle(butterflyFig(iChunk))                set(butterflyFig(iChunk),'PaperPositionMode','auto');                MATLABver=ver('MATLAB');                [a b]=strtok(MATLABver.Version,'.');                b=b(2:end);                                try                    if ~isprop(butterflyFig(iChunk),'Number')                        eval (['print -f' num2str(butterflyFig(iChunk)) ' -djpeg ''' pathstr filesep fileName  '.jpg''']);                    else                        eval (['print -f' num2str(butterflyFig(iChunk).Number) ' -djpeg ''' pathstr filesep fileName  '.jpg''']);                    end;                catch                    disp('Couldn''t save a copy of the artifact correction figure.  Perhaps your version of Matlab is not current.');                end;                close(butterflyFig(iChunk));            else                disp('Couldn''t save a copy of the artifact correction figure.  It seems to be gone.  Did you close it up with your mouse?');            end;        end;    end;        if badDataCriteria.fMRI        suffix='_bcg';    else        suffix='_e';    end;        [pathstr, name, ext] = fileparts(Name);    [fileSuffix,formatName]=ep_fileExtensions(outputFormat);        sameName=1;    theNumber=0;    fileNameSuffix=[pathstr filesep name suffix fileSuffix];    while sameName        sameName=0;        if exist(fileNameSuffix,'file')            sameName=1;        end;        if sameName            theNumber=theNumber+1;            fileNameSuffix=[pathstr filesep name suffix '-' num2str(theNumber) fileSuffix];        end;    end;        ep_rejoinChunks(Name, fileNameSuffix, outputFormat, chunkNum, EPmain.preferences.general.specSuffix,EPmain.preferences.general.subjectSpecSuffix, varargin);        for iChunk = 1:chunkNum        delete([Name '-' num2str(iChunk) '.mat']); %clean up temporary work files    end;        fileTime = floor(toc/60);    logMsg=['The file took ' num2str(fileTime) ' minutes to process.'];    disp(logMsg);    finalLog{end+1}=logMsg;    if (fileTime > (8 * 60)) && ismac        logMsg='The file took over eight hours to run.  Did you remember to turn off sleep mode?  It will turn off the Mac in the middle of a Matlab session.';        disp(logMsg);        finalLog{end+1}=logMsg;    end;    if (fileTime > (4 * 60)) && (chunkNum > 1)        logMsg='The file took over four hours to run.  Have you tried increasing the chunk size?  See the tutorial.';        disp(logMsg);        finalLog{end+1}=logMsg;    end;    for line=1:length(finalLog)        finalLog{line}=strrep(finalLog{line},'\','\\'); %slashes are mistaken as control characters.        finalLog{line}=strrep(finalLog{line},'%','%%'); %percentages are mistaken as control characters.        fprintf(fid,[finalLog{line} '\n']);    end    finalLog=[];    end; %sessionlogMsg='Done.';disp(logMsg);fprintf(fid,[logMsg '\n']);fclose(fid);