function [totblinkTrialNum, blinkPoints, templates, outputLog, graphCounter] = ep_fixBlink(inFile, outFile, startChunk, endChunk, badDataCriteria, badChans, eog, templateSource, blinkFile, baseline, refChan, butterflyFig, graphCounter, numGraphs, theSubject)%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% [totblinkTrialNum, blinkPoints, templates, outputLog, graphCounter] = ep_fixBlink(inFile, outFile, startChunk, endChunk, badDataCriteria, badChans, eog, templateSource, blinkFile, baseline, refChan, butterflyFig, graphCounter, numGraphs, theSubject)%%	Reads in file chunks generated by chunkInputFile function (should be set at a size small%	enough to fit in memory.  100,000 samples of 128chan data can be processed with ICA.%	Function runs through all the files given and outputs them as fixed chunks.%	chunks will still need to be rejoined.%%Inputs%	inFile:     filename (not including the .mat suffix or chunk number.  e.g., "NT5") and sourcepath.%	outFile:    filename (not including the .mat suffix or chunk number.  e.g., "NT5") and sourcepath.%	startChunk: starting chunk (usually 1)%   endChunk:   ending chunk%   badDataCriteria:  Criteria for detecting bad data.%       .window:    moving average window for smoothing%       .minmax:    difference from minimum to maximum for bad channel%       .trialminmax:  difference from minimum to maximum for bad trial%       .badnum:    percent of bad channels exceeded to declare bad trial, rounding down%       .hminmax:   difference from minimum to maximum for bad horizontal EOG%       .neighbors: number of electrodes considered to be neighbors%       .badchan:   maximum microvolt difference allowed from best matching neighbor%       .maxneighbor:   maximum microvolt difference allowed from best matching neighbor%       .blink:     threshold correlation with blink template, 0 to 1%       .saccade:     threshold correlation with saccade template, 0 to 1%       .saccademin:  µv Saccade Fac is the minimum HEOG voltage difference required to constitute a possible saccade.%       .detrend:   1 to detrend%       .badtrials: percentage of good trials chan is bad to declare a channel globally bad%       .replace:   1 to interpolate bad channels from neighbors.%       .noadjacent:1 to not allow adjacent bad channels (trial or subject declared bad)%       .movefacs  : number of factors to retain during movement correction.%       .channelMode: 'replace' to interpolate bad channels, 'mark' to mark them with a spike, and 'none' to do nothing.%       .trialMode: 'fix' to fix bad trial data and 'none' to do nothing.%       .saturation: followed by range of acceptable data values.  Time points with a channel outside this range will be excluded.%   badChans:   list of bad channels to exclude from blink detection process.%   eog:        EOG channels.%   templateSource:   source of blink template (fileTemplate: load 'blinks' file.  autoTemplate: automatically generate blink template.%                  bothTemplate: use both file and automatic template at the same time).%   blinkFile:  file with blink template.  Assumed to be in the same directory as the data file.%   baseline:   array of sample numbers to permanently baseline correct the trials with.  [] means don't correct.%   refChan:    Array of current reference channels.%   butterflyFig:  the handle for the output figure.  Otherwise, will open a new figure.%   graphCounter: the current subplot for the summary figure.%   numGraphs: the total number of subgraphs in the summary figure.%   theSubject: which subject of the file is being processed.%%   The input chunks are EP format data files.%%Outputs%	totblinkTrialNum: Total list of blink trials.%   blinkPoints: Array of points that fall within blink periods, numbering end-to-end for single-trial data. (cell array of number of chunks)%   templates: the templates used for the correction, both file and auto if both used.%       .blinks%           .manual: manual template from file (number of EEG channels,1)%           .auto: auto template (number of EEG channels,1)%   outputLog: output messages from blink fixing process%%	Saves files with blinks removed, replacing the original chunked files.%   If baseline option is used (provides better results, particularly when%   there are large DC swings in the recordings), then the output will be%   baselined.%% History:%% by Joseph Dien (10/00)% jdien07@mac.com%% modified 6/22/01 JD% added bad channel and threshold parameters.  Also changed chunkNum to startChunk and endChunk.%% modified 5/27/02 JD% added baseline correct feature.  Fix to bad chans so they are zeroed even if no blink factors.%% bugfix 10/11/02 JD% added fix to baseline feature for when a blink occurs during the baseline% period.  Output files will now be baselined.  Also, added check for chans% with zero variability.%% modified 10/20/02 JD% since ICA removal sometimes degrades trials without blinks, will now% remove blink components only for trials where the largest feature has the% topography of a blink (correlates .9 with raw EEG).%% modified 12/06/02 JD% Can automatically generate individualized blink template.  Maxed out VEOG time% points dropped from correction and baseline process and left intact (to trigger% eyeblink rejection in averaging program) since they can't be corrected% properly.  Added output log.%% modified 02/04/03  JD% Can now specify blink template file name.  Saves topoplots of blink facs.%  Added bothTemplate option.%% bugfix 4/1/04 JD% Allow for spaces in file names.%% bugfix 11/15/05 JD% Fixed bug that crashed program when a customized blink template was% specified.%% bugfix 7/24/06 JD% Contents of blink template no longer prints out on screen.  Added some error checking.%% modified 3/22/07 JD% Finished autotemplate feature.  Also now takes into account possibility% of blink recoveries (with an inverse topography).  Also now handles% different montages through EEG_hardware function.%% modified 2/17/08 JD% Checks to see if binary version of runica is installed and uses it if available.%% modified 11/17/08 JD% Eliminated topoplot of blink factors. Made baseline specification more flexible.%% modified 12/13/08 JD% Increased scaling for blink plots to make them more visible.%% modified 2/11/09 JD% Dropped trialsize input field.  No longer zeroes bad channels.  Replaced% threshold field with full badDataCriteria field.%% modified 3/14/09 JD% Changed to use EP format data to provide more flexibility with I/O functions.%% modified 3/17/09 JD% Only subtracted blink activity (that met variance reduced criterion) is shown for blink data figure.%% bugfix 4/16/09 JD% Fixed crash when overall blink direction equaled exactly zero.%% bugfix &  modified 7/14/09 JD% Fixed bothTemplate option, which was functioning the same as autoTemplate, ignoring the file template.% Changed output from list of blink facs to list of blink trials.  No longer zeroes out bad channels.% Includes list of blink trials in the data chunk.  Output figure can now be passed from function call.% blink file assumed to be in the directory of the data file.  Uses updated blink template format.%% modified 8/28/09 JD% Modified to use new option for binary runICA to control the output file names so that they can be cleaned up% and so that unpredictable crash from bug causing strange file names can be circumvented.%% modified 9/4/09 JD% Added refChan input to deal with mean mastoid data where the presence of the two reference channels (correlated -1)% was causing ICA problems.%% bugfix 10/17/09 JD% Crash when only one VEOG channel.%% modified 10/28/09 JD% Added option to disable preprocessing figure for low memory situations.%% bugfix 11/20/09 JD% Replaced "union" commands with "unique" commands because certain situations caused the "union" command to crash in% Matlab 2007.%% bugfix 12/3/09 JD% Additional check for ICA failure (denoted by imaginary numbers for weights).%% modified 2/11/10 JD% Will now work with subject average files with multiple subjects.% BlinkTrial no longer initialized to zero.%% modified & bugfix 5/15/10 JD% Made more memory efficient by reducing resolution of the blink plots to no more than 10000 points regardless of size of data.% Fixed when data is mean mastoid, not setting second reference channel to be inverse of the first reference channel.% Fixed crashes when explicit reference channel is present.%% modified 10/13/10 JD% For continuous files, data now divided into one second epochs and can be artifact rejected in an epochwise fashion% in same fashion as segmented data.%% modified 10/17/10 JD% Added support for HEOG saccade correction.%% bugfix 11/3/10 JD% Now handles mismatch where file template or data has implicit reference and the other one has explicit reference.%% bugfix 12/8/10 JD% No longer aborts blink correction when number of electrode coordinates in blink file and in data match (including implicits).%% modified 1/20/11 JD% Added support for manually specifying EOG channels in the preferences.  Missing EOG channel marked as a -1.%% bugfix 2/3/11 JD% Fixed crash when autoTemplate or bothTemplate selected.%% modified 1/25/12 JD% Eliminated REF channel type and added reference field to keep track of original and current reference scheme.% Stop dropping reference channels from templates (assume ref chans same for both data and template).%% modified 9/22/13 JD% Restricted blink correction to EEG channels.%% bugfix 11/18/13 JD% Fixed crash when there is more than one bad channel.%% modified 12/24/13 JD% Adds blink artifact channel and event marking peak latency of the blink in each epoch.% Checks for semi-singular data matrix and drops dimensions as needed to improve quality of solution.%% bufix 3/11/14 JD% Handles decimal sampling rates gracefully.%% modified 3/18/14 JD% Changed uses of "temp" as a variable name to "tempVar" due to other Matlab programmers often using it as a function% name, resulting in collisions.%% modified 6/2/14 JD% Rereference an epoch after performing blink correction.%% bufix 6/6/14 JD% Fixed blink correction can issue false error that template has wrong number of electrodes.% Fixed crash when correcting blink in continuous file.% Always add blink channel to avoid inter-chunk incompatibility.%% bufix 6/12/14 JD% Fixed blank keys field of events being produced without .key (e.g., .keys.keyCod instead of .keys.key.keyCode)%% modified 7/16/14 JD% Simplified keys code field structure.%% bugfix 8/14/15 JD% Fixed unable to save artifact correction summary figure starting with% Matlab 2014b in stand-alone mode.%% modified 2/16/16 JD% Disabled check to see if subtracting blink factors increased overall variance since semi-singularity correction seems to be controlling the noise problem.% Fixing keeping data points straight when there are saturated data points.% No longer baseline correcting each one-second epoch in continuous data when baseline parameter is specified.  Instead just baseline correcting start of the continuous data.% Improved event marking of blink peaks.% Blink artifact channel now difference between upper and lower EOG channels.%% bugfix 3/8/16 JD% Fix to semi-singularity check, which was dropping too many channels.%% bugfix 4/21/16 JD% Fixed crash when correcting single-trial data.% Fixed crash when no blinks were detected.%% bugfix 5/5/16 JD% Really disabled check to see if subtracting blink factors increased overall variance (oops).%% bugfix 9/4/16 JD% Fixed blink detection algorithm was adding lower VEOG channels rather than subtracting them (making it a little less sensitive than it should have been).%% modified 10/2/16 JD% Added blink_start and blink_end events.% Added blinkPoints and templates output.% Changed runica call so that always initialized with same seed so that ICA results are fully replicable.% Added support for boundary events.% NaN out eye-tracker data during blinks.%% modified 1/3/17 JD% Added eyeTracker option to blink and saccade correction routines.%% modified 2/1/17 JD% Eliminated semi-singularity check.%% modified 2/5/17 JD% Added Subtracted topography to template jpeg output.%% bugfix and modified 4/5/17 JD% Fixed blink detection algorithm was not computing blink direction correctly, making it less sensitive.% Made autotemplate algorithm more robust to vertical saccades, at the cost of needing actual blinks, not just blink recovery artifact, to be present in the data.%% modified 4/24/17 JD% Excludes time points beyond a certain range from global bad channel detection, blink, and saccade routines.% Improved blink autotemplate routine by adding additional criteria for blink candidates including slope and symmetry of UVEOG channels.  Also mean correction of channels.%% bugfix 8/8/17 JD% Fixed crash that could occur when there are bad time points that exceed the saturation threshold and the dataset is segmented.%% bugfix 10/1/17 JD% Median corrects data prior to saturation check to ensure channels with merely high offsets are not treated as bad data.% Fixed autotemplate option missing blinks when sampling rate not 250Hz.  Also loosened blink criteria to handle slow blinks.%% bugfix 10/5/17 JD% Fixed crashes due to Matlab changing their graphics objects AGAIN in 2017b.%% bugfix 11/2/17 JD% Eliminated x tick labels to address problem with subplots in summary% artifact figure getting squeezed by formatting problem on PCs.% Adding rank check prior to ICA.%% bugfix 12/1/17 JD% Fixed crash in blink correction when chunking and there are events.%% bugfix 12/8/17 JD% Fixed crash when preprocessing data containing impedance values.% Fixed crash when preprocessing multi-subject average files.% Fixed crash when 1000 is not evenly divisible by the sampling rate.% Fixed crash when there is an event with an empty .value field.%% bugfix 1/13/18 JD% Fixed crash when sample length did not divide evenly into 100.%% bugfix 1/30/18 JD% Fixed crash when there is an event with an empty .value field.%% modified 2/4/18 JD% Made subplot specification for summary figure output more flexible.%% modified 4/8/18 JD% Consolidated summary figure for average files so no longer one per subject.%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%     Copyright (C) 1999-2018  Joseph Dien%%     This program is free software: you can redistribute it and/or modify%     it under the terms of the GNU General Public License as published by%     the Free Software Foundation, either version 3 of the License, or%     (at your option) any later version.%%     This program is distributed in the hope that it will be useful,%     but WITHOUT ANY WARRANTY; without even the implied warranty of%     MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the%     GNU General Public License for more details.%%     You should have received a copy of the GNU General Public License%     along with this program.  If not, see <http://www.gnu.org/licenses/>.%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%if ~isempty(butterflyFig)    graphCounter=graphCounter+2;end;msg='Starting eyeblinks routine.';disp(msg);outputLog{1}=msg;blinkPoints=cell(endChunk-startChunk+1,1);totblinkTrialNum=[];badChans=badChans(:); %make sure it's a column vectortemplates=[];if ~exist('butterflyFig','var')    butterflyFig=figure('Name','Artifact Correction','NumberTitle','off');    colormap jet;    standAlone=1;else    standAlone=0;end;theEOG(1) = eog.LUVEOG;theEOG(2) = eog.RUVEOG;theEOG(3) = eog.LLVEOG;theEOG(4) = eog.RLVEOG;blinkThreshold=100; %minimum microvolts to count as a blinkblinkwindowMS=300; %minimum separation for blinks in ms.slopeLengthMS=100; %for auto template, number of ms to look for slope on either side of putative blink peak.slopeThresh=2; %criterion for sufficient slope for putative blinkblinkSymm=100; %upper VEOG of blinks need to be within this range of each other to be included in automatic blink templates.noisier=0;VEOG=[];goodVEOG=[];for iChan=1:length(theEOG)    if isempty(intersect(theEOG(iChan),badChans)) && (theEOG(iChan) ~= -1)        VEOG=[VEOG theEOG(iChan)];        goodVEOG(end+1)=iChan;    end;end;blinkManualTemplate=[];blinkAutoTemplate=[];if any(strcmp(templateSource, {'fileTemplate','bothTemplate'}))    [fileDir, name, ext] = fileparts(inFile);    eval(['load ''' blinkFile '''']);        if ~exist('EPblink','var')        msg{1}='Not a blink template.';        [msg]=ep_errorMsg(msg);        return    end;        eval(['load ''' deblank(inFile) '''-' num2str(1) '.mat']);    EEGchans=find(strcmp('EEG',dataChunk.chanTypes));    EEGblinkChans=find(ismember({EPblink.eloc.type},{'EEG','REF'}));        blinkManualTemplate=EPblink.template;    if size(blinkManualTemplate,1) > 1        blinkManualTemplate = blinkManualTemplate';    end;    if size(blinkManualTemplate,1) > 1        msg='Something is wrong with the blink template.  It has the wrong dimensions.';        outputLog{end+1}=msg;        disp(' ');        disp('**************************************************************');        disp(msg);        disp('**************************************************************');        disp(' ');        return;    end;    blinkManualTemplate=blinkManualTemplate(EEGblinkChans);    if length(EPblink.eloc) ~= length(dataChunk.eloc)        numBlinkEEG=length(EEGblinkChans);        numDataEEG=length(EEGchans);        if numBlinkEEG ~= numDataEEG            msg=['Number of blink template EEG electrodes (' num2str(numBlinkEEG) ') different from the data (' num2str(numDataEEG) ').'];            outputLog{end+1}=msg;            disp(' ');            disp('**************************************************************');            disp(msg);            disp('**************************************************************');            disp(' ');            return;        end;    end;        if any([EPblink.eloc(EEGblinkChans).theta]-[dataChunk.eloc(EEGchans).theta])        msg='Blink template electrode locations not consistent with the data.';        outputLog{end+1}=msg;        disp(' ');        disp('**************************************************************');        disp(msg);        disp('**************************************************************');        disp(' ');        return;    end;end;signs = [ 1 1 -1 -1;1 1 -1 -1; -1 -1 1 1; -1 -1 1 1];signs=signs(goodVEOG,:);signs=signs(:,goodVEOG);blinksign = [1 1 -1 -1]';blinksign=blinksign(goodVEOG,1);if ~any(strcmp(templateSource, {'autoTemplate','bothTemplate','fileTemplate','eyeTracker'}))    msg='Template variable must be set to fileTemplate, autoTemplate, bothTemplate, or eyeTracker.';    outputLog{end+1}=msg;    disp(' ');    disp('**************************************************************');    disp(msg);    disp('**************************************************************');    disp(' ');    return;end;facsdone = [];badChans = badChans(find(badChans));	%drop out bad channels set as being zeroif length(refChan) == 2    badChans = unique([badChans;refChan(2)]);     %temporarily take second reference site out of ICAend;outputLog=[];warning off GLREN:doubleBufferSlow; %Turn off warning message about doublebuffer not available.priorPoints=0;for iChunk = startChunk:endChunk    if endChunk > startChunk        msg=[deblank(inFile) '-' num2str(iChunk)];        disp(msg);        outputLog{end+1}=msg;    end;    eval(['load ''' deblank(inFile) '''-' num2str(iChunk) '.mat']);        if strcmp(dataChunk.dataType,'continuous')        theSegment = 'one second epoch';    else        theSegment = 'trial';    end;        numChans=length(dataChunk.chanNames);    numSubs=length(dataChunk.subNames);    EEGchans=find(strcmp('EEG',dataChunk.chanTypes));    if length(dataChunk.facNames) > 1        msg='This function is not intended for application to factor data.';        outputLog{end+1}=msg;        disp(' ');        disp('**************************************************************');        disp(msg);        disp('**************************************************************');        disp(' ');        return;    end;        if iChunk ==startChunk        subtractedBlinksTopo=zeros(length(EEGchans),1);    end;        ETchans=find(ismember(dataChunk.chanTypes,{'PPL';'XEY';'YEY'}));        trialdata=reshape(dataChunk.data(:,:,:,theSubject),numChans,[]);        if strcmp(dataChunk.dataType,'continuous')        displayPeriod=size(dataChunk.data,2);    %Number of timepoints to graph in display.    else        displayPeriod=size(dataChunk.data,2)*size(dataChunk.data,3);    end;    decimateSamples=ceil(max(1,displayPeriod/10000));    totalDisplayPeriod=displayPeriod*size(dataChunk.data,4);        if displayPeriod == 1        msg='There is only one time point and so the data cannot be blink/saccade corrected.';        outputLog{end+1}=msg;        disp(' ');        disp('**************************************************************');        disp(msg);        disp('**************************************************************');        disp(' ');        return;    end;        if strcmp(dataChunk.dataType,'continuous')        numTrials=floor(size(trialdata,2)/ceil(dataChunk.Fs)); %excess time points are tacked onto final epoch        trialSize = min(ceil(dataChunk.Fs),size(trialdata,2)); %one second epochs    else        trialSize = length(dataChunk.timeNames);        numTrials = length(dataChunk.cellNames);    end;        if (length(refChan) == 1) && std(trialdata(refChan(1),:)') == 0        badChans = unique([badChans; refChan(1)]);     %temporarily take first reference site out of ICA    end;        chans = setdiff(EEGchans,badChans);    EEGchansNoHEOG=find(~ismember(chans,[eog.LHEOG eog.RHEOG]));    goodPoints = find((max(trialdata(chans,:)-repmat(median(trialdata(chans,:)')',1,size(trialdata(chans,:),2))) < badDataCriteria.saturation(2)) & (min(trialdata(chans,:)-repmat(median(trialdata(chans,:)')',1,size(trialdata(chans,:),2))) > badDataCriteria.saturation(1)));    slopeLength=round(slopeLengthMS/(1000/dataChunk.Fs));        if ~isempty(baseline)			%subtract out baselines before performing ICA        if strcmp(dataChunk.dataType,'continuous')            baseMeans = mean(trialdata(EEGchans,baseline),2);            trialdata(EEGchans,:)=trialdata(EEGchans,:)-diag(baseMeans)*ones(length(EEGchans),size(trialdata,2));        else            for iTrial = 1:numTrials                epoch=goodPoints(find((goodPoints>((iTrial-1)*trialSize)) & (goodPoints<=(iTrial*trialSize))));                base=(iTrial-1)*trialSize+baseline;                goodBase=goodPoints(find(ismember(base,goodPoints)));                if ~isempty(epoch) && ~isempty(goodBase)                    baseMeans = mean(trialdata(EEGchans,goodBase),2);                    trialdata(EEGchans,epoch)=trialdata(EEGchans,epoch)-diag(baseMeans)*ones(length(EEGchans),length(epoch));                end;            end;        end;    end;        if standAlone        if ~isempty(butterflyFig)            figure(butterflyFig(theSubject,iChunk));            [pathstr, fileName, ext]=fileparts(inFile);            subplot(3,1,1), plot([1:decimateSamples:displayPeriod],trialdata([badChans; chans],1:decimateSamples:displayPeriod));            axis([1 displayPeriod -200 200])            set(gca,'XTickLabel','','XTick',[]);            title([deblank(fileName) '-' num2str(iChunk)],'Interpreter','none');        end;                if ~isempty(baseline)			%subtract out baselines before performing ICA            if ~isempty(butterflyFig)                subplot(3,1,2), plot([1:decimateSamples:displayPeriod],trialdata([badChans; chans],1:decimateSamples:displayPeriod));                axis([1 displayPeriod -200 200])                set(gca,'XTickLabel','','XTick',[]);                title('with baselines subtracted','Interpreter','none');            end;        else            if ~isempty(butterflyFig)                subplot(3,1,3), plot([1:decimateSamples:displayPeriod],trialdata([badChans; chans],1:decimateSamples:displayPeriod));                axis([1 displayPeriod -200 200])                set(gca,'XTickLabel','','XTick',[]);                title('no baseline subtraction specified','Interpreter','none');            end;        end;    end;        NUM_FAC=length(chans);    dataRank=rank(trialdata(chans,[goodPoints]));    if dataRank < NUM_FAC        msg=['Dropping ' num2str(NUM_FAC-dataRank) ' dimensions due to singular data matrix (bridged channels can cause this, or simply very similar channels).'];        disp(msg);        outputLog{end+1}=msg;        NUM_FAC = dataRank;    end;        icadefs;    if exist(ICABINARY) == 2 && ~any(isspace(pwd)) %is there a binary file of runica installed?        try            [weights sphere] = binica(trialdata(chans,goodPoints),'verbose', 'on','filenum',9501,'pca', NUM_FAC);        catch            msg='Binary ICA failed to run.  Suggest disabling it (see tutorial) and try again.';            outputLog{end+1}=msg;            disp(' ');            disp('**************************************************************');            disp(msg);            disp('**************************************************************');            disp(' ');            return        end        delete('binica9501.wts');        delete('binica9501.sph');        delete('bias_after_adjust');        delete('binica9501.sc');    else        try            rng(0,'twister'); %sets random number generator to standardized start to ensure replicability of ICA results.            [weights sphere] = el_runica(trialdata(chans,goodPoints),'pca', NUM_FAC); %modified runica that doesn't reset the random number generator.            %             [winv,activations] = sobi(trialdata(chans,goodPoints),NUM_FAC,100);            %             [winv,activations]=sobi(trialdata(chans,goodPoints),NUM_FAC,100);                    catch            msg=['Error computing ICA.  The error message was:' lasterr];            outputLog{end+1}=msg;            disp(' ');            disp('**************************************************************');            disp(msg);            disp('**************************************************************');            disp(' ');            return        end;    end;        if all(diag(weights) == 1) || ~all(isreal(weights))        msg=['Error: ICA was unable to converge on a solution for chunk ' num2str(iChunk) '.'];        outputLog{end+1}=msg;        disp(' ');        disp('**************************************************************');        disp(msg);        disp('**************************************************************');        disp(' ');        return;    end;        winv = pinv(weights * sphere);    activations = weights * sphere * trialdata(chans,goodPoints);    chanMeans=mean(trialdata')';        %generate automatic blink template    if any(strcmp(templateSource,{'autoTemplate','bothTemplate','eyeTracker'}))        blinkTimes = zeros(numTrials,1);        if strcmp(templateSource,'eyeTracker')            blinkSamps=round([dataChunk.events{1}(find(strcmp('blinkStartET',{dataChunk.events{1}.value}))).sample]);            blinkSamps=blinkSamps-priorPoints;            blinkSamps=blinkSamps((blinkSamps > 0) & (blinkSamps <= size(trialdata,2))); %only saccadeET events in the current data chunk.        end;                for iTrial = 1:numTrials %check each trial for presence of blink            if strcmp(dataChunk.dataType,'continuous') && (iTrial == numTrials)                epoch=goodPoints(find(goodPoints>((iTrial-1)*trialSize))); %excess time points are tacked onto final epoch            else                epoch=goodPoints(find((goodPoints>((iTrial-1)*trialSize)) & (goodPoints<=(iTrial*trialSize))));            end;            if ~isempty(epoch)                blinkFlag=0;                blinkSignal = sum(diag(blinksign)*(trialdata(VEOG,epoch))-repmat(chanMeans(VEOG),1,length(epoch)))';                [maxamp maxpoint] = max(blinkSignal);                if strcmp(templateSource,'eyeTracker')                    if any(ismember(blinkSamps,epoch))                        blinkFlag=1;                    end;                elseif ((epoch(maxpoint)-slopeLength) > 0) && ((epoch(maxpoint)+slopeLength) <= size(trialdata,2))                    badBlink=0;                    if all(ismember([1 2],goodVEOG)) && (abs((trialdata(eog.LUVEOG,epoch(maxpoint))-chanMeans(eog.LUVEOG))-(trialdata(eog.RUVEOG,epoch(maxpoint))-chanMeans(eog.RUVEOG))) > blinkSymm)                        badBlink=1; %upper VEOG not symmetrical enough to be counted for autoblink template                    end;                    if all(ismember([1 3],goodVEOG)) && (abs((trialdata(eog.LUVEOG,epoch(maxpoint))-chanMeans(eog.LUVEOG))-(trialdata(eog.LLVEOG,epoch(maxpoint))-chanMeans(eog.LLVEOG))) < blinkThreshold)                        badBlink=1; %difference between upper and lower EOG too small to count as a blink.                    end;                    if all(ismember([2 4],goodVEOG)) && (abs((trialdata(eog.RUVEOG,epoch(maxpoint))-chanMeans(eog.RUVEOG))-(trialdata(eog.RLVEOG,epoch(maxpoint))-chanMeans(eog.RLVEOG))) < blinkThreshold)                        badBlink=1; %difference between upper and lower EOG too small to count as a blink.                    end;                    if ~badBlink                        blinkSignal = sum(diag(blinksign)*(trialdata(VEOG,epoch(maxpoint)-slopeLength:epoch(maxpoint))-repmat(chanMeans(VEOG),1,slopeLength+1)))';                        b1=[ones(slopeLength+1,1), [1:slopeLength+1]']\blinkSignal;                        blinkSignal = sum(diag(blinksign)*trialdata(VEOG,epoch(maxpoint):epoch(maxpoint)+slopeLength)-repmat(chanMeans(VEOG),1,slopeLength+1))';                        b2=[ones(slopeLength+1,1), [1:slopeLength+1]']\blinkSignal;                        if (b1(2) > slopeThresh) && (b2(2) < -slopeThresh)                            %if this really is a peak point and with reasonable slopes                            blinkFlag=1;                        end;                    end;                end;                if blinkFlag                    if sign(maxamp) ~= 0                        blinkTimes(iTrial)=epoch(maxpoint); %timepoint of blink activity                    end;                end;            end;        end;                blinkTimes=blinkTimes(find(blinkTimes)); %compact array to eliminate trials with no blinks        if ~isempty(blinkTimes)            if length(blinkTimes) == 1                msg=['1 blink ' theSegment ' used for template generation.'];            else                msg=[num2str(length(blinkTimes)) ' blink ' theSegment 's used for template generation.'];            end            disp(msg);            outputLog{end+1}=msg;            if length(blinkTimes) == 1                autoBlinks=trialdata(chans,blinkTimes)';            else                autoBlinks=mean(trialdata(chans,blinkTimes)');            end;            autoBlinks=autoBlinks-chanMeans(chans)';            corrs = corrcoef([autoBlinks(EEGchansNoHEOG)' winv(EEGchansNoHEOG,:)]); %not including HEOG since too variable            blinkfacs = find(abs(corrs(1,2:size(corrs,1))) >= badDataCriteria.blink);            if isempty(blinkfacs)                msg=['No automatic blink facs met criteria.  The highest correlation was: ' num2str(max(abs(corrs(2:end,1))))];                disp(msg);                outputLog{end+1}=msg;            end;        else            msg='No blinks auto-detected.';            disp(msg);            outputLog{end+1}=msg;            autoBlinks=zeros(1,length(chans));            blinkfacs=[];        end;        blinkAutoTemplate{iChunk}(:,1)=autoBlinks;    end;        if strcmp(templateSource,'fileTemplate')        corrs = corrcoef([blinkManualTemplate(chans)' winv]);        blinkfacs = find(abs(corrs(1,2:size(corrs,1))) >= badDataCriteria.blink);        if isempty(blinkfacs)            msg=['No manual blink facs met criteria.  The highest correlation was: ' num2str(max(abs(corrs(2:end,1))))];            disp(msg);            outputLog{end+1}=msg;        end;    end;        if strcmp(templateSource,'bothTemplate')        corrs = corrcoef([blinkManualTemplate(chans)' winv]);        blinkfacs2 = find(abs(corrs(1,2:size(corrs,1))) >= badDataCriteria.blink);        if isempty(blinkfacs2)            msg=['No manual blink facs met criteria.  The highest correlation was: ' num2str(max(abs(corrs(2:end,1))))];            disp(msg);            outputLog{end+1}=msg;        end;        blinkfacs = unique([blinkfacs, blinkfacs2]);    end;        blinkTrialNum{iChunk}=dataChunk.analysis.blinkTrial;    subtractedBlinks=[];    blinkEOG=zeros(1,size(trialdata,2));    if ~isempty(blinkfacs)	%if there are blink factors, subtract them out        winvFull = zeros(numChans,size(winv,2));        for iChan = 1:length(chans)            winvFull(chans(iChan),:)=winv(iChan,:);        end;                tempVar = zeros(size(activations,1),1);        tempVar(blinkfacs) = 1;        blinkdata = (winvFull * diag(tempVar) * (activations-repmat(median(activations')',1,size(activations,2))));                if any(blinksign ==1)            blinkEOG(1,goodPoints) = blinkEOG(1,goodPoints)+mean(blinkdata(VEOG(blinksign ==1),:),1);        end;        if any(blinksign ==-1)            blinkEOG(1,goodPoints) = blinkEOG(1,goodPoints)-mean(blinkdata(VEOG(blinksign ==-1),:),1);        end;        blinkEOG=blinkEOG-mean(blinkEOG);        subtractedBlinks = zeros(size(blinkdata));                count=0;        blinkWindow=blinkwindowMS/round(1000/dataChunk.Fs); %blink peaks within a 100 ms treated as a single blink                dataSize=size(dataChunk.data,2);                boundaryPoints=[];        for iTrial=1:size(dataChunk.data,3)            boundaryPoints=[boundaryPoints; [dataChunk.events{iTrial}(find(strcmp('boundary',{dataChunk.events{iTrial}.type}))).sample]'+(iTrial-1)*dataSize];            if iTrial > 1                boundaryPoints=[boundaryPoints; (iTrial-1)*dataSize+1];            end;        end;                if strcmp(dataChunk.dataType,'continuous')                        %check to see if procedure made data noisier            numTrials=floor(size(dataChunk.data,2)/ceil(dataChunk.Fs)); %excess time points are tacked onto final epoch            trialSize = min(ceil(dataChunk.Fs),size(dataChunk.data,2)); %one second epochs                        for iTrial = 1:numTrials                if iTrial == numTrials                    epochGoodPoints=find(goodPoints>((iTrial-1)*trialSize));                else                    epochGoodPoints=find((goodPoints>((iTrial-1)*trialSize)) & (goodPoints<=(iTrial*trialSize)));                end;                epochPoints=goodPoints(epochGoodPoints);                                if sum(var(trialdata(chans,epochPoints))) < sum(var(trialdata(chans,epochPoints)-blinkdata(chans,epochGoodPoints)))                    noisier=noisier+1;                end;            end;                        %blinkEOG, blinkPeaks, blinkStarts, and blinkEnds in goodPoints space, boundaryPoints are in regular point space            blinkPeaks=min(find(blinkEOG(goodPoints) >= blinkThreshold)); %find first blink point            if ~isempty(blinkPeaks)                blinkStarts=max(find(blinkEOG(goodPoints(1:blinkPeaks(1))) < (blinkThreshold/4))); %the last officially non-blink point prior to the peak                if isempty(blinkStarts) || any(ismember(boundaryPoints,[goodPoints(blinkStarts(1))+1:goodPoints(blinkPeaks(1))]))                    blinkStarts=0;                end;                blinkEnds=min(find(blinkEOG(goodPoints(blinkPeaks(1):end)) < (blinkThreshold/4)))+blinkPeaks(1)-1; %the first officialy non-blink point after the peak                if isempty(blinkEnds) || any(ismember(boundaryPoints,[goodPoints(blinkPeaks(1))+1:goodPoints(blinkEnds)]))                    blinkEnds=0;                end;                if blinkPeaks(1) < length(goodPoints)                    for iPoint=blinkPeaks(1)+1:length(goodPoints)                        theAmp=blinkEOG(goodPoints(iPoint));                        if theAmp >= blinkThreshold                            if ((goodPoints(iPoint)-goodPoints(blinkPeaks(end))) > blinkWindow) || any(ismember(boundaryPoints,[goodPoints(blinkPeaks(end))+1:goodPoints(iPoint)]))                                blinkPeaks=[blinkPeaks;iPoint]; %new blink peak                                if iPoint < blinkEnds(end)                                    blinkEnds(end)=0;                                end;                                theStart=max(find(blinkEOG(goodPoints(1:iPoint)) < (blinkThreshold/4))); %good points space                                if isempty(theStart)                                    blinkStarts(end+1,1)=0;                                    firstBlinkSamp=1;                                elseif theStart < max(blinkEnds)                                    blinkStarts(end+1,1)=0;                                    firstBlinkSamp=max(blinkEnds);                                elseif theStart < max(blinkPeaks(1:end-1))                                    blinkStarts(end+1,1)=0;                                    firstBlinkSamp=max(blinkPeaks(1:end-1))+1;                                elseif any(ismember(boundaryPoints,[goodPoints(theStart)+1:goodPoints(iPoint)]))                                    blinkStarts(end+1,1)=0;                                    firstBlinkSamp=find(goodPoints==max(boundaryPoints(ismember(boundaryPoints,[goodPoints(theStart)+1:goodPoints(iPoint)])))); %good points space                                else                                    blinkStarts(end+1,1)=theStart;                                    firstBlinkSamp=theStart;                                end;                                theEnd=min(find(blinkEOG(goodPoints(iPoint:end)) < (blinkThreshold/4))); %good points space                                if isempty(theEnd)                                    blinkEnds(end+1,1)=0;                                    lastBlinkSamp=length(goodPoints);                                elseif any(ismember(boundaryPoints,[goodPoints(iPoint)+1:goodPoints(theEnd)]))                                    blinkEnds(end+1,1)=0;                                    lastBlinkSamp=find(goodPoints==max(boundaryPoints(ismember(boundaryPoints,[goodPoints(iPoint)+1:goodPoints(theEnd)]))));                                else                                    blinkEnds(end+1,1)=theEnd+iPoint-1;                                    lastBlinkSamp=theEnd;                                end;                                trialdata(ETchans,goodPoints(firstBlinkSamp:lastBlinkSamp))=NaN; %NaN out eye-tracker data during blinks                                theValues={dataChunk.events{1}.value};                                valList=[];                                for iValue=1:length(theValues)                                    if any(strcmp(theValues{iValue},{'saccadeET','fixationET'}))                                        valList(end+1)=iValue;                                    end;                                end;                                ETevents=find(ismember([dataChunk.events{1}(valList').sample],[firstBlinkSamp:lastBlinkSamp]));                                if ~isempty(ETevents)                                    dataChunk.events{1}(ETevents)=[]; %drop ET                                end;                            else                                if theAmp > blinkEOG(1,goodPoints(blinkPeaks(end)))                                    blinkPeaks(end)=iPoint; %update current blink peak                                end;                            end;                        end;                    end;                end;                                for iBlink=1:length(blinkPeaks)                    count=count+1;                                        if blinkStarts(iBlink) > 0                        dataChunk.events{theSubject,1}(end+1).sample=goodPoints(blinkStarts(iBlink));                        dataChunk.events{theSubject,1}(end).type='artifact';                        dataChunk.events{theSubject,1}(end).value='blink_start';                        dataChunk.events{theSubject,1}(end).duration=0;                        dataChunk.events{theSubject,1}(end).keys.code='blnk';                        dataChunk.events{theSubject,1}(end).keys.data=num2str(count);                        dataChunk.events{theSubject,1}(end).keys.datatype='text';                        dataChunk.events{theSubject,1}(end).keys.description='';                    end;                                        dataChunk.events{theSubject,1}(end+1).sample=goodPoints(blinkPeaks(iBlink));                    dataChunk.events{theSubject,1}(end).type='artifact';                    dataChunk.events{theSubject,1}(end).value='blink_peak';                    dataChunk.events{theSubject,1}(end).duration=0;                    dataChunk.events{theSubject,1}(end).keys.code='blnk';                    dataChunk.events{theSubject,1}(end).keys.data=num2str(count);                    dataChunk.events{theSubject,1}(end).keys.datatype='text';                    dataChunk.events{theSubject,1}(end).keys.description='';                                        if blinkEnds(iBlink) > 0                        dataChunk.events{theSubject,1}(end+1).sample=goodPoints(blinkEnds(iBlink));                        dataChunk.events{theSubject,1}(end).type='artifact';                        dataChunk.events{theSubject,1}(end).value='blink_end';                        dataChunk.events{theSubject,1}(end).duration=0;                        dataChunk.events{theSubject,1}(end).keys.code='blnk';                        dataChunk.events{theSubject,1}(end).keys.data=num2str(count);                        dataChunk.events{theSubject,1}(end).keys.datatype='text';                        dataChunk.events{theSubject,1}(end).keys.description='';                    end;                                        theTrial=min(ceil(goodPoints(blinkPeaks(iBlink))/trialSize),size(blinkTrialNum,2));                    blinkTrialNum{iChunk}(theSubject,theTrial)=1; %mark this epoch as having at least one blink                                        startPoint=blinkStarts(iBlink);                    if startPoint==0                        if iBlink==1                            epochStart=goodPoints(1);                        else                            epochStart=goodPoints(blinkPeaks(iBlink-1));                        end;                    else                        epochStart=goodPoints(startPoint);                    end;                    boundPoints=intersect(boundaryPoints,[epochStart+1:goodPoints(blinkPeaks(iBlink))]);                    if ~isempty(boundPoints)                        epochStart=max(boundPoints);                    end;                                        endPoint=blinkEnds(iBlink);                    if endPoint==0                        if iBlink==length(blinkPeaks)                            epochEnd=goodPoints(end);                        else                            epochEnd=goodPoints(blinkPeaks(iBlink+1));                        end;                    else                        epochEnd=goodPoints(endPoint);                    end;                    boundPoints=intersect(boundaryPoints,[goodPoints(blinkPeaks(iBlink))+1:epochEnd]);                    if ~isempty(boundPoints)                        epochEnd=min(boundPoints);                    end;                                        blinkPoints{iChunk-startChunk+1}=[blinkPoints{iChunk-startChunk+1}; [epochStart+1:epochEnd-1]'];                end;                blinkPoints{iChunk-startChunk+1}=unique(blinkPoints{iChunk-startChunk+1});            end;        else            %not continuous data            for iTrial = 1:numTrials                epochGoodPoints=find((goodPoints>((iTrial-1)*trialSize)) & (goodPoints<=(iTrial*trialSize)));                epochPoints=goodPoints(epochGoodPoints);                                %check to see if procedure made data noisier                if sum(var(trialdata(chans,epochPoints))) < sum(var(trialdata(chans,epochPoints)-blinkdata(chans,epochGoodPoints)))                    noisier=noisier+1;                end;                                if ~isempty(epochPoints)                    %blinkEOG, blinkPeaks, blinkStarts, and blinkEnds in epochGoodPoints space                    blinkPeaks=min(find(blinkEOG(1,epochGoodPoints) >= blinkThreshold)); %find first blink point                    if ~isempty(blinkPeaks)                        blinkStarts=max(find(blinkEOG(epochGoodPoints(1:blinkPeaks(1))) < (blinkThreshold/4)));                        if isempty(blinkStarts) || any(ismember(boundaryPoints,[epochGoodPoints(blinkStarts(1))+1:epochGoodPoints(blinkPeaks(1))]))                            blinkStarts=0;                        end;                        blinkEnds=min(find(blinkEOG(epochGoodPoints(blinkPeaks(1):end)) < (blinkThreshold/4)))+blinkPeaks(1)-1;                        if isempty(blinkEnds) || any(ismember(boundaryPoints,[epochGoodPoints(blinkPeaks(1))+1:epochGoodPoints(blinkEnds)]))                            blinkEnds=0;                        end;                        if blinkPeaks(1) < length(epochGoodPoints)                            for iPoint=blinkPeaks(1)+1:length(epochPoints)                                theAmp=blinkEOG(1,epochPoints(iPoint));                                if theAmp >= blinkThreshold                                    if (epochGoodPoints(iPoint)-epochGoodPoints(blinkPeaks(end))) > blinkWindow || any(ismember(boundaryPoints,[epochGoodPoints(blinkPeaks(end))+1:epochGoodPoints(iPoint)]))                                        blinkPeaks=[blinkPeaks;iPoint]; %new blink peak                                        if iPoint < blinkEnds(end)                                            blinkEnds(end)=0;                                        end;                                        theStart=max(find(blinkEOG(epochGoodPoints(1:iPoint)) < (blinkThreshold/4)));                                        if isempty(theStart)                                            blinkStarts(end+1,1)=0;                                            firstBlinkSamp=1;                                        elseif theStart < max(blinkEnds)                                            blinkStarts(end+1,1)=0;                                            firstBlinkSamp=max(blinkEnds);                                        elseif theStart < max(blinkPeaks(1:end-1))                                            blinkStarts(end+1,1)=0;                                            firstBlinkSamp=max(blinkPeaks(1:end-1))+1;                                        elseif any(ismember(boundaryPoints,[epochGoodPoints(theStart)+1:epochGoodPoints(iPoint)]))                                            blinkStarts(end+1,1)=0;                                            firstBlinkSamp=max(boundaryPoints(ismember(boundaryPoints,[epochGoodPoints(theStart)+1:epochGoodPoints(iPoint)])));                                        else                                            blinkStarts(end+1,1)=theStart;                                            firstBlinkSamp=theStart;                                        end;                                        theEnd=min(find(blinkEOG(epochGoodPoints(iPoint:end)) < (blinkThreshold/4)));                                        if isempty(theEnd)                                            blinkEnds(end+1,1)=0;                                            lastBlinkSamp=length(epochGoodPoints);                                        elseif any(ismember(boundaryPoints,[epochGoodPoints(iPoint)+1:epochGoodPoints(theEnd)]))                                            blinkEnds(end+1,1)=0;                                            lastBlinkSamp=max(boundaryPoints(ismember(boundaryPoints,[epochGoodPoints(iPoint)+1:epochGoodPoints(theEnd)])));                                        else                                            blinkEnds(end+1,1)=theEnd;                                            lastBlinkSamp=theEnd;                                        end;                                        trialdata(ETchans,epochGoodPoints(firstBlinkSamp:lastBlinkSamp))=NaN; %NaN out eye-tracker data during blinks                                        theValues={dataChunk.events{theSubject,iTrial}.value};                                        valList=[];                                        for iValue=1:length(theValues)                                            if any(strcmp(theValues{iValue},{'saccadeET','fixationET'}))                                                valList(end+1)=iValue;                                            end;                                        end;                                        ETevents=find(ismember([dataChunk.events{theSubject,iTrial}(valList').sample],[firstBlinkSamp:lastBlinkSamp]));                                        if ~isempty(ETevents)                                            dataChunk.events{1}(ETevents)=[]; %drop ET                                        end;                                    else                                        if theAmp > blinkEOG(1,epochGoodPoints(blinkPeaks(end)))                                            blinkPeaks(end)=iPoint; %update current blink peak                                        end;                                    end;                                end;                            end;                        end;                    end;                    for iBlink=1:length(blinkPeaks)                        count=count+1;                                                if blinkStarts(iBlink) > 0                            dataChunk.events{theSubject,iTrial}(end+1).sample=epochGoodPoints(blinkStarts(iBlink));                            dataChunk.events{theSubject,iTrial}(end).type='artifact';                            dataChunk.events{theSubject,iTrial}(end).value='blink_start';                            dataChunk.events{theSubject,iTrial}(end).duration=0;                            dataChunk.events{theSubject,iTrial}(end).keys.code='blnk';                            dataChunk.events{theSubject,iTrial}(end).keys.data=num2str(count);                            dataChunk.events{theSubject,iTrial}(end).keys.datatype='text';                            dataChunk.events{theSubject,iTrial}(end).keys.description='';                        end;                                                dataChunk.events{theSubject,iTrial}(end+1).sample=epochGoodPoints(blinkPeaks(iBlink))-((iTrial-1)*trialSize);                        dataChunk.events{theSubject,iTrial}(end).type='artifact';                        dataChunk.events{theSubject,iTrial}(end).value='blink';                        dataChunk.events{theSubject,iTrial}(end).duration=0;                        dataChunk.events{theSubject,iTrial}(end).keys.code='blnk';                        dataChunk.events{theSubject,iTrial}(end).keys.data=num2str(count);                        dataChunk.events{theSubject,iTrial}(end).keys.datatype='text';                        dataChunk.events{theSubject,iTrial}(end).keys.description='';                                                if blinkEnds(iBlink) > 0                            dataChunk.events{theSubject,iTrial}(end+1).sample=epochGoodPoints(blinkEnds(iBlink));                            dataChunk.events{theSubject,iTrial}(end).type='artifact';                            dataChunk.events{theSubject,iTrial}(end).value='blink_end';                            dataChunk.events{theSubject,iTrial}(end).duration=0;                            dataChunk.events{theSubject,iTrial}(end).keys.code='blnk';                            dataChunk.events{theSubject,iTrial}(end).keys.data=num2str(count);                            dataChunk.events{theSubject,iTrial}(end).keys.datatype='text';                            dataChunk.events{theSubject,iTrial}(end).keys.description='';                        end;                                                blinkTrialNum{iChunk}(theSubject,iTrial)=1; %mark this epoch as having at least one blink                        startPoint=blinkStarts(iBlink);                        if startPoint==0                            if iBlink==1                                epochStart=epochGoodPoints(1);                            else                                epochStart=epochGoodPoints(blinkPeaks(iBlink-1));                            end;                        else                            epochStart=epochGoodPoints(startPoint);                        end;                        boundPoints=intersect(boundaryPoints,[epochStart+1:epochGoodPoints(blinkPeaks(iBlink))]);                        if ~isempty(boundPoints)                            epochStart=max(boundPoints);                        end;                                                endPoint=blinkEnds(iBlink);                        if endPoint==0                            if iBlink==length(blinkPeaks)                                epochEnd=epochGoodPoints(end);                            else                                epochEnd=epochGoodPoints(blinkPeaks(iBlink+1));                            end;                        else                            epochEnd=epochGoodPoints(endPoint);                        end;                        boundPoints=intersect(boundaryPoints,[epochGoodPoints(blinkPeaks(iBlink))+1:epochEnd]);                        if ~isempty(boundPoints)                            epochEnd=min(boundPoints);                        end;                                                blinkPoints{iChunk-startChunk+1}=[blinkPoints{iChunk-startChunk+1}; [epochStart+1:epochEnd-1]'];                    end;                end;            end;            blinkPoints{iChunk-startChunk+1}=unique(blinkPoints{iChunk-startChunk+1});        end;                %even if no discernible blink peaks, there can still be blink-related activity like blink recovery artifact        data = trialdata(chans,goodPoints);        noblinkdata= data - blinkdata(chans,:);        trialdata(chans,goodPoints) = noblinkdata;        subtractedBlinks=zeros(size(trialdata));        subtractedBlinks(chans,goodPoints) = blinkdata(chans,:);                if count == 0            msg=['No blink peaks detected but blink-related activity corrected.'];        elseif count == 1            msg=['One blink corrected.'];        else            msg=[num2str(count) ' blinks corrected.'];        end        disp(msg);        outputLog{end+1}=msg;                facsdone = [facsdone; winvFull(:,blinkfacs)'];                if ~isempty(butterflyFig)            figure(butterflyFig(iChunk));            theTitle='subtracted blinks';            plotData=ep_makePlotData(butterflyFig(iChunk),displayPeriod,totalDisplayPeriod,decimateSamples,theTitle,subtractedBlinks,EEGchans,theSubject);            subplot(numGraphs,1,graphCounter-2), plot([1:decimateSamples:totalDisplayPeriod],plotData);            title(theTitle,'Interpreter','none');            axis([1 totalDisplayPeriod -200 200])            set(gca,'XTickLabel','','XTick',[]);                        theTitle='with blinks subtracted';            plotData=ep_makePlotData(butterflyFig(iChunk),displayPeriod,totalDisplayPeriod,decimateSamples,theTitle,trialdata,EEGchans,theSubject);            subplot(numGraphs,1,graphCounter-1), plot([1:decimateSamples:totalDisplayPeriod],plotData);            title(theTitle,'Interpreter','none');            axis([1 totalDisplayPeriod -200 200])            set(gca,'XTickLabel','','XTick',[]);        end;    else        msg='No components match blink template so no correction performed.';        disp(msg);        outputLog{end+1}=msg;                subtractedBlinks = zeros(size(dataChunk.data(:,:,:,1)));                if ~isempty(butterflyFig)            figure(butterflyFig(iChunk));            if numSubs > 1                theTitle='subtracted blinks';            else                theTitle='no blinks to subtract that were detected';            end;            plotData=ep_makePlotData(butterflyFig(iChunk),displayPeriod,totalDisplayPeriod,decimateSamples,theTitle,zeros(size(trialdata)),EEGchans,theSubject);            subplot(numGraphs,1,graphCounter-2), plot([1:decimateSamples:totalDisplayPeriod],plotData);            axis([1 totalDisplayPeriod -200 200])            set(gca,'XTickLabel','','XTick',[]);            title(theTitle,'Interpreter','none');                        if numSubs > 1                theTitle='with blinks subtracted';            else                theTitle='no blinks subtracted';            end;            plotData=ep_makePlotData(butterflyFig(iChunk),displayPeriod,totalDisplayPeriod,decimateSamples,theTitle,trialdata,EEGchans,theSubject);            subplot(numGraphs,1,graphCounter-1), plot([1:decimateSamples:totalDisplayPeriod],plotData);            title(theTitle,'Interpreter','none');            axis([1 totalDisplayPeriod -200 200])            set(gca,'XTickLabel','','XTick',[]);        end;    end;        drawnow        if ~isempty(baseline)			%baseline again in case there were blinks in the baseline period.        for iTrial = 1:numTrials            epoch=goodPoints(find((goodPoints>((iTrial-1)*trialSize)) & (goodPoints<=(iTrial*trialSize))));            base=(iTrial-1)*trialSize+baseline;            goodBase=goodPoints(find(ismember(base,goodPoints)));            if ~isempty(epoch) && ~isempty(goodBase)                baseMeans = mean(trialdata(EEGchans,goodBase),2);                trialdata(EEGchans,epoch)=trialdata(EEGchans,epoch)-diag(baseMeans)*ones(length(EEGchans),length(epoch));            end;        end;    end;        if length(refChan) == 2        trialdata(refChan(2),:)=-trialdata(refChan(1),:);     %put second reference channel back in.    end;        %rereference the data.    if ~isempty(refChan)        for iTrial = 1:numTrials            epoch=goodPoints(find((goodPoints>((iTrial-1)*trialSize)) & (goodPoints<=(iTrial*trialSize))));            if ~isempty(epoch)                referenceData=mean(trialdata(refChan,epoch),1);                for iChan=1:length(EEGchans)                    theChan=EEGchans(iChan);                    trialdata(theChan,epoch)=trialdata(theChan,epoch)-referenceData;                end;            end;        end;    end;        dataChunk.data(:,:,:,theSubject)=reshape(trialdata,size(dataChunk.data));    dataChunk.analysis.blinkTrial(theSubject,:)=blinkTrialNum{iChunk};        subtractedEOG=zeros(1,size(trialdata,2));    if any(blinksign ==1)        subtractedEOG(1,goodPoints) = subtractedEOG(1,goodPoints)+mean(subtractedBlinks(VEOG(blinksign ==1),goodPoints),1);    end;    if any(blinksign ==-1)        subtractedEOG(1,goodPoints) = subtractedEOG(1,goodPoints)+mean(subtractedBlinks(VEOG(blinksign ==-1),goodPoints),1);    end;        blinkChan=find(strcmp('blink',dataChunk.chanNames));    if isempty(blinkChan)        EPadd.chanNames{1}='blink';        EPadd.chanTypes{1}='REG';        EPadd.data=zeros(length(EPadd.chanNames),length(dataChunk.timeNames),length(dataChunk.cellNames),length(dataChunk.subNames));        EPadd.data(:,:,:,theSubject)=reshape(subtractedEOG,size(dataChunk.data(1,:,:,1)));        if isfield(dataChunk,'interpChans')            interpChans=dataChunk.interpChans;            dataChunk=rmfield(dataChunk,'interpChans'); %remove interpChans temporarily so it doesn't trigger error by checkEPfile.            [dataChunk]=ep_addData(dataChunk,EPadd,'channels');            dataChunk.interpChans=interpChans;        else            [dataChunk]=ep_addData(dataChunk,EPadd,'channels');        end;    else        dataChunk.data(blinkChan,:,:,theSubject)=reshape(subtractedEOG,size(dataChunk.data(1,:,:,1)));    end;        if isempty(dataChunk)        disp('Warning: No file saved due to program error.');    end;    eval (['save ''' outFile '''-' num2str(iChunk) '.mat dataChunk;']);        if standAlone        try            MATLABver=ver('MATLAB');            [a b]=strtok(MATLABver.Version,'.');            b=b(2:end);            if ~isprop(butterflyFig,'Number')                eval (['print -f' num2str(butterflyFig(iChunk)) ' -djpeg ''' inFile '-' num2str(iChunk) 'EOG.jpg''']);            else                eval (['print -f' num2str(butterflyFig(iChunk).Number) ' -djpeg ''' inFile '-' num2str(iChunk) 'EOG.jpg''']);            end;        catch            disp('Couldn''t save a copy of the artifact correction figure.  Perhaps your version of Matlab is not current.');        end;    end;    priorPoints=priorPoints+size(trialdata,2);    subtractedBlinksTopo=subtractedBlinksTopo+mean(subtractedBlinks(EEGchans,:),2);end;% if noisier == 1%     msg=['1 ' theSegment ' was noisier after correction.'];% else%     msg=[num2str(noisier) ' ' theSegment 's were noisier after correction.'];% end% disp(msg);% outputLog{end+1}=msg;totblinkTrialNum=[];for iChunk = startChunk:endChunk    totblinkTrialNum=[totblinkTrialNum blinkTrialNum{iChunk}];end;templates.blinks.auto=zeros(length(EEGchans),1);if any(strcmp(templateSource,{'autoTemplate','bothTemplate','eyeTracker'}))    totalAutoTemplate=zeros(size(blinkAutoTemplate{1}));    for iChunk = startChunk:endChunk        totalAutoTemplate=totalAutoTemplate+blinkAutoTemplate{iChunk};    end;    totalAutoTemplate=totalAutoTemplate/(endChunk-startChunk+1);    templates.blinks.auto(chans,1)=totalAutoTemplate;else    templates.blinks.auto=[];end;templates.blinks.manual=zeros(length(EEGchans),1);if any(strcmp(templateSource, {'fileTemplate','bothTemplate'}))    templates.blinks.manual=blinkManualTemplate;else    templates.blinks.manual=[];end;templates.blinks.blinkTopo=subtractedBlinksTopo;