function [templates, outputLog, graphCounter] = ep_fixSaccade(inFile, startChunk, endChunk, badChans, eog, templateSource, saccadeFile, badDataCriteria, refChan, excludePoints, butterflyFig, graphCounter, numGraphs, theSubject)%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% [templates, outputLog, graphCounter] = ep_fixSaccade(inFile, startChunk, endChunk, badChans, eog, templateSource, saccadeFile, badDataCriteria, refChan, excludePoints, butterflyFig, graphCounter, numGraphs, theSubject)%%   Corrects eye position artifact based on the EOG channels.%	Reads in file chunks generated by chunkInputFile function.%	Function runs through all the files given and outputs them as fixed chunks.%	chunks will still need to be rejoined.%%Inputs%	inFile:     filename (not including the .mat suffix or chunk number.  e.g., "NT5") and sourcepath.%	startChunk: starting chunk (usually 1)%   endChunk:   ending chunk%   badChans:   list of bad channels to exclude from blink detection process.%   eog:        EOG channels.%   templateSource:   source of saccade templates (fileTemplate: load file.  autoTemplate: automatically generate saccade template.%                  bothTemplate: average together automatic and manual templates).%   saccadeFile:  file with saccade template.  Assumed to be in the same directory as the data file.%   badDataCriteria:  Criteria for detecting bad data.%       .saturation: followed by range of acceptable data values.  Time points with a channel outside this range will be excluded.%   refChan:    Array of current reference channels.%   excludePoints: time points to exclude, numbering end-to-end for single-trial data (cell array of number of chunks)%   butterflyFig:  the handle for the output figure.  Otherwise, will open a new figure.%   graphCounter: the current subplot for the summary figure.%   numGraphs: the total number of subgraphs in the summary figure.%   theSubject: which subject of the file is being processed.%%   The input chunks are EP format data files.%%Outputs%	Saves files with eye position artifact removed, replacing the original chunked files.%   templates: the templates used for the correction, both file and auto if both used.  Returns empty if error occurs.%       .hSaccades%           .manual: manual horizontal saccade template from file (number of EEG channels,1)%           .auto: auto horizontal saccade template (number of EEG channels,1)%       .vSaccades%           .manual: manual horizontal saccade template from file (number of EEG channels,1)%           .auto: auto horizontal saccade template (number of EEG channels,1)%   outputLog: output messages from saccade fixing process%   graphCounter: the current subplot for the summary figure.%% History:%% by Joseph Dien (10/00)% jdien07@mac.com%% modified 6/22/01 JD% added bad channel and threshold parameters.  Also changed chunkNum to startChunk and endChunk.%% modified 5/27/02 JD% added baseline correct feature.  Fix to bad chans so they are zeroed even if no blink factors.%% bugfix 10/11/02 JD% added fix to baseline feature for when a blink occurs during the baseline% period.  Output files will now be baselined.  Also, added check for chans% with zero variability.%% modified 10/20/02 JD% since ICA removal sometimes degrades trials without blinks, will now% remove blink components only for trials where the largest feature has the% topography of a blink (correlates .9 with raw EEG).%% modified 12/06/02 JD% Can automatically generate individualized blink template.  Maxed out VEOG time% points dropped from correction and baseline process and left intact (to trigger% eyeblink rejection in averaging program) since they can't be corrected% properly.  Added output log.%% modified 02/04/03  JD% Can now specify blink template file name.  Saves topoplots of blink facs.%  Added bothTemplate option.%% bugfix 4/1/04 JD% Allow for spaces in file names.%% bugfix 11/15/05 JD% Fixed bug that crashed program when a customized blink template was% specified.%% bugfix 7/24/06 JD% Contents of blink template no longer prints out on screen.  Added some error checking.%% modified 3/22/07 JD% Finished autotemplate feature.  Also now takes into account possibility% of blink recoveries (with an inverse topography).  Also now handles% different montages through EEG_hardware function.%% modified 2/17/08 JD% Checks to see if binary version of runica is installed and uses it if available.%% modified 11/17/08 JD% Eliminated topoplot of blink factors. Made baseline specification more flexible.%% modified 12/13/08 JD% Increased scaling for blink plots to make them more visible.%% modified 2/11/09 JD% Dropped trialsize input field.  No longer zeroes bad channels.  Replaced% threshold field with full badDataCriteria field.%% modified 3/14/09 JD% Changed to use EP format data to provide more flexibility with I/O functions.%% modified 3/17/09 JD% Only subtracted blink activity (that met variance reduced criterion) is shown for blink data figure.%% bugfix 4/16/09 JD% Fixed crash when overall blink direction equaled exactly zero.%% bugfix &  modified 7/14/09 JD% Fixed bothTemplate option, which was functioning the same as autoTemplate, ignoring the file template.% Changed output from list of blink facs to list of blink trials.  No longer zeroes out bad channels.% Includes list of blink trials in the data chunk.  Output figure can now be passed from function call.% blink file assumed to be in the directory of the data file.  Uses updated blink template format.%% modified 8/28/09 JD% Modified to use new option for binary runICA to control the output file names so that they can be cleaned up% and so that unpredictable crash from bug causing strange file names can be circumvented.%% modified 9/4/09 JD% Added refChan input to deal with mean mastoid data where the presence of the two reference channels (correlated -1)% was causing ICA problems.%% bugfix 10/17/09 JD% Crash when only one VEOG channel.%% modified 10/28/09 JD% Added option to disable preprocessing figure for low memory situations.%% bugfix 11/20/09 JD% Replaced "union" commands with "unique" commands because certain situations caused the "union" command to crash in% Matlab 2007.%% bugfix 12/3/09 JD% Additional check for ICA failure (denoted by imaginary numbers for weights).%% modified 2/11/10 JD% Will now work with subject average files with multiple subjects.% BlinkTrial no longer initialized to zero.%% modified & bugfix 5/15/10 JD% Made more memory efficient by reducing resolution of the blink plots to no more than 10000 points regardless of size of data.% Fixed when data is mean mastoid, not setting second reference channel to be inverse of the first reference channel.% Fixed crashes when explicit reference channel is present.%%  modified 10/13/10 JD%  For continuous files, data now divided into one second epochs and can be artifact rejected in an epochwise fashion%  in same fashion as segmented data.%%  modified 10/28/10 JD%  Added support for HEOG saccade correction.%%  bugfix 11/3/10 JD%  Now handles mismatch where file template or data has implicit reference and the other one has explicit reference.%%  modified 1/20/11 JD%  Added support for manually specifying EOG channels in the preferences.  Missing EOG channel marked as a -1.%%  bugfix 6/6/11 JD%  Fixed crash when using saccade correction on file divided into multiple segments.%%  bugfix 6/12/11 JD%  Fixed crash when different numbers of factors correlate with left and right saccade templates.% % modified 1/25/12 JD% Eliminated REF channel type and added reference field to keep track of original and current reference scheme.% % modified 9/22/13 JD% Restricted saccade correction to EEG channels.% % modified 11/19/13 JD% Adds saccade artifact channel and event marking onset latency of the saccade in each epoch.%% bugfix 1/8/14 JD% Fixed crash when there is more than one bad channel.%% bufix 3/11/14 JD% Handles decimal sampling rates gracefully.%% modified 3/18/14 JD% Changed uses of "temp" as a variable name to "tempVar" due to other Matlab programmers often using it as a function% name, resulting in collisions.% % modified 6/2/14 JD% Rereference an epoch after performing saccade correction%% bufix 6/6/14 JD% Fixed saccade correction can issue false error that template has wrong number of electrodes.% Fixed crash when correcting saccade in continuous file.%% bufix 6/12/14 JD% Fixed blank keys field of events being produced without .key (e.g., .keys.keyCod instead of .keys.key.keyCode)%% modified 7/16/14 JD% Simplified keys code field structure.%% modified 11/20/14 JD% Added vertical saccade correction.%% bugfix 8/14/15 JD% Fixed unable to save artifact correction summary figure starting with% Matlab 2014b in stand-alone mode.%% bugfix 8/26/15 JD% Fixed crash when running horizontal saccade correction but not vertical saccade correction.%% modified 9/20/16 JD% Improved saccade correction by treating as an eye position artifact rather than an episodic saccade artifact.% Added auto option for saccades.% Added template to output.% Added exclusion of blink points from eye position artifact estimation, instead interpolating these points by assuming no change in eye position during blinks.% Added support for boundary events.%% modified 1/3/17 JD% Added eyeTracker option to blink and saccade correction routines.%% modified 2/5/17 JD% Added Subtracted topography to template jpeg output.%% modified 4/21/17 JD% Excludes time points beyond a certain range from global bad channel detection, blink, and saccade routines.% Enabled saccade correction even when one or both HEOG channels are bad.% Fixed bug that mucked up correction scaling in the presence of a bad channel.%% bugfix 9/30/17 JD% Median corrects data prior to saturation check to ensure channels with merely high offsets are not treated as bad data.%% bugfix 10/5/17 JD% Fixed crashes due to Matlab changing their graphics objects AGAIN in 2017b.%% bugfix 10/20/17 JD% Eliminated x tick labels to address problem with subplots in summary% artifact figure getting squeezed by formatting problem on PCs.%% bugfix 11/26/17 JD% Fixed miscalculation of saccade correction in single-trial data.%% bugfix 10/5/17 JD% Fixed crash when preprocessing data containing impedance values.% Fixed crash when preprocessing multi-subject average files.%% bugfix 1/14/18 JD% Fixed crash when no good samples in an epoch.%% modified 2/4/18 JD% Made subplot specification for summary figure output more flexible.%% modified 4/8/18 JD% Consolidated summary figure for average files so no longer one per subject.%% bugfix 4/26/18 JD% Fixed crash when there are bad channels.%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%     Copyright (C) 1999-2018  Joseph Dien%%     This program is free software: you can redistribute it and/or modify%     it under the terms of the GNU General Public License as published by%     the Free Software Foundation, either version 3 of the License, or%     (at your option) any later version.%%     This program is distributed in the hope that it will be useful,%     but WITHOUT ANY WARRANTY; without even the implied warranty of%     MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the%     GNU General Public License for more details.%%     You should have received a copy of the GNU General Public License%     along with this program.  If not, see <http://www.gnu.org/licenses/>.%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%templates=[];msg='Fixing saccade artifacts.';disp(msg);outputLog{1}=msg;if ~exist('butterflyFig','var')    butterflyFig=figure('Name','Artifact Correction','NumberTitle','off');    colormap jet;    standAlone=1;else    standAlone=0;end;theEOG(1) = eog.LUVEOG;theEOG(2) = eog.RUVEOG;theEOG(3) = eog.LLVEOG;theEOG(4) = eog.RLVEOG;theEOG(5) = eog.LHEOG;theEOG(6) = eog.RHEOG;VEOG=[];goodVEOG=[];for i=1:4    if isempty(intersect(theEOG(i),badChans)) && (theEOG(i) ~= -1)        VEOG=[VEOG theEOG(i)];        goodVEOG(end+1)=i;    end;end;blinksign = [1 1 -1 -1]';blinksign=blinksign(goodVEOG,1);HEOG=[];for i=5:6    if isempty(intersect(theEOG(i),badChans)) && (theEOG(i) ~= -1)        HEOG=[HEOG theEOG(i)];    end;end;hSaccManualTemplate=[];vSaccManualTemplate=[];hSaccAutoTemplate=[];vSaccAutoTemplate=[];if any(strcmp(templateSource, {'fileTemplate','bothTemplate'}))    [fileDir, name, ext] = fileparts(inFile);    eval(['load ''' saccadeFile '''']);        if ~exist('EPsaccade','var')        msg='Not a saccade template.';        [msg]=ep_errorMsg({msg});        return    end;        if ~exist('EPsaccade','var')        msg='No saccade template so horizontal saccade correction disabled.';        outputLog{end+1}=msg;        disp(' ');        disp('**************************************************************');        disp(msg);        disp('**************************************************************');        disp(' ');        saccadeFileCorrect=0;    else        saccadeFileCorrect=1;        if (~isfield(EPsaccade,'vSaccade')) || ~any(EPsaccade.vSaccade.template)            msg='No vertical saccade template so vertical saccade correction disabled.';            outputLog{end+1}=msg;            disp(' ');            disp('**************************************************************');            disp(msg);            disp('**************************************************************');            disp(' ');            vertSaccadeFileCorrect=0;        else            vertSaccadeFileCorrect=1;        end;    end;        eval(['load ''' deblank(inFile) '''-' num2str(1) '.mat']);    EEGchans=find(strcmp('EEG',dataChunk.chanTypes));    EEGsaccChans=find(ismember({EPsaccade.eloc.type},{'EEG','REF'}));    nonHEOGbadChans=setdiff(badChans,[eog.LHEOG eog.RHEOG]); %HEOG bad chans will be interpolated    saccChans = setdiff(EEGsaccChans,nonHEOGbadChans);        if saccadeFileCorrect        hSaccManualTemplate=EPsaccade.hSaccade.template;        if size(hSaccManualTemplate,1) > 1            hSaccManualTemplate = hSaccManualTemplate';        end;        if size(hSaccManualTemplate,1) > 1            msg='Something is wrong with the saccade template.  It has the wrong dimensions.';            outputLog{end+1}=msg;            disp(' ');            disp('**************************************************************');            disp(msg);            disp('**************************************************************');            disp(' ');            return;        end;        hSaccManualTemplate=hSaccManualTemplate(saccChans);        if length(EPsaccade.eloc) ~= length(dataChunk.eloc)            numSaccEEG=length(EEGsaccChans);            numDataEEG=length(EEGchans);            if numSaccEEG ~= numDataEEG                msg=['Number of saccade template EEG electrodes (' num2str(numSaccEEG) ') different from the data (' num2str(numDataEEG) ').'];                outputLog{end+1}=msg;                disp(' ');                disp('**************************************************************');                disp(msg);                disp('**************************************************************');                disp(' ');                return;            end;        end;                if vertSaccadeFileCorrect            vSaccManualTemplate=EPsaccade.vSaccade.template;            vSaccManualTemplate=vSaccManualTemplate(saccChans);            if size(vSaccManualTemplate,1) > 1                vSaccManualTemplate = vSaccManualTemplate';            end;        end;                if any([EPsaccade.eloc(EEGsaccChans).theta]-[dataChunk.eloc(EEGchans).theta])            msg='Saccade template electrode locations not consistent with the data.';            outputLog{end+1}=msg;            disp(' ');            disp('**************************************************************');            disp(msg);            disp('**************************************************************');            disp(' ');            return;        end;    end;end;if ~any(strcmp(templateSource, {'autoTemplate','bothTemplate','fileTemplate','eyeTracker'}))    msg='Template variable must be set to fileTemplate, autoTemplate, bothTemplate, or eyeTracker.';    outputLog{end+1}=msg;    disp(' ');    disp('**************************************************************');    disp(msg);    disp('**************************************************************');    disp(' ');    return;end;badChans = badChans(find(badChans));	%drop out bad channels set as being zerooutputLog=[];for iChunk = startChunk:endChunk    if endChunk > startChunk        msg=[deblank(inFile) '-' num2str(iChunk)];        disp(msg);        outputLog{end+1}=msg;    end;    eval(['load ''' deblank(inFile) '''-' num2str(iChunk) '.mat']);        if strcmp(dataChunk.dataType,'continuous')        theSegment = 'one second epoch';    else        theSegment = 'trial';    end;        numChans=length(dataChunk.chanNames);    EEGchans=find(strcmp('EEG',dataChunk.chanTypes));    trialdata=reshape(dataChunk.data(:,:,:,theSubject),numChans,[]);    chans = setdiff(EEGchans,badChans);    if length(dataChunk.facNames) > 1        msg='This function is not intended for application to factor data.';        outputLog{end+1}=msg;        disp(' ');        disp('**************************************************************');        disp(msg);        disp('**************************************************************');        disp(' ');        return;    end;        %     if ~ismember(1,blinksign) || ~ismember(-1,blinksign)%         msg='Needs at least one good upper and one good lower VEOG channel to fix saccade artifacts.';%         outputLog{end+1}=msg;%         disp(' ');%         disp('**************************************************************');%         disp(msg);%         disp('**************************************************************');%         disp(' ');%         return%     end;        if iChunk ==startChunk        subtractedHsacTopo=zeros(length(EEGchans),1);        subtractedVsacTopo=zeros(length(EEGchans),1);    end;        if strcmp(dataChunk.dataType,'continuous')        displayPeriod=size(dataChunk.data,2);    %Number of timepoints to graph in display.    else        displayPeriod=size(dataChunk.data,2)*size(dataChunk.data,3);    end;    decimateSamples=ceil(max(1,displayPeriod/10000));    totalDisplayPeriod=displayPeriod*size(dataChunk.data,4);        goodPoints = find((max(trialdata(chans,:)-repmat(median(trialdata(chans,:)')',1,size(trialdata(chans,:),2))) < badDataCriteria.saturation(2)) & (min(trialdata(chans,:)-repmat(median(trialdata(chans,:)')',1,size(trialdata(chans,:),2))) > badDataCriteria.saturation(1)));        goodPoints=setdiff(goodPoints,excludePoints{iChunk});        if displayPeriod == 1        msg='There is only one time point and so the data cannot be blink/saccade corrected.';        outputLog{end+1}=msg;        disp(' ');        disp('**************************************************************');        disp(msg);        disp('**************************************************************');        disp(' ');        return;    end;        trialSize=size(dataChunk.data,2);        boundaryPoints=[];    for iTrial=1:size(dataChunk.data,3)        boundaryPoints=[boundaryPoints; [dataChunk.events{iTrial}(find(strcmp('boundary',{dataChunk.events{iTrial}.type}))).sample]'+(iTrial-1)*trialSize];        if iTrial > 1            boundaryPoints=[boundaryPoints; (iTrial-1)*trialSize+1];        end;    end;        drawnow        hSaccEEG=trialdata(HEOG(1),goodPoints)-trialdata(HEOG(2),goodPoints);    vSaccEEG=mean(trialdata(VEOG(blinksign == -1),goodPoints),1)-mean(trialdata(VEOG(blinksign == 1),goodPoints),1);    if strcmp(templateSource, 'eyeTracker')        hSacc=trialdata(find(strcmp('XEY',dataChunk.chanTypes)),goodPoints);        vSacc=trialdata(find(strcmp('YEY',dataChunk.chanTypes)),goodPoints);        if isempty(hSacc) || isempty(vSacc)            msg='There is no apparent eye-tracker data.';            outputLog{end+1}=msg;            disp(' ');            disp('**************************************************************');            disp(msg);            disp('**************************************************************');            disp(' ');            return;        end;    else        hSacc=hSaccEEG;        vSacc=vSaccEEG;    end;        numPoints=size(trialdata,2);    hSacc1=zeros(1,numPoints);    vSacc1=zeros(1,numPoints);    hSaccEEG1=zeros(1,numPoints);    vSaccEEG1=zeros(1,numPoints);        if isempty(boundaryPoints)        hSacc1=interp1([0 goodPoints size(trialdata,2)+1],[hSacc(1) hSacc hSacc(end)],[1:size(trialdata,2)]); %interpolate bad points        vSacc1=interp1([0 goodPoints size(trialdata,2)+1],[vSacc(1) vSacc vSacc(end)],[1:size(trialdata,2)]); %interpolate bad points        hSaccEEG1=interp1([0 goodPoints size(trialdata,2)+1],[hSaccEEG(1) hSaccEEG hSaccEEG(end)],[1:size(trialdata,2)]); %interpolate bad points        vSaccEEG1=interp1([0 goodPoints size(trialdata,2)+1],[vSaccEEG(1) vSaccEEG vSaccEEG(end)],[1:size(trialdata,2)]); %interpolate bad points    else        for iBreak=0:length(boundaryPoints)            if iBreak ==0                startPoint=1; %full time point space                endPoint=boundaryPoints(1)-1; %full time point space            elseif iBreak == length(boundaryPoints)                startPoint=boundaryPoints(iBreak); %full time point space                endPoint=numPoints; %full time point space            else                startPoint=boundaryPoints(iBreak); %full time point space                endPoint=boundaryPoints(iBreak+1)-1; %full time point space            end;            theGoodPoints=intersect(goodPoints,[startPoint:endPoint]);            if ~isempty(theGoodPoints)                theGoodPointStart=min(find(goodPoints >= startPoint)); %ordinal point in goodPoint space                theGoodPointEnd=max(find(goodPoints <= endPoint)); %ordinal point in goodPoint space                                %interpolate hSacc and vSacc from goodPoint space to full time point space                hSacc1(startPoint:endPoint)=interp1([startPoint-1 theGoodPoints endPoint+1],[hSacc(theGoodPointStart) hSacc(theGoodPointStart:theGoodPointEnd) hSacc(theGoodPointEnd)],[startPoint:endPoint]); %interpolate bad points                vSacc1(startPoint:endPoint)=interp1([startPoint-1 theGoodPoints endPoint+1],[vSacc(theGoodPointStart) vSacc(theGoodPointStart:theGoodPointEnd) vSacc(theGoodPointEnd)],[startPoint:endPoint]); %interpolate bad points                hSaccEEG1(startPoint:endPoint)=interp1([startPoint-1 theGoodPoints endPoint+1],[hSaccEEG(theGoodPointStart) hSaccEEG(theGoodPointStart:theGoodPointEnd) hSaccEEG(theGoodPointEnd)],[startPoint:endPoint]); %interpolate bad points                vSaccEEG1(startPoint:endPoint)=interp1([startPoint-1 theGoodPoints endPoint+1],[vSaccEEG(theGoodPointStart) vSaccEEG(theGoodPointStart:theGoodPointEnd) vSaccEEG(theGoodPointEnd)],[startPoint:endPoint]); %interpolate bad points            end;        end;    end;        hSacc2=hSacc1;    hSaccIsnan=find(isnan(hSacc1));    goodSaccPoints=setdiff(goodPoints,hSaccIsnan);    hSacc2(hSaccIsnan)=0; %hSacc2 is mean-corrected hSacc (based only on good points)    hSacc2(goodSaccPoints)=hSacc2(goodSaccPoints)-mean(hSacc2(goodSaccPoints));    vSacc2=vSacc1;    vSaccIsnan=find(isnan(vSacc1));    vSacc2(vSaccIsnan)=0;    hSaccAutoTemplate=(mean(trialdata(chans,goodSaccPoints).*repmat(hSacc2(goodSaccPoints),length(chans),1),2))'; %weight the time points by the estimated size of the saccade    sortedhSacc=sort(abs(hSacc2(goodSaccPoints)));        fixationGoodPoints=setdiff(find((abs(hSacc2) < sortedhSacc(round(length(sortedhSacc)/8)))),hSaccIsnan); %just the good time points where eyes were near the center line    if ~isempty(fixationGoodPoints)        goodFixSaccPoints=setdiff(fixationGoodPoints,vSaccIsnan);        vSacc2(goodFixSaccPoints)=vSacc2(goodFixSaccPoints)-mean(vSacc2(goodFixSaccPoints));        vSaccAutoTemplate=(mean(trialdata(chans,goodFixSaccPoints).*repmat(vSacc2(goodFixSaccPoints),length(chans),1),2))';    else        vSacc2(goodSaccPoints)=vSacc2(goodSaccPoints)-mean(vSacc2(goodSaccPoints));        vSaccAutoTemplate=(mean(trialdata(chans,setdiff(goodPoints,vSaccIsnan)).*repmat(vSacc2(goodSaccPoints),length(chans),1),2))';    end;        switch templateSource        case 'fileTemplate'            hSaccadeTemplate=hSaccManualTemplate;            vSaccadeTemplate=vSaccManualTemplate;            hSaccAutoTemplate=[];            vSaccAutoTemplate=[];        case {'autoTemplate','eyeTracker'}            hSaccadeTemplate=hSaccAutoTemplate;            vSaccadeTemplate=vSaccAutoTemplate;        case 'bothTemplate'            hSaccadeTemplate=(hSaccManualTemplate+hSaccAutoTemplate)/2;            vSaccadeTemplate=(vSaccManualTemplate+vSaccAutoTemplate)/2;        otherwise            disp('template option not recognized.');            return    end;        subtractedHsac=zeros(size(trialdata));    if ~isempty(hSaccadeTemplate)        hSaccadesScale=abs(hSaccadeTemplate(find(chans==HEOG(2)))-hSaccadeTemplate(find(chans==HEOG(1))));        X=hSacc1(goodSaccPoints)';        Y=((hSaccadeTemplate/hSaccadesScale)*trialdata(chans,goodSaccPoints))';        b=[ones(length(X),1) X]\Y;        subtractedHsac(chans,:)=pinv(hSaccadeTemplate/hSaccadesScale)*(hSacc1*b(2)+b(1));        trialdata=trialdata-subtractedHsac;    end;        subtractedVsac=zeros(size(trialdata));    if ~isempty(vSaccadeTemplate)        vSaccadesScale=abs(mean(vSaccadeTemplate(find(ismember(chans,VEOG(blinksign == 1)))))-mean(vSaccadeTemplate(find(ismember(chans,VEOG(blinksign == -1))))));        if vSaccadesScale~=0            X=vSacc1(goodSaccPoints)';            Y=((vSaccadeTemplate/vSaccadesScale)*trialdata(chans,goodSaccPoints))';            b=[ones(length(X),1) X]\Y;            subtractedVsac(chans,:)=pinv(vSaccadeTemplate/vSaccadesScale)*(vSacc1*b(2)+b(1));            trialdata=trialdata-subtractedVsac;        end;    end;        if ~isempty(butterflyFig)        subtractedSaccades=subtractedHsac+subtractedVsac;        figure(butterflyFig(iChunk));        theTitle='subtracted saccades';        plotData=ep_makePlotData(butterflyFig(iChunk),displayPeriod,totalDisplayPeriod,decimateSamples,theTitle,subtractedSaccades,EEGchans,theSubject);        subplot(numGraphs,1,graphCounter), plot([1:decimateSamples:totalDisplayPeriod],plotData);        title(theTitle,'Interpreter','none');        axis([1 totalDisplayPeriod -200 200])        set(gca,'XTickLabel','','XTick',[]);                theTitle='with saccades subtracted';        plotData=ep_makePlotData(butterflyFig(iChunk),displayPeriod,totalDisplayPeriod,decimateSamples,theTitle,trialdata,EEGchans,theSubject);        subplot(numGraphs,1,graphCounter+1), plot([1:decimateSamples:totalDisplayPeriod],plotData);        title(theTitle,'Interpreter','none');        axis([1 totalDisplayPeriod -200 200])        set(gca,'XTickLabel','','XTick',[]);                drawnow    end;        %rereference the data.    if ~isempty(refChan)        referenceData=mean(trialdata(refChan,:),1);        for iChan=1:length(EEGchans)            theChan=EEGchans(iChan);            trialdata(theChan,:)=trialdata(theChan,:)-referenceData;        end;    end;        dataChunk.data(:,:,:,theSubject)=reshape(trialdata,size(dataChunk.data));        saccChan=find(strcmp('Hsaccade',dataChunk.chanNames));    if isempty(saccChan)        EPadd.chanNames{1}='Hsaccade';        EPadd.chanTypes{1}='REG';        EPadd.data=zeros(length(EPadd.chanNames),length(dataChunk.timeNames),length(dataChunk.cellNames),length(dataChunk.subNames));        EPadd.data(:,:,:,theSubject)=reshape(hSaccEEG1,1,size(dataChunk.data,2),[]);        if isfield(dataChunk,'interpChans')            interpChans=dataChunk.interpChans;            dataChunk=rmfield(dataChunk,'interpChans'); %remove interpChans temporarily so it doesn't trigger error by checkEPfile.            [dataChunk]=ep_addData(dataChunk,EPadd,'channels');            dataChunk.interpChans=interpChans;        else            [dataChunk]=ep_addData(dataChunk,EPadd,'channels');        end;    else        dataChunk.data(saccChan,:,:,theSubject)=reshape(hSaccEEG1,1,size(dataChunk.data,2),[]);    end;        saccChan=find(strcmp('Vsaccade',dataChunk.chanNames));    if isempty(saccChan)        EPadd.chanNames{1}='Vsaccade';        EPadd.chanTypes{1}='REG';        EPadd.data=zeros(length(EPadd.chanNames),length(dataChunk.timeNames),length(dataChunk.cellNames),length(dataChunk.subNames));        EPadd.data(:,:,:,theSubject)=reshape(hSaccEEG1,1,size(dataChunk.data,2),[]);        if isfield(dataChunk,'interpChans')            interpChans=dataChunk.interpChans;            dataChunk=rmfield(dataChunk,'interpChans'); %remove interpChans temporarily so it doesn't trigger error by checkEPfile.            [dataChunk]=ep_addData(dataChunk,EPadd,'channels');            dataChunk.interpChans=interpChans;        else            [dataChunk]=ep_addData(dataChunk,EPadd,'channels');        end;    else        dataChunk.data(saccChan,:,:,theSubject)=reshape(hSaccEEG1,1,size(dataChunk.data,2),[]);    end;        if isempty(dataChunk)        disp('Warning: No file saved due to program error.');    end;    eval (['save ''' inFile '''-' num2str(iChunk) '.mat dataChunk;']);    if standAlone        try            MATLABver=ver('MATLAB');            [a b]=strtok(MATLABver.Version,'.');            b=b(2:end);            if ~isprop(butterflyFig,'Number')                eval (['print -f' num2str(butterflyFig(iChunk)) ' -djpeg ''' inFile '''-' num2str(iChunk) 'EOG.jpg']);            else                eval (['print -f' num2str(butterflyFig(iChunk).Number) ' -djpeg ''' inFile '''-' num2str(iChunk) 'EOG.jpg']);            end;        catch            disp('Couldn''t save a copy of the artifact correction figure.  Perhaps your version of Matlab is not current.');        end;        close(butterflyFig(iChunk));    end;    subtractedHsacTopo=subtractedHsacTopo+mean(subtractedHsac,2);    subtractedVsacTopo=subtractedVsacTopo+mean(subtractedVsac,2);end;templates.hSaccades.manual=zeros(length(EEGchans),1);templates.vSaccades.manual=zeros(length(EEGchans),1);if any(strcmp(templateSource, {'fileTemplate','bothTemplate'}))    if ~isempty(hSaccManualTemplate)        templates.hSaccades.manual(chans,1)=hSaccManualTemplate;    end;    if ~isempty(vSaccManualTemplate)        templates.vSaccades.manual(chans,1)=vSaccManualTemplate;    end;end;templates.hSaccades.auto=zeros(length(EEGchans),1);templates.vSaccades.auto=zeros(length(EEGchans),1);if any(strcmp(templateSource, {'autoTemplate','bothTemplate','eyeTracker'}))    if ~isempty(hSaccAutoTemplate)        templates.hSaccades.auto(chans,1)=hSaccAutoTemplate;    end;    if ~isempty(vSaccAutoTemplate)        templates.vSaccades.auto(chans,1)=vSaccAutoTemplate;    end;end;templates.hSaccades.hSaccadesTopo=subtractedHsacTopo;templates.vSaccades.vSaccadesTopo=subtractedVsacTopo;if ~isempty(butterflyFig)    graphCounter=graphCounter+2;end;