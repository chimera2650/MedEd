function EPdata=ep_averageData(inputFiles,inputFormat,fileType,averagingMethod,trimLevel,methodName,smoothing,latencyName,latencyMin,latencyMax,jitterChan,jitterPolar,multiSessionSubject);%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% EPdata=ep_averageData(inputFiles,inputFormat,fileType,averagingMethod,trimLevel,methodName,smoothing,latencyName,latencyMin,latencyMax,jitterChan,jitterPolar,multiSessionSubject);% Averages single trial data into subject averages or subjects averages into grand averages.% Will refuse to operate on a factor file as it would be meaningless.  The PCA procedure already generates% a grand average and it can also be generated via the Edit Data function.% Can also generate spectral coherence and phase-locked output in the process of forming averages.%%	Reads in specified data files, averages them together using the specified method, dropping bad marked bad trials.%   Returns an EPdata format structured variable.%%Inputs%   inputFiles: cell array of file names to correct.  Assumes active directory if path not specified.  (default: will ask for files)%   inputFormat: input file format.%   fileType: input file type.%   averagingMethod: Type of averaging method   ('Average','Latency-Lock','Jitter-Correct','Frequency-Coherence','Frequency-Phase Lock')%   trimLevel: proportion to drop from each tail of the distribution if using trimmed means averaging.%   methodName: Method used to carry out transformation (for averaging, 'Mean', 'Median', 'Trimmed_Mean').%   smoothing: Frequency smoothing for frequency domain analysis.%   latencyName: For latency locking, name of trial spec with ms timing information.%   latencyMin: For jitter correction and latency locking, minimum allowed latency value to be included in the average in ms.%   latencyMax: For jitter correction and latency locking, maximum allowed latency value to be included in the average in ms.%               Latency range specified as left to right-sided (e.g., 1 second of 250 samples could be -200 to 800ms).%               In order for the full range to be used, there has to be sufficient space before and after the range to%               accommodate latencies that fall at the extremes of the range.  If not, then the range will be narrowed%               accordingly and a note will be displayed.  Simplest if even number of samples.%   jitterChan: Name of the channel with which to adjust for jitter.%   jitterPolar: Whether to check for maximum (1) or minimum (2).%   multiSessionSubject: For when a subject is spread across multiple files and its ID is encoded in the file name, example 4:6 for 4th-6th characters of 'sub001.ept'.%               Needs to be an array of numbers.%%Outputs%	Returns EPdata format structured variable.%   EPdata         : Structured array with the data and accompanying information.  See readData.%%  Leonowicz, Z., Karvanen, J., & Shishkin, S. L. (2005). Trimmed estimators for robust averaging of event-related%  potentials. J Neurosci Methods, 142(1), 17-26.%% History:%% by Joseph Dien (7/20/09)% jdien07@mac.com%% bugfix 9/10/09 JD% Crash when generating grand average from file with analysis fields.%% modified & bugfix 2/14/10 JD% Changed bad channel field to negative numbers for still bad channels.  Modified averaging to deal with the possibility of% these uncorrected bad channels.  Counts of total blink trials and movement trials for averaged waveforms include only% good trials.  Averaging function handles possibility of no good trials for an average.% Moved check for flat epochs to the readData function.  AvgNum and SubNum fields now calculated for grand averages.% analysis fields no longer optional.% Make the assumption that all the files averaged together will use the same ced file.%% bugfix 5/3/10 JD% Fixed crash when generating grand average from files with more than one cell by using either mean or median methods.%% bugfix 5/25/10 JD% Fixed cell names being associated with wrong waveforms when averaging data.%% bugfix 6/12/10 JD% Fixed average files not being generated with .dataName field.%% modified 10/4/10 JD% Now assumes that all the session files going into an average is using the same montage so doesn't keep asking for it.%%  modified 10/17/10 JD%  Added support for saccadeTrials and saccadeOnset fields.%% modified 1/24/12 JD% Eliminated REF channel type and added reference field to keep track of original and current reference scheme.%% modified 4/13/12 JD% Added support for averaging FFT data.%% bugfix 5/17/12 JD% Completed support for bad channels by setting bad channel field to NaN in average files and handling average files% with bad channels when computing grand averages.%% modified 7/15/12 JD% Added ability to merge together session files that have different sets of cells.%% bugfix 8/4/12 JD% Allow continuous files that have been frequency transformed to be averaged.%% bugfix 9/8/12 JD% Fixed crash when combining multiple session files into one average file.%% bugfix 9/15/12 JD% Fixed crash when combining multiple session files into one average file and there are corrected saccades in files after the first.%% bugfix 1/14/13 JD% Fixed subNames and subTypes field not being a column vector when averaging multiple files, resulting in no average% file being saved.%% modified 10/9/13 JD% Added recTime field.%% modified 11/9/13 JD% Default changed to mean.%% modified 11/19/13 JD% Keeps all the events from the averaged data.%% modified 3/6/14 JD% Fields output in standard order and with .pca, .facVar, and facVarQ.%% modified 3/24/14 JD% Added .cov field.%% modified 4/14/14 JD% Added .covNum field.%% modified 4/18/14 JD% Allows choosing either Hanning or multi-taper methods for spectral measures.% Eliminated upper bound to smoothing as no longer seems to apply.%% modified 4/24/14 JD% Added coherence and phase-locking options and allows choosing either hanning or multi-taper methods for spectral measures.%% modified 6/27/14 JD% Added latency-locked and jitter-correction averaging options.%% bugfix 8/4/14 JD% Fixed crash when median averaging frequency-domain data.%% modified 8/31/14 JD% Added support for adding additional keys information to events in continuous data and trial specs in single-trial% data.%% bugfix 9/29/14 JD% Fixed crash when bad channels resulted in not being able to compute% covariance matrix.%% modified 10/16/14 JD% Passes screen size to ep_readData call.%% bugfix 8/30/15 JD% Changed the frequency bins so that the first one starts at the frequency% resolution (e.g., 2hz if the bins are 2Hz wide) rather than always at 1.%% modified 9/4/15 JD% Added trial specs for average files and averages their contents.%% bugfix 10/12/15 JD% Fixed aborting averaging when generating a combined subject average file% wherein one of the files after the first has more trial specs than the% first average file.%% modified 3/8/16 JD% Eliminated support for .power field.%% bugfix 3/15/16 JD% Fixed crash when using jitter-correct option in Average and there are bad channels in the jitter-correct channel.% Fixed replaced bad channels still being treated as bad by jitter-correct option in Average.%% bugfix 3/21/16 JD% Fixed crash when generating a grand average with the Average function.%% bugfix 8/23/16 JD% Fixed error when averaging and a cell has no good trials.%% modified 8/23/16 JD% Reworked the latency-lock and the jitter-correct algorithm to operate in a more straightforward manner.%% bugfix 9/6/16 JD% Fixed error when generating a grand average and there are trial specs.%% modified 10/16/16 JD% Added .stims field.%% modified 11/7/16 JD% Added support for reading and writing subject spec text files.% No longer assumes subject specs are the same for all averaged files. %% modified 11/14/16 JD% Added .calibration field.%% bugfix 3/2/17 JD% Fixed error when generating a grand average.% Fixed error when generating a grand average where there were no good subjects.%% modified 6/18/17 JD% Added support for multi-file subjects.% Added .timeUnits field.% Switch to amplitude scaling when adding freq data together.% Fixed crashes when using median or trimmed means options.%% bugfix 10/15/17 JD% Fixed crash when averaging files that have different trial specs.%% modified 11/22/17 JD% Added support for impedances field.%% bugfix 12/18/17 JD% Fixed odd behavior due to Matlab bug in which str2num executes word strings which are function names.% Fixed crash when generating grand average from average file without .cov% information.%% modified 2/12/18 JD% Added support for stdCM field.%% modified 3/28/18 JD% Added calculation of RT and accuracy summary scores.%% bugfix 6/1/18 JD% Fixed not handling case where some files to be averaged have impedance information and some do not, resulting in later crashes.%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%     Copyright (C) 1999-2018  Joseph Dien%%     This program is free software: you can redistribute it and/or modify%     it under the terms of the GNU General Public License as published by%     the Free Software Foundation, either version 3 of the License, or%     (at your option) any later version.%%     This program is distributed in the hope that it will be useful,%     but WITHOUT ANY WARRANTY; without even the implied warranty of%     MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the%     GNU General Public License for more details.%%     You should have received a copy of the GNU General Public License%     along with this program.  If not, see <http://www.gnu.org/licenses/>.%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%global EPmainEPdata=[];if nargin < 1    [inputFiles, activeDirectory]=ep_getFilesUI(inputFormat);    if inputFiles{1}==0        msg{1}='No filenames selected. You have to click on a name';        [msg]=ep_errorMsg(msg);        return    end    for theFile=1:size(inputFiles,2)        inputFiles{theFile}=[activeDirectory inputFiles{theFile}];    end;else    files=dir;    for theFile=1:size(inputFiles,2)        [activeDirectory, name, ext] = fileparts(inputFiles{theFile});        if isempty(activeDirectory)            activeDirectory=pwd;            inputFiles{theFile}=[activeDirectory filesep inputFiles{theFile}];        end;        if ~exist(inputFiles{theFile},'file')            msg{1}=['Error: The file ' inputFiles{theFile} ' is not in the directory.'];            [msg]=ep_errorMsg(msg);            return        end;    end;end;inputFiles=inputFiles';sessionNum = size(inputFiles,1);readArg{1}='format';readArg{2}=inputFormat;readArg{3}='screenSize';readArg{4}=EPmain.scrsz;readArg{5}='FontSize';readArg{6}=EPmain.fontsize;if ~isempty(fileType)    readArg{7}='type';    readArg{8}=fileType;end;SMIsuffix=EPmain.preferences.general.SMIsuffix;if ~isempty(SMIsuffix)    readArg{end+1}='SMIsuffix';    readArg{end+1}=SMIsuffix;end;specSuffix=EPmain.preferences.general.specSuffix;if ~isempty(specSuffix)    readArg{end+1}='specSuffix';    readArg{end+1}=specSuffix;end;subjectSpecSuffix=EPmain.preferences.general.subjectSpecSuffix;if ~isempty(subjectSpecSuffix)    readArg{end+1}='subjectSpecSuffix';    readArg{end+1}=subjectSpecSuffix;end;BVheader=EPmain.preferences.general.BVheader;if ~isempty(BVheader)    readArg{end+1}='BVheader';    readArg{end+1}=BVheader;end;%assume the first session file is representative of the rest.disp('Reading in the file(s) to determine parameters.');Name=deblank(inputFiles{1});disp(['Now checking file ' Name '.']);thisReadArg=readArg;thisReadArg{end+1}='file';[pathstr, fileName, ext]=fileparts(Name);thisReadArg{end+1}=Name;inputData=ep_readData(thisReadArg);if isempty(inputData)    return;end;[inputData]=ep_stripAdds(inputData);if isempty(inputData.data)    msg{1}=['Error: The file ' fileName ' had no data left to correct after additions were removed.'];    [msg]=ep_errorMsg(msg);    returnend;if length(inputData.facNames) > 1    msg{1}=['Error: The file ' fileName ' is a factor file.'];    [msg]=ep_errorMsg(msg);    returnend;if strcmp(inputData.dataType,'continuous') && isempty(inputData.facNames)    msg{1}=['Error: The file ' fileName ' is a continuous file.'];    [msg]=ep_errorMsg(msg);    returnend;if strcmp(inputData.dataType,'average') && strcmp(averagingMethod,'Frequency-Coherence')    msg{1}=['Error: The file ' fileName ' is an average file, so coherence analysis cannot be performed upon it.'];    [msg]=ep_errorMsg(msg);    returnend;if~isempty(multiSessionSubject) && (length(inputData.subNames)>1)    msg{1}=['Error: The file ' fileName ' has more than one subject, so the multi-file subject option cannot be used.'];    [msg]=ep_errorMsg(msg);    returnend;if ~isempty(latencyName)    if ~strcmp(averagingMethod,'Latency-Lock')        msg{1}=['Error: A trial spec name has been specified but the averaging method is not latency locking.'];        [msg]=ep_errorMsg(msg);        return    end;    theTrialSpec=find(strcmp(latencyName,inputData.trialSpecNames));    if isempty(theTrialSpec)        msg{1}=['Error: The file ' fileName ' does not contain the specified trial spec: ' latencyName '.'];        [msg]=ep_errorMsg(msg);        return    end;    if latencyMin < inputData.timeNames(1)        msg{1}=['Error: The file ' fileName ' begins after the specified minimum latency: ' num2str(latencyMin) '.'];        [msg]=ep_errorMsg(msg);        return    end;    if latencyMax > inputData.timeNames(end)        msg{1}=['Error: The file ' fileName ' ends prior to the specified maximum latency: ' num2str(latencyMax) '.'];        [msg]=ep_errorMsg(msg);        return    end;    if ~strcmp(inputData.dataType,'single_trial')        msg{1}=['Error: Latency-locked averaging can only be performed with single-trial files, which the file ' fileName ' is not.'];        [msg]=ep_errorMsg(msg);        return    end;    if ~isempty(inputData.freqNames)        msg{1}=['Error: Latency-locked averaging can only be performed with non-spectral files, which the file ' fileName ' is not.'];        [msg]=ep_errorMsg(msg);        return    end;        meanLatency(1)=mean(cell2mat(inputData.trialSpecs(find(~inputData.analysis.badTrials(1,:)),theTrialSpec))); %calcualate the average latency including only non-empty values of good trials.end;numChans=length(inputData.chanNames);numPoints=length(inputData.timeNames);[uniqueCells cellIndex ic]=unique(inputData.cellNames);numCells=length(uniqueCells);numWaves=length(inputData.cellNames);numFacs=size(inputData.data,5); %dimensionality of the fifth dimension.  One even if no factors.numFreqs=length(inputData.freqNames);numCMBfacs=size(inputData.facData,5);numRels=length(inputData.relNames);numSpecs=length(inputData.trialSpecNames);dataType=inputData.dataType;sampleSize=1000/inputData.Fs;if strcmp(averagingMethod,'Jitter-Correct')    if isempty(jitterChan)        msg{1}=['Error: Jitter correction has been specified but no channel has been indicated.'];        [msg]=ep_errorMsg(msg);        return    end;    if ~strcmp(jitterChan,inputData.chanNames)        msg{1}=['Error: The indicated channel name(' jitterchan ') is not present in the dataset.'];        [msg]=ep_errorMsg(msg);        return    end;    if ~ismember(jitterPolar,[1 2])        msg{1}=['Error: The jitter polarity setting needs to be either 1 or 2.'];        [msg]=ep_errorMsg(msg);        return    end;end;if any(strcmp(averagingMethod,{'Frequency-Coherence','Frequency-Phase Lock'}))    if strcmp(inputData.dataType,'continuous')        deltaT=min(numPoints/inputData.Fs,1); %time window in seconds    else        deltaT=numPoints/inputData.Fs; %time window in seconds    end;    deltaF=1/deltaT; %frequency resolution    cfg=[];    cfg.foi=[deltaF:deltaF:inputData.Fs/2];    numFreqs=length(cfg.foi);    numRels=numChans;            if ~isempty(inputData.freqNames)        msg{1}=['Error: The file ' fileName ' is already an FFT file.'];        [msg]=ep_errorMsg(msg);        return    end;        switch methodName        case 'Hanning'            cfg.taper='hanning'; %Fieldtrip recommends Hanning for frequencies below 30Hz            cfg.method = 'mtmfft';        case 'multi-taper'            cfg.method='mtmfft';            if ~isempty(which('dpss'))                cfg.taper='dpss';                if smoothing < (inputData.Fs/numPoints)                    disp(['Increasing smoothing to minimum value allowed for dpss taper: ' num2str(inputData.Fs/numPoints)]);                    smoothing=(inputData.Fs/numPoints);                end;                cfg.tapsmofrq=smoothing;            else                cfg.taper='hanning';                disp('Signal Processing Toolkit not installed so taper defaulting to Hanning');            end;        case 'phase-lock wavelet'            cfg.method='wavelet';            deltaT=min(.5,(numPoints/inputData.Fs)); %time window in seconds, no more than 500 ms            resT=50; %50 ms sliding window            deltaF=1/deltaT; %frequency resolution            cfg.foi=[deltaF:deltaF:inputData.Fs/2];            cfg.t_ftimwin    = ones(1,length(cfg.foi)).*deltaT;            cfg.toi          = (inputData.timeNames(ceil(deltaT*inputData.Fs*.5)):resT:inputData.timeNames(numPoints-ceil(deltaT*inputData.Fs*.5)))/1000;    end;        cfg.feedback='none';    cfg.output = 'fourier';    cfg.pad='maxperlen';        cfg2 = [];    cfg2.complex = 'complex';        switch averagingMethod        case 'Frequency-Coherence'            cfg2.method = 'coh';            disp('Using FieldTrip function ft_connectivityanalysis to perform coherence analysis.');        case 'Frequency-Phase Lock'            cfg2.method = 'plv';            cfg2.complex = 'abs';            disp('Using FieldTrip function ft_connectivityanalysis to perform phase locking analysis.');    end;end;EPdata.fileFormat = inputData.fileFormat;EPdata.montage = inputData.montage;EPdata.chanNames = inputData.chanNames;if strcmp(averagingMethod,'Frequency-Coherence')    EPdata.timeNames = [];    EPdata.freqNames=[1:inputData.Fs/2]';    EPdata.Fs = inputData.Fs;elseif strcmp(averagingMethod,'Frequency-Phase Lock')    EPdata.timeNames=cfg.toi'*1000;    EPdata.freqNames=cfg.foi';    EPdata.Fs = 20;else    EPdata.timeNames=inputData.timeNames;    EPdata.freqNames=inputData.freqNames;    EPdata.Fs = inputData.Fs;end;EPdata.cellNames = unique(inputData.cellNames);if any(strcmp(averagingMethod,{'Frequency-Coherence','Frequency-Phase Lock'}))    EPdata.relNames = inputData.chanNames;else    EPdata.relNames = [];end;EPdata.cellTypes = inputData.cellTypes(cellIndex);EPdata.chanTypes= inputData.chanTypes;EPdata.timeUnits= inputData.timeUnits;EPdata.facNames= inputData.facNames;EPdata.facTypes = inputData.facTypes;EPdata.facVecT = inputData.facVecT;EPdata.facVecS = inputData.facVecS;EPdata.facVecF = inputData.facVecF;EPdata.facData = inputData.facData;try    EPver=ver('EP_Toolkit');catch    EPver='unavailable'; %workaround for bug in earlier version of Matlabend;EPdata.EPver = EPver;EPdata.ver = ver;EPdata.date = date;EPdata.reference = inputData.reference;EPdata.baseline = inputData.baseline;if EPdata.baseline==0    disp('Note: the baseline equals zero.  The cov parameter will not be calculated correctly, if later desired for MNE analysis.');end;EPdata.ename = inputData.ename;EPdata.dataName = inputData.dataName;EPdata.trialSpecNames = inputData.trialSpecNames;EPdata.trialNames = [];EPdata.trialSpecs = [];EPdata.ced = inputData.ced;EPdata.eloc = inputData.eloc;EPdata.implicit = inputData.implicit;EPdata.history = inputData.history;EPdata.history{end+1} = {'ep_averageData',inputFiles,inputFormat,fileType,averagingMethod,trimLevel,methodName,smoothing,latencyName,latencyMin,latencyMax,jitterChan,jitterPolar,multiSessionSubject};if length(inputFiles) == 1    EPdata.fileName = inputData.fileName;else    EPdata.fileName = 'average';end;EPdata.dataType=inputData.dataType;EPdata.pca=[];EPdata.facVar=[];EPdata.facVarQ=[];EPdata.stims = inputData.stims;EPdata.calibration=[];EPdata.impedances.channels=[];EPdata.impedances.ground=[];for theFile=2:length(inputFiles)    Name2=deblank(inputFiles{theFile});    disp(['Now checking file ' Name2 '.']);    thisReadArg2=readArg;    thisReadArg2{end+1}='file';    thisReadArg2{end+1}=Name2;    thisReadArg2{end+1}='silent';    thisReadArg2{end+1}='on';    thisReadArg2{end+1}='ced';    thisReadArg2{end+1}=inputData.ced; %assume all the files averaged together will be using the same ced file.    thisReadArg2{end+1}='montage';    thisReadArg2{end+1}=inputData.montage; %assume all the files averaged together will be using the same montage.    data2=ep_readData(thisReadArg2);    if isempty(data2)        return    end;    [data2]=ep_stripAdds(data2);    if (numChans ~= length(data2.chanNames))        msg{1}=['Error: The file ' inputFiles{theFile} ' has a different set of electrodes.'];        [msg]=ep_errorMsg(msg);        return    end;    if (numPoints ~= length(data2.timeNames))        msg{1}=['Error: The file ' inputFiles{theFile} ' has a different length epoch.'];        [msg]=ep_errorMsg(msg);        return    end;    if length(data2.facNames) > 1        msg{1}=['Error: The file ' inputFiles{theFile} ' is a factor file.'];        [msg]=ep_errorMsg(msg);        return    end;    if (length(inputData.facNames) ~= length(data2.facNames))        msg{1}=['Error: The file ' inputFiles{theFile} ' has a different set of factors.'];        [msg]=ep_errorMsg(msg);        return    end;    if ((length(inputData.freqNames) ~= length(data2.freqNames)))        msg{1}=['Error: The file ' inputFiles{theFile} ' has a different number of frequencies.'];        [msg]=ep_errorMsg(msg);        return    end;    if isempty(data2.data)        msg{1}=['Error: The file ' inputFiles{theFile} ' had no data left to correct after additions were removed.'];        [msg]=ep_errorMsg(msg);        return    end;    if ~strcmp(inputData.dataType,data2.dataType)        msg{1}=['Error: The file ' inputFiles{theFile} ' is not the same type of data file as ' inputFiles{1} '.'];        [msg]=ep_errorMsg(msg);        return    end;    if~isempty(multiSessionSubject) && (length(data2.subNames)>1)        msg{1}=['Error: The file ' inputFiles{theFile} ' has more than one subject, so the multi-file subject option cannot be used.'];        [msg]=ep_errorMsg(msg);        return    end;    if ~isempty(latencyName)        if isempty(find(strcmp(latencyName,data2.trialSpecNames)))            msg{1}=['Error: The file ' inputFiles{theFile} ' does not contain the specified trial spec: ' latencyName '.'];            [msg]=ep_errorMsg(msg);            return        end;        if latencyMin < data2.timeNames(1)            msg{1}=['Error: The file ' inputFiles{theFile} ' begins after the specified minimum latency: ' num2str(latencyMin) '.'];            [msg]=ep_errorMsg(msg);            return        end;        if latencyMax > data2.timeNames(end)            msg{1}=['Error: The file ' inputFiles{theFile} ' ends prior to the specified maximum latency: ' num2str(latencyMax) '.'];            [msg]=ep_errorMsg(msg);            return        end;        if ~strcmp(data2.dataType,'single_trial')            msg{1}=['Error: Latency-locked averaging can only be performed with single-trial files, which the file file ' inputFiles{theFile} ' is not.'];            [msg]=ep_errorMsg(msg);            return        end;        if ~isempty(data2.freqNames)            msg{1}=['Error: Latency-locked averaging can only be performed with non-spectral files, which the file ' fileName ' is not.'];            [msg]=ep_errorMsg(msg);            return        end;        theTrialSpec=find(strcmp(latencyName,data2.trialSpecNames));        meanLatency(theFile)=mean(cell2mat(data2.trialSpecs{find(~data2.analysis.badTrials(1,:)),theTrialSpec}));    end;        if ~isempty(setdiff(data2.cellNames,inputData.cellNames))        [newCells,ia]=setdiff(data2.cellNames,EPdata.cellNames);        EPdata.cellNames(end+1:end+length(newCells))=newCells;        EPdata.cellTypes(end+1:end+length(newCells))=data2.cellTypes(ia);        numCells=numCells+length(newCells);    end;end;EPdata.dataType='average';outFileID=cell(sessionNum,1);numOutSubs=sessionNum;if ~isempty(multiSessionSubject)    for iFile=1:length(inputFiles)        [pathstr, name, ext] = fileparts(inputFiles{iFile});        outFileID{iFile}=name(multiSessionSubject);    end;    subList=unique(outFileID,'stable');    numOutSubs=length(subList);end;if any(strcmp(dataType,{'continuous','single_trial'})) %form subject averages    EPdata.events = cell(numOutSubs,numCells);    EPdata.subjectSpecNames = inputData.subjectSpecNames;    if ~any(strcmp('fileName',EPdata.subjectSpecNames))        EPdata.subjectSpecNames{end+1}='fileName';    end;        %if using latency-locked or jitter-correction averaging, width of resulting epoch will be equal to the period before the left side of the range and the period after the right side of the range.    if any(strcmp(averagingMethod,{'Latency-Lock','Jitter-Correct'}))        minPadSamples=round(100/sampleSize); %if range is not specified, default to having 100 ms before and after the new zero point so latency range is 100 ms shy of start and end of epoch        if (isempty(latencyMin) || isempty(latencyMax)) && (numPoints < minPadSamples*2)            msg{1}=['Error: Epoch is too short for default latency range of at least 100 ms before and after the zero point.'];            [msg]=ep_errorMsg(msg);            return        end;        if isempty(latencyMin)            latencyMin=inputData.timeNames(minPadSamples+1);        else            latencyMin=inputData.timeNames(min(find(inputData.timeNames>=latencyMin)));        end;        if isempty(latencyMax)            latencyMax=inputData.timeNames(end-minPadSamples);        else            latencyMax=inputData.timeNames(max(find(inputData.timeNames<=latencyMax-sampleSize))); %convert to left-sided sample times        end;        leftRangeSample=find(inputData.timeNames == latencyMin); %sample of start of latency range (inclusive)        rightRangeSample=find(inputData.timeNames == latencyMax); %sample of end of latency range (inclusive)        leftRange=leftRangeSample-1; %number of samples to left of latency-lock.        rightRange=numPoints-rightRangeSample; %number of samples to right of latency-lock.        epochPoints=leftRange+rightRange;        numPoints=leftRange+rightRange; %update size of range in samples        EPdata.timeNames=[-leftRange:rightRange-1]'*sampleSize;        EPdata.baseline=leftRange;    end;        if strcmp(averagingMethod,'Frequency-Coherence')        EPdata.data=zeros(numChans,1,numCells,numOutSubs,numFacs,max(numFreqs,1),numChans);    elseif strcmp(averagingMethod,'Frequency-Phase Lock')        EPdata.data=zeros(numChans,max(length(EPdata.timeNames),1),numCells,numOutSubs,numFacs,max(length(EPdata.freqNames),1),numChans);    else        EPdata.data=zeros(numChans,max(numPoints,1),numCells,numOutSubs,numFacs,max(numFreqs,1),1);    end;    EPdata.noise=zeros(numChans,max(numPoints,1),numCells,numOutSubs,numFacs);    EPdata.std=zeros(numChans,max(numPoints,1),numCells,numOutSubs,numFacs,max(numFreqs,1));    EPdata.stdCM=zeros(numChans,max(numPoints,1),numCells,numOutSubs,numFacs,max(numFreqs,1));        EPdata.cov.covMatrix=NaN(numOutSubs,numChans,numChans);    EPdata.cov.Nq=NaN;        for iSub = 1:numOutSubs        if ~isempty(multiSessionSubject)            subFilesList=find(strcmp(subList{iSub},outFileID));            numSubFiles=length(subFilesList);        else            subFilesList=iSub;            numSubFiles=1;        end;                for iFile=1:numSubFiles            theFile=subFilesList(iFile);            Name=deblank(inputFiles{theFile});            [pathstr, fileName, ext]=fileparts(Name);                        disp(['Working on #' num2str(iSub) ': ' fileName '.']);                        if (iFile > 1) || (iSub > 1)                thisReadArg=readArg;                thisReadArg{end+1}='file';                thisReadArg{end+1}=Name;                thisReadArg{end+1}='silent';                thisReadArg{end+1}='on';                thisReadArg{end+1}='ced';                thisReadArg{end+1}=EPdata.ced; %assume all the files averaged together will be using the same ced file.                thisReadArg{end+1}='montage';                thisReadArg{end+1}=EPdata.montage; %assume all the files averaged together will be using the same montage.                SMIsuffix=EPmain.preferences.general.SMIsuffix;                if ~isempty(SMIsuffix)                    thisReadArg{end+1}='SMIsuffix';                    thisReadArg{end+1}=SMIsuffix;                end;                specSuffix=EPmain.preferences.general.specSuffix;                if ~isempty(specSuffix)                    thisReadArg{end+1}='specSuffix';                    thisReadArg{end+1}=specSuffix;                end;                subjectSpecSuffix=EPmain.preferences.general.subjectSpecSuffix;                if ~isempty(subjectSpecSuffix)                    thisReadArg{end+1}='subjectSpecSuffix';                    thisReadArg{end+1}=subjectSpecSuffix;                end;                tempData=ep_readData(thisReadArg);            else                tempData=inputData; %since sublist is in 'stable' order the first one will always be the first file, already loaded.            end;            [tempData]=ep_stripAdds(tempData);            if iFile > 1                inputData=ep_addData(inputData,tempData,'cells');                if isempty(inputData)                    msg{1}=['Error: Something went wrong with:' Name];                    [msg]=ep_errorMsg(msg);                    return                end;            else                inputData=tempData;            end;        end;        if ~isempty(multiSessionSubject)            theSubName=['sub' subList{iSub}];        else            theSubName=inputData.subNames{1};        end;        EPdata.subNames{iSub,1}=theSubName;        EPdata.subTypes{iSub,1}='AVG';        [pathstr, name, ext] = fileparts(inputData.fileName);        for iSpec=1:length(inputData.subjectSpecs)            theSpec=find(strcmp(inputData.subjectSpecNames{iSpec},EPdata.subjectSpecNames));            if ~isempty(theSpec)                EPdata.subjectSpecs{iSub,theSpec}=inputData.subjectSpecs{iSpec};            else                EPdata.subjectSpecNames{end+1}=inputData.subjectSpecNames{iSpec};                EPdata.subjectSpecs{iSub,end+1}=inputData.subjectSpecs{iSpec};            end;        end;        theSpec=find(strcmp('fileName',EPdata.subjectSpecNames));        EPdata.subjectSpecs{iSub,theSpec}=[name ext];                newStims=find(~ismember({inputData.stims.name},{EPdata.stims.name}));        if ~isempty(newStims)            EPdata.stims(end+1:end+length(newStims)) = inputData.stims(newStims);        end;                if ~isempty(inputData.impedances.channels)            EPdata.impedances.channels(:,iSub)=inputData.impedances.channels;        elseif ~isempty(EPdata.impedances.channels)            EPdata.impedances.channels(:,iSub)=NaN;        end;        if ~isempty(inputData.impedances.ground)            EPdata.impedances.ground(iSub,1)=inputData.impedances.ground;        elseif ~isempty(EPdata.impedances.ground)            EPdata.impedances.ground(iSub,1)=NaN;        end;        if any(strcmp(averagingMethod,{'Frequency-Coherence','Frequency-Phase Lock'}))            fprintf('%60s\n',' ' );        end;                for theCell=1:numCells            if ~ismember(EPdata.cellNames(theCell),inputData.cellNames)                theGoodTrials=[];            else                theTrials=find(strcmp(EPdata.cellNames(theCell),inputData.cellNames));                badTrials=zeros(1,length(theTrials));                theGoodTrials=theTrials;                theSpecTrials=theGoodTrials; %the trials that will be used to calculate the RT and accuracy scores                                if EPmain.average.dropBad                    badTrials=theTrials(find(inputData.analysis.badTrials(1,theTrials)));                end;                                if any(strcmp(averagingMethod,{'Frequency-Coherence','Frequency-Phase Lock'}))                    %bad channels are very problematic.  To keep the data for each coherence calculation consistent,                    %will need to drop trials with any bad channels at all.                    badTrials=union(badTrials,any(inputData.analysis.badChans(1,theTrials,:)==-1,3));                end;                                EPdata.analysis.badTrials(iSub,theCell)= length(badTrials);                                if strcmp(averagingMethod,'Jitter-Correct')                    %if jitter-correcting, then trials with a bad jitter channel must be counted as bad.                    badTrials=union(badTrials,theTrials(find(squeeze(inputData.analysis.badChans(iSub,theTrials,find(strcmp(jitterChan,inputData.chanNames)))==-1))));                end;                theGoodTrials=setdiff(theGoodTrials,badTrials);                                if ~isempty(latencyName) %if using latency-locking, drop trials where the spec is empty or outside the bounds of the latency range                    theTrialSpec=find(strcmp(latencyName,inputData.trialSpecNames));                    theNonEmptySpecs=find(~cellfun(@isempty,inputData.trialSpecs(theGoodTrials,theTrialSpec)));                    theGoodTrials=intersect(theGoodTrials,theGoodTrials(theNonEmptySpecs)); %drop trials where the spec is empty                    theGoodTrials=theGoodTrials(find([inputData.trialSpecs{theGoodTrials,theTrialSpec}]>=latencyMin));                    theGoodTrials=theGoodTrials(find([inputData.trialSpecs{theGoodTrials,theTrialSpec}]<=latencyMax));                end;                                theACCspec=find(strcmp('ACC',inputData.trialSpecNames));                if length(theACCspec) > 1                    theACCspec=theACCspec(1); %if there are multiple specs with the same name, match to the first one.                end;                theRTspec=find(strcmp('RT',inputData.trialSpecNames));                if length(theRTspec) > 1                    theRTspec=theRTspec(1); %if there are multiple specs with the same name, match to the first one.                end;                                %drop trials based on accuracy scores                if ~isempty(theACCspec) && (EPmain.average.dropError || EPmain.average.dropTimeout)                    theACCSpecs=inputData.trialSpecs(theGoodTrials,theACCspec);                    theStrSpecs=find(cellfun(@ischar,theACCSpecs));                    for iStrSpec=1:length(theStrSpecs)                        theStrSpec=theStrSpecs(iStrSpec);                        theACCSpecs{theStrSpec}=str2double(theACCSpecs{theStrSpec});                    end;                    ACClist=cell2mat(theACCSpecs);                    dropTrials=[];                    if EPmain.average.dropError                        dropTrials=find(theGoodTrials(ACClist==0));                    end;                    if EPmain.average.dropTimeout                        dropTrials=union(dropTrials,find(theGoodTrials(ACClist==2)));                    end;                    theGoodTrials=setdiff(theGoodTrials,dropTrials);                end;                                %drop trials based on RT scores                if ~isempty(theRTspec) && (EPmain.average.minRT || EPmain.average.maxRT)                    theRTSpecs=inputData.trialSpecs(theGoodTrials,theRTspec);                    theStrSpecs=find(cellfun(@ischar,theRTSpecs));                    for iStrSpec=1:length(theStrSpecs)                        theStrSpec=theStrSpecs(iStrSpec);                        theRTSpecs{theStrSpec}=str2double(theRTSpecs{theStrSpec});                    end;                    RTlist=cell2mat(theRTSpecs);                    dropTrials=[];                    if EPmain.average.minRT                        dropTrials=find(theGoodTrials(RTlist<EPmain.average.minRT));                    end;                    if EPmain.average.maxRT                        dropTrials=union(dropTrials,find(theGoodTrials(((RTlist-mean(RTlist))/std(RTlist))>EPmain.average.maxRT)));                    end;                    theGoodTrials=setdiff(theGoodTrials,dropTrials);                end;                                    EPdata.analysis.blinkTrial(iSub,theCell)= sum(inputData.analysis.blinkTrial(1,theGoodTrials));                EPdata.analysis.saccadeTrial(iSub,theCell)= sum(inputData.analysis.saccadeTrial(1,theGoodTrials));                if EPdata.analysis.saccadeTrial(iSub,theCell) == 0                    EPdata.analysis.saccadeOnset(iSub,theCell)=0;                else                    EPdata.analysis.saccadeOnset(iSub,theCell)=sum(inputData.analysis.saccadeOnset(1,theGoodTrials))/inputData.analysis.saccadeTrial(1,theCell); %compute average saccade onset                end;                                EPdata.analysis.saccadeOnset(iSub,theCell)= sum(inputData.analysis.saccadeOnset(1,theGoodTrials));                EPdata.analysis.moveTrial(iSub,theCell)= sum(inputData.analysis.moveTrial(1,theGoodTrials));                for theChan=1:numChans                    if all(inputData.analysis.badChans(1,theGoodTrials,theChan) < 0) %if the channel is bad for all the available good trials                        EPdata.analysis.badChans(iSub,theCell,theChan) = NaN;                    else                        EPdata.analysis.badChans(iSub,theCell,theChan)= sum(inputData.analysis.badChans(1,theGoodTrials,theChan).*(inputData.analysis.badChans(1,theGoodTrials,theChan)>0),2); %only good channels                    end;                end;            end;                        if isempty(theGoodTrials) %if no good trials for this cell, fill out values and move on                EPdata.analysis.blinkTrial(iSub,theCell)=0;                EPdata.analysis.saccadeTrial(iSub,theCell)=0;                EPdata.analysis.saccadeOnset(iSub,theCell)=0;                EPdata.analysis.moveTrial(iSub,theCell)=0;                EPdata.analysis.badTrials(iSub,theCell)=0;                EPdata.analysis.badChans(iSub,theCell,1:numChans)=NaN;                EPdata.avgNum(iSub,theCell)=-1;                EPdata.subNum(iSub,theCell)=-1;                EPdata.covNum(iSub,theCell)=-1;                if strcmp(averagingMethod,'Frequency-Coherence')                    EPdata.data(:,:,theCell,iSub,:,:,:)=zeros(numChans,1,1,1,numFacs,max(numFreqs,1),numChans);                elseif strcmp(averagingMethod,'Frequency-Phase Lock')                    EPdata.data(:,:,theCell,iSub,:,:,:)=zeros(numChans,max(numPoints,1),1,1,numFacs,max(numFreqs,1),numChans);                else                    EPdata.data(:,:,theCell,iSub,:,:,:)=zeros(numChans,max(numPoints,1),1,1,numFacs,max(numFreqs,1));                end;                EPdata.noise(:,:,theCell,iSub,:)=zeros(numChans,max(numPoints,1),1,1,numFacs);                EPdata.std(:,:,theCell,iSub,:,:)=zeros(numChans,max(numPoints,1),1,1,numFacs,max(numFreqs,1));                EPdata.recTime(theCell)=1;                EPdata.trialSpecs{theCell,numSpecs,iSub}=[];                disp(['Warning: The cell ' EPdata.cellNames{theCell} ' for ' fileName ' has zero trials.']);                continue            end;                        EPdata.recTime(theCell)=min(inputData.recTime(theGoodTrials));            numTrials=length(theGoodTrials);            EPdata.avgNum(iSub,theCell)=numTrials;            EPdata.subNum(iSub,theCell)=1;            EPdata.covNum(iSub,theCell)=numTrials;                        switch averagingMethod                case {'Average','Latency-Lock','Jitter-Correct'}                    switch methodName                        case 'Mean'                            for theChan = 1:numChans                                chanGoodTrials=theGoodTrials;                                chanGoodTrials=theGoodTrials(find(inputData.analysis.badChans(1,theGoodTrials,theChan) > -1));                                numChanGoodTrials=length(chanGoodTrials);                                if numChanGoodTrials==0 %if the channel is bad for all the available good trials                                    EPdata.data(theChan,:,theCell,iSub,:,:)=zeros(1,max(numPoints,1),1,1,numFacs,max(numFreqs,1));                                    EPdata.std(theChan,:,theCell,iSub,:,:)=zeros(1,max(numPoints,1),1,1,numFacs,max(numFreqs,1));                                    EPdata.noise(theChan,:,theCell,iSub,:)=zeros(1,max(numPoints,1),1,1,numFacs);                                else                                    theSigns=ones(numChanGoodTrials,1);                                    if numChanGoodTrials > 1                                        theSigns(2:2:end)=-1;                                    end;                                    for theFactor = 1:numFacs                                        for theFreq = 1:max(numFreqs,1)                                            theData=zeros(numChanGoodTrials,max(numPoints,1));                                            noiseData=zeros(numChanGoodTrials,max(numPoints,1));                                            for iTrial=1:numChanGoodTrials                                                theTrial=chanGoodTrials(iTrial);                                                if strcmp(averagingMethod,'Latency-Lock')                                                    theLockSample=floor(inputData.trialSpecs{theTrial,theTrialSpec}/sampleSize)+inputData.baseline+1;                                                    thePoints=[theLockSample-leftRange:theLockSample+rightRange-1];                                                elseif strcmp(averagingMethod,'Jitter-Correct')                                                    thePoints=[leftRangeSample:rightRangeSample];                                                    if jitterPolar==1                                                        [a,theLockSample]=max(inputData.data(strcmp(jitterChan,inputData.chanNames),thePoints,theTrial,:,theFactor,theFreq));                                                    else                                                        [a,theLockSample]=min(inputData.data(strcmp(jitterChan,inputData.chanNames),thePoints,theTrial,:,theFactor,theFreq));                                                    end;                                                    theLockSample=theLockSample+leftRangeSample-1;                                                    thePoints=[theLockSample-leftRange:theLockSample+rightRange-1];                                                else                                                    thePoints=[1:numPoints];                                                    if isempty(thePoints)                                                        thePoints=1;                                                    end;                                                end;                                                theData(iTrial,:)=inputData.data(theChan,thePoints,theTrial,:,theFactor,theFreq);                                                noiseData(iTrial,:)=theSigns(iTrial)*inputData.data(theChan,thePoints,theTrial,:,theFactor,theFreq);                                            end;                                            if isempty(EPdata.freqNames)                                                EPdata.noise(theChan,:,theCell,iSub,theFactor,:)=mean(noiseData);                                            end;                                            if ~isempty(inputData.freqNames) && any(strcmp(inputData.chanTypes{theChan},{'EEG','REG'}))                                                theData=abs(theData); %convert to amplitude scaling when adding freq data together.                                            end;                                            EPdata.data(theChan,:,theCell,iSub,theFactor,theFreq)=mean(theData);                                            EPdata.std(theChan,:,theCell,iSub,theFactor,theFreq)=std(theData);                                        end;                                    end;                                end;                            end;                            for iTrial=1:numChanGoodTrials                                theTrial=theGoodTrials(iTrial);                                for iEvent=1:length(inputData.events{1,theTrial})                                    if ~isempty(latencyName) %if using latency-locking, drop events outside the latency range and adjust the event sample                                        eventSample=inputData.events{1,theTrial}(iEvent).sample;                                        theLockSample=floor(inputData.trialSpecs{theTrial,theTrialSpec}/sampleSize)+inputData.baseline+1;                                        thePoints=[theLockSample-leftRange:theLockSample+rightRange-1];                                        if ismember(eventSample,thePoints)                                            EPdata.events{iSub,theCell}(end+1)=inputData.events{1,theTrial}(iEvent);                                            EPdata.events{iSub,theCell}(end).sample=EPdata.events{iSub,theCell}(end).sample-thePoints(1)+1;                                        end;                                    else                                        EPdata.events{iSub,theCell}(end+1)=inputData.events{1,theTrial}(iEvent);                                    end;                                end;                            end;                                                    case 'Median'                            for theChan = 1:numChans                                chanGoodTrials=theGoodTrials(find(inputData.analysis.badChans(1,theGoodTrials,theChan) > -1));                                numChanGoodTrials=length(chanGoodTrials);                                if numChanGoodTrials==0 %if the channel is bad for all the available good trials                                    EPdata.data(theChan,:,theCell,iSub,:,:)=zeros(1,max(numPoints,1),1,1,numFacs,max(numFreqs,1));                                    EPdata.std(theChan,:,theCell,iSub,:,:)=zeros(1,max(numPoints,1),1,1,numFacs,max(numFreqs,1));                                    EPdata.noise(theChan,:,theCell,iSub,:)=zeros(1,max(numPoints,1),1,1,numFacs);                                else                                    for theFactor = 1:numFacs                                        for theFreq = 1:max(numFreqs,1)                                            for iTrial=1:numChanGoodTrials                                                theTrial=chanGoodTrials(iTrial);                                                if strcmp(averagingMethod,'Latency-Lock')                                                    theLockSample=floor(inputData.trialSpecs{theTrial,theTrialSpec}/sampleSize)+inputData.baseline+1;                                                    thePoints=[theLockSample-leftRange:theLockSample+rightRange-1];                                                elseif strcmp(averagingMethod,'Jitter-Correct')                                                    thePoints=[leftRangeSample:rightRangeSample];                                                    if jitterPolar==1                                                        [a,theLockSample]=max(inputData.data(strcmp(jitterChan,inputData.chanNames),thePoints,theTrial,:,theFactor,theFreq));                                                    else                                                        [a,theLockSample]=min(inputData.data(strcmp(jitterChan,inputData.chanNames),thePoints,theTrial,:,theFactor,theFreq));                                                    end;                                                    theLockSample=theLockSample+leftRangeSample-1;                                                    thePoints=[theLockSample-leftRange:theLockSample+rightRange-1];                                                else                                                    thePoints=[1:numPoints];                                                    if isempty(thePoints)                                                        thePoints=1;                                                    end;                                                end;                                            end;                                            theData=inputData.data(theChan,thePoints,chanGoodTrials,:,theFactor,theFreq);                                            if ~isempty(inputData.freqNames) && any(strcmp(inputData.chanTypes{theChan},{'EEG','REG'}))                                                theData=abs(theData); %convert to amplitude scaling when adding freq data together.                                            end;                                            EPdata.data(theChan,:,theCell,iSub,theFactor)=median(theData,3);                                            for iPoint=1:1:max(numPoints,1)                                                theSample = thePoints(iPoint);                                                EPdata.std(theChan,iPoint,theCell,iSub,theFactor,theFreq)=std(squeeze(theData(:,theSample,:,:,:,theFreq)));                                            end                                            if isempty(EPdata.freqNames)                                                noiseData=zeros(1,max(numPoints,1),1,1,1,max(numFreqs,1));                                                theSigns=ones(numChanGoodTrials,1);                                                if numChanGoodTrials > 1                                                    theSigns(2:2:end)=-1;                                                end;                                                noiseData=noiseData+mean(theSigns(iTrial)*inputData.data(theChan,thePoints,theTrial,:,theFactor,theFreq),3);                                            end;                                        end;                                    end;                                    for iEvent=1:length(inputData.events{1,theTrial})                                        if ~isempty(latencyName) %if using latency-locking, drop events outside the latency range and adjust the event sample                                            eventSample=inputData.events{1,theTrial}(iEvent).sample;                                            if ismember(eventSample,thePoints)                                                EPdata.events{iSub,theCell}(end+1)=inputData.events{1,theTrial}(iEvent);                                                EPdata.events{iSub,theCell}(end).sample=EPdata.events{iSub,theCell}(end).sample-thePoints(1)+1;                                            end;                                        else                                            EPdata.events{iSub,theCell}(end+1)=inputData.events{1,theTrial}(iEvent);                                        end;                                    end;                                    if isempty(EPdata.freqNames)                                        EPdata.noise(theChan,:,theCell,iSub,theFactor,:)=noiseData/numChanGoodTrials;                                    end;                                end;                            end;                        case 'Trimmed_Mean'                            for theChan = 1:numChans                                chanGoodTrials=theGoodTrials(find(inputData.analysis.badChans(1,theGoodTrials,theChan) > -1));                                numChanGoodTrials=length(chanGoodTrials);                                if numChanGoodTrials==0 %if the channel is bad for all the available good trials                                    EPdata.data(theChan,:,theCell,iSub,:,:)=zeros(1,max(numPoints,1),1,1,numFacs,max(numFreqs,1));                                    EPdata.std(theChan,:,theCell,iSub,:,:)=zeros(1,max(numPoints,1),1,1,numFacs,max(numFreqs,1));                                    EPdata.noise(theChan,:,theCell,iSub,:)=zeros(1,max(numPoints,1),1,1,numFacs);                                else                                    trimTrials=floor(numChanGoodTrials*trimLevel);                                    numTrimmedTrials=length(trimTrials+1:numChanGoodTrials-trimTrials);                                    theSigns=ones(numTrimmedTrials,1);                                                                        if numTrimmedTrials > 1                                        if rand() > .5                                            theSigns(2:2:end)=-1;                                        else                                            theSigns(1:2:end)=-1;                                        end;                                    end;                                    noiseData=zeros(1,max(numPoints,1),1,1,numFacs,max(numFreqs,1));                                    if any(strcmp(averagingMethod,{'Latency-Lock','Jitter-Correct'}))                                        theData=zeros(numChans,max(numPoints,1),numChanGoodTrials,1,numFacs,max(numFreqs,1),1);                                        for iTrial=1:numChanGoodTrials                                            theTrial=chanGoodTrials(iTrial);                                            for theFactor = 1:numFacs                                                for theFreq = 1:max(numFreqs,1)                                                    if strcmp(averagingMethod,'Latency-Lock')                                                        theLockSample=floor(inputData.trialSpecs{theTrial,theTrialSpec}/sampleSize)+inputData.baseline+1;                                                        thePoints=[theLockSample-leftRange:theLockSample+rightRange-1];                                                    elseif strcmp(averagingMethod,'Jitter-Correct')                                                        thePoints=[leftRangeSample:rightRangeSample];                                                        if jitterPolar==1                                                            [a,theLockSample]=max(inputData.data(strcmp(jitterChan,inputData.chanNames),thePoints,theTrial,:,theFactor,theFreq));                                                        else                                                            [a,theLockSample]=min(inputData.data(strcmp(jitterChan,inputData.chanNames),thePoints,theTrial,:,theFactor,theFreq));                                                        end;                                                        theLockSample=theLockSample+leftRangeSample-1;                                                        thePoints=[theLockSample-leftRange:theLockSample+rightRange-1];                                                    end;                                                    theData(:,:,iTrial,:,theFactor,theFreq)=inputData.data(:,thePoints,theTrial,:,theFactor,theFreq);                                                    for iEvent=1:length(inputData.events{1,theTrial})                                                        eventSample=inputData.events{1,theTrial}(iEvent).sample;                                                        if ismember(eventSample,thePoints)                                                            EPdata.events{iSub,theCell}(end+1)=inputData.events{1,theTrial}(iEvent);                                                            EPdata.events{iSub,theCell}(end).sample=EPdata.events{iSub,theCell}(end).sample-thePoints(1)+1;                                                        end;                                                    end;                                                end;                                            end;                                        end;                                    else                                        theData=inputData.data(:,:,chanGoodTrials,:,:,:);                                        for iTrial=1:numChanGoodTrials                                            theTrial=chanGoodTrials(iTrial);                                            EPdata.events{iSub,theCell}(end+1:end+length(inputData.events{1,theTrial}))=inputData.events{1,theTrial};                                        end;                                    end;                                    if ~isempty(inputData.freqNames) && any(strcmp(inputData.chanTypes{theChan},{'EEG','REG'}))                                        theData=abs(theData); %convert to amplitude scaling when adding freq data together.                                    end;                                    for theSample = 1:max(numPoints,1)                                        for theFactor = 1:numFacs                                            for theFreq = 1:max(numFreqs,1)                                                sortedValues=sort(squeeze(theData(theChan,theSample,:,:,theFactor,theFreq)));                                                EPdata.data(theChan,theSample,theCell,iSub,theFactor,theFreq)=mean(sortedValues(trimTrials+1:numChanGoodTrials-trimTrials));                                                if isempty(EPdata.freqNames)                                                    EPdata.noise(theChan,theSample,theCell,iSub,theFactor)=mean(theSigns.*sortedValues(trimTrials+1:numChanGoodTrials-trimTrials));                                                end;                                                EPdata.std(theChan,theSample,theCell,iSub,theFactor,theFreq)=std(squeeze(inputData.data(theChan,theSample,chanGoodTrials,:,theFactor,theFreq)));                                            end;                                        end;                                    end                                end;                            end;                    end;                                    case 'Frequency-Coherence'                    %bad channels are very problematic.  To keep the data for each coherence calculation consistent,                    %will need to drop trials with any bad channels at all.                                        fprintf('%s%-60s',repmat(sprintf('\b'),1,60),sprintf('Applying coherence transform to cell #%4d of %4d', theCell, numCells))                    for theFactor = 1:numFacs                        ftData=ep_ep2ft(ep_selectData(inputData,{[],[],theGoodTrials,[],theFactor,[]}));                        if ~isempty(ftData)                            evalc('[freq] = ft_freqanalysis(cfg,ftData);'); %amplitude spectrum                            evalc('coh = ft_connectivityanalysis(cfg2, freq);');                                                        for iFreq=1:length(coh.freq)                                EPdata.data(:,1,theCell,iSub,theFactor,iFreq,:) = squeeze(coh.cohspctrm(:,:,iFreq));                            end;                        end;                    end;                case 'Frequency-Phase Lock'                    %bad channels are very problematic.  To keep the data for each coherence calculation consistent,                    %will need to drop trials with any bad channels at all.                                        fprintf('%s%-60s',repmat(sprintf('\b'),1,60),sprintf('Applying phase locking transform to cell #%4d of %4d', theCell, numCells))                    for theFactor = 1:numFacs                        ftData=ep_ep2ft(ep_selectData(inputData,{[],[],theGoodTrials,[],theFactor,[]}));                        if ~isempty(ftData)                            evalc('[freq] = ft_freqanalysis(cfg,ftData);'); %amplitude spectrum                            evalc('plv = ft_connectivityanalysis(cfg2, freq);');                                                        for iPoint=1:length(plv.time)                                for iFreq=1:length(plv.freq)                                    EPdata.data(:,iPoint,theCell,iSub,theFactor,iFreq,:) = squeeze(plv.plvspctrm(:,:,iFreq,iPoint));                                end;                            end;                        end;                    end;                    if isempty(EPdata.freqNames)                        EPdata.freqNames=freq.freq; %assuming they are the same for all the data                    end;                otherwise                    msg{1}=['Error: The averaging method ' averagingMethod ' is not recognized.'];                    [msg]=ep_errorMsg(msg);                    return            end;                        %generate the accuracy and RT summary scores based on all trials not just the good ones            goodRTs=theSpecTrials;            if ~isempty(theACCspec) && ~isempty(theSpecTrials)                EPdata.trialSpecs{theCell,theACCspec,iSub}=nan;                theACCSpecs=inputData.trialSpecs(theSpecTrials,theACCspec);                theStrSpecs=find(cellfun(@ischar,theACCSpecs));                for iStrSpec=1:length(theStrSpecs)                    theStrSpec=theStrSpecs(iStrSpec);                    theACCSpecs{theStrSpec}=str2double(theACCSpecs{theStrSpec});                end;                ACClist=cell2mat(theACCSpecs);                if ~isempty(ACClist)                    keepACC=find((ACClist==1)|(ACClist==0));                    ACClist=ACClist(keepACC);                    theSpecTrials=theSpecTrials(keepACC);                    goodRTs=goodRTs(ACClist==1); %compute summary RT number based only on correct trials.                else                    theSpecTrials=[];                    goodRTs=[];                end;            end;            goodACCs=theSpecTrials;            if ~isempty(theRTspec) && ~isempty(theSpecTrials)                theSpecs=inputData.trialSpecs(goodRTs,theRTspec);                theStrSpecs=find(cellfun(@ischar,theSpecs));                for iStrSpec=1:length(theStrSpecs)                    theStrSpec=theStrSpecs(iStrSpec);                    theSpecs{theStrSpec}=str2double(theSpecs{theStrSpec});                end;                RTlist=cell2mat(theSpecs); %RT numbers based only on correct trials.                if ~isempty(RTlist)                    %drop premature responses                    if EPmain.average.minRT ~=0                        badRTs=goodRTs(RTlist<EPmain.average.minRT);                        goodRTs(RTlist<EPmain.average.minRT)=[];                        RTlist(RTlist<EPmain.average.minRT)=[];                        ACClist=ACClist(~ismember(goodACCs,badRTs));                        goodACCs=setdiff(goodACCs,badRTs);                    end;                    if ~isempty(RTlist)                        %drop outlier slow responses not including premature responses                        if EPmain.average.maxRT ~=0                            badRTs=goodRTs(((RTlist-mean(RTlist))/std(RTlist))>EPmain.average.maxRT);                            goodRTs(((RTlist-mean(RTlist))/std(RTlist))>EPmain.average.maxRT)=[];                            RTlist(((RTlist-mean(RTlist))/std(RTlist))>EPmain.average.maxRT)=[];                            ACClist=ACClist(~ismember(goodACCs,badRTs));                            goodACCs=setdiff(goodACCs,badRTs);                        end;                    end;                end;            end;            summaryRT=nan;            summaryACC=nan;            if ~isempty(goodRTs) && ~isempty(theRTspec)                switch EPmain.average.RTmethod                    case 1                        summaryRT=median(RTlist);                    case 2                        summaryRT=mean(RTlist);                    case 3                        trimTrials=floor(length(RTlist)*trimLevel);                        summaryRT=mean(trimTrials+1:length(RTlist)-trimTrials);                    otherwise                        %oops, not a valid option.                end;            end;            if ~isempty(goodACCs) && ~isempty(theACCspec)                summaryACC=mean(ACClist);            end;            %generate the averaged trial specs            for iSpec=1:length(inputData.trialSpecNames)                theSpec=find(strcmp(inputData.trialSpecNames{iSpec},EPdata.trialSpecNames));                if length(theSpec) > 1                    theSpec=theSpec(1); %if there are multiple specs with the same name, match to the first one.                end;                if isempty(theSpec)                    EPdata.trialSpecNames{end+1}=inputData.trialSpecNames{iSpec};                    theSpec=length(EPdata.trialSpecNames);                end;                if strcmp(inputData.trialSpecNames{theSpec},'RT')                    EPdata.trialSpecs{theCell,theSpec,iSub}=summaryRT;                elseif strcmp(inputData.trialSpecNames{theSpec},'ACC')                    EPdata.trialSpecs{theCell,theSpec,iSub}=summaryACC;                elseif ischar(inputData.trialSpecs{theGoodTrials(1),iSpec}) && all(strcmp(inputData.trialSpecs{theGoodTrials(1),iSpec},inputData.trialSpecs(theGoodTrials,iSpec)))                    EPdata.trialSpecs{theCell,theSpec,iSub}=inputData.trialSpecs{1,iSpec};                else                    theSpecs=inputData.trialSpecs(theGoodTrials,iSpec);                    theStrSpecs=find(cellfun(@ischar,theSpecs));                    for iStrSpec=1:length(theStrSpecs)                        theStrSpec=theStrSpecs(iStrSpec);                        theSpecs{theStrSpec}=str2double(theSpecs{theStrSpec});                    end;                    EPdata.trialSpecs{theCell,theSpec,iSub}=mean(cell2mat(theSpecs));                end;            end;                    end;                %apply .calibration to eye location channels        if isfield(EPdata.calibration,'ET') && isfield(EPdata.calibration.ET,'Xzero') && isfield(EPdata.calibration.ET,'Yzero') && isfield(EPdata.calibration.ET,'Xscale') && isfield(EPdata.calibration.ET,'Yscale')            XEYchan=find(strcmp('XEY',EPdata.chanTypes));            if length(XEYchan) > 1                XEYchan=XEYchan(1);            end;            YEYchan=find(strcmp('YEY',EPdata.chanTypes));            if length(YEYchan) > 1                YEYchan=YEYchan(1);            end;            EPdata.data(XEYchan,:,:,iSub,:,:,:)=(EPdata.data(XEYchan,:,:,iSub,:,:,:)-EPdata.calibration.ET.Xzero)/EPdata.calibration.ET.Xscale;            EPdata.data(YEYchan,:,:,iSub,:,:,:)=(EPdata.data(YEYchan,:,:,iSub,:,:,:)-EPdata.calibration.ET.Yzero)/EPdata.calibration.ET.Yscale;        end;        if isfield(EPdata.calibration,'SAC') && isfield(EPdata.calibration.SAC,'Xzero') && isfield(EPdata.calibration.SAC,'Yzero') && isfield(EPdata.calibration.SAC,'Xscale') && isfield(EPdata.calibration.SAC,'Yscale')            XEYchan=find(strcmp('Hsaccade',EPdata.chanNames));            if length(XEYchan) > 1                XEYchan=XEYchan(1);            end;            YEYchan=find(strcmp('Vsaccade',EPdata.chanNames));            if length(YEYchan) > 1                YEYchan=YEYchan(1);            end;            EPdata.data(XEYchan,:,:,iSub,:,:,:)=(EPdata.data(XEYchan,:,:,iSub,:,:,:)-EPdata.calibration.SAC.Xzero)/EPdata.calibration.SAC.Xscale;            EPdata.data(YEYchan,:,:,iSub,:,:,:)=(EPdata.data(YEYchan,:,:,iSub,:,:,:)-EPdata.calibration.SAC.Yzero)/EPdata.calibration.SAC.Yscale;        end;                %calculate the .cov field        if isempty(inputData.cov)            EPdata.cov.covMatrix(iSub,:,:)=NaN(numChans,numChans);            EPdata.cov.Nq(iSub)=NaN;            if isempty(inputData.freqNames)                goodChans=setdiff([1:numChans],any(isnan(squeeze(inputData.analysis.badChans(1,:,:))))); %if channel entirely bad in any of the cells, then leave out of cov calculation                covData=[];                EEGchans=find(strcmp('EEG',inputData.chanTypes));                for iCell=1:length(inputData.cellNames)                    if ~any(inputData.analysis.badChans(1,iCell,goodChans) < 0) && ~inputData.analysis.badTrials(1,iCell)                        theData=squeeze(inputData.data(goodChans,:,iCell,1,:,:));                        if inputData.baseline                            theData=theData-diag(squeeze(mean(theData(:,1:inputData.baseline),2)))*ones(length(goodChans),size(theData,2)); %baseline the data prior to calculating the cov matrix                        end;                        theData=theData-ones(length(goodChans),size(theData,2))*diag(squeeze(mean(theData,1))); %average reference prior to cov calculation                        covData=[covData, theData];                    end;                end;                if ~isempty(covData)                    Nq=size(covData,2);                    EPdata.cov.covMatrix(iSub,goodChans,goodChans)=(covData*covData')./Nq; %per MNE recommended procedure, the cov is calculated as an SSCP matrix where the variables have been baseline corrected for each epoch.                    EPdata.cov.Nq(iSub)=Nq; %degrees of freedom, for weighting cov matrices when later combined.                end;            end;        else            EPdata.cov.covMatrix(iSub,:,:)=inputData.cov.covMatrix; %per MNE recommended procedure, the cov is calculated as an SSCP matrix where the variables have been baseline corrected for each epoch.            EPdata.cov.Nq(iSub)=inputData.cov.Nq; %degrees of freedom, for weighting cov matrices when later combined.        end;        if any(strcmp(averagingMethod,{'Frequency-Coherence','Frequency-Phase Lock'}))            fprintf('%60s\n',' ' );        end;    end;    elseif strcmp(dataType,'average') %form grand average        if any(strcmp(averagingMethod,{'Latency-Lock','Jitter-Correct'}))        msg{1}=['Error: Latency-locked and jitter-correction averaging not available for grand averages.'];        [msg]=ep_errorMsg(msg);        return    end;        EPdata.subNames{1}='grand average';    EPdata.subTypes{1}='GAV';    EPdata.subjectSpecs={};    EPdata.subjectSpecNames={};    EPdata.events = cell(1,numCells);    avgNum=[];    subNum=[];    covNum=[];    covMatrix=[];    covNq=[];    trialSpecs=cell(0);    gavData=zeros(size(inputData.data,1),size(inputData.data,2),length(EPdata.cellNames),size(inputData.data,4),size(inputData.data,5),size(inputData.data,6),size(inputData.data,7));        impCount=0;    impGrdCount=0;        %glue together the various subject average files    totNumSubs=0;    for theSession = 1:sessionNum        Name=deblank(inputFiles{theSession});        [pathstr, fileName, ext]=fileparts(Name);                disp(['Working on: ' Name '.']);                if theSession > 1            thisReadArg=readArg;            thisReadArg{end+1}='file';            thisReadArg{end+1}=Name;            thisReadArg{end+1}='silent';            thisReadArg{end+1}='on';            thisReadArg{end+1}='ced';            thisReadArg{end+1}=inputData.ced; %assume all the files averaged together will be using the same ced file.            SMIsuffix=EPmain.preferences.general.SMIsuffix;            if ~isempty(SMIsuffix)                thisReadArg{end+1}='SMIsuffix';                thisReadArg{end+1}=SMIsuffix;            end;            specSuffix=EPmain.preferences.general.specSuffix;            if ~isempty(specSuffix)                thisReadArg{end+1}='specSuffix';                thisReadArg{end+1}=specSuffix;            end;            subjectSpecSuffix=EPmain.preferences.general.subjectSpecSuffix;            if ~isempty(subjectSpecSuffix)                thisReadArg{end+1}='subjectSpecSuffix';                thisReadArg{end+1}=subjectSpecSuffix;            end;            inputData=ep_readData(thisReadArg);            [inputData]=ep_stripAdds(inputData);        end;                numSubs=length(inputData.subNames);        totNumSubs=totNumSubs+numSubs;                [theFileCells cellIndex]=ismember(EPdata.cellNames,inputData.cellNames);        cellIndex=cellIndex(find(cellIndex));        EPdata.analysis.blinkTrial(totNumSubs-numSubs+1:totNumSubs,theFileCells)= inputData.analysis.blinkTrial(:,cellIndex);        EPdata.analysis.saccadeTrial(totNumSubs-numSubs+1:totNumSubs,theFileCells)= inputData.analysis.saccadeTrial(:,cellIndex);        EPdata.analysis.saccadeOnset(totNumSubs-numSubs+1:totNumSubs,theFileCells)= inputData.analysis.saccadeOnset(:,cellIndex);        EPdata.analysis.moveTrial(totNumSubs-numSubs+1:totNumSubs,theFileCells)= inputData.analysis.moveTrial(:,cellIndex);        EPdata.analysis.badTrials(totNumSubs-numSubs+1:totNumSubs,theFileCells)= inputData.analysis.badTrials(:,cellIndex);        for theCell=1:length(inputData.cellNames)            whichCells=find(theFileCells);            EPdata.analysis.badChans(totNumSubs-numSubs+1:totNumSubs,whichCells(theCell),:)= inputData.analysis.badChans(1:numSubs,cellIndex(theCell),:);        end;                for iSpec=1:length(inputData.trialSpecNames)            theSpec=find(strcmp(inputData.trialSpecNames{iSpec},EPdata.trialSpecNames));            if length(theSpec) > 1                theSpec=theSpec(1); %if there are multiple specs with the same name, match to the first one.            end;            if isempty(theSpec)                EPdata.trialSpecNames{end+1}=inputData.trialSpecNames{iSpec};                theSpec=length(EPdata.trialSpecNames);            end;            trialSpecs(theCell,theSpec,totNumSubs-numSubs+1:totNumSubs)=inputData.trialSpecs(theCell,theSpec,:);        end;                for iSub=1:numSubs            for iCell=1:length(cellIndex)                theCell=cellIndex(iCell);                for iEvent=1:length(inputData.events{iSub,theCell})                    EPdata.events{1,theCell}(end+1)=inputData.events{iSub,theCell}(iEvent);                end;            end;        end;                EPdata.recTime(theFileCells)=min(inputData.recTime(cellIndex));        newStims=find(~ismember({inputData.stims.name},{EPdata.stims.name}));        if ~isempty(newStims)            EPdata.stims(end+1:end+length(newStims)) = inputData.stims(newStims);        end;                avgNum(end+1:end+numSubs,1:numCells)=-1;        subNum(end+1:end+numSubs,1:numCells)=-1;        covNum(end+1:end+numSubs,1:numCells)=-1;        avgNum(end-numSubs+1:end,theFileCells)=inputData.avgNum(:,cellIndex);        subNum(end-numSubs+1:end,theFileCells)=inputData.subNum(:,cellIndex);        covNum(end-numSubs+1:end,theFileCells)=inputData.covNum(:,cellIndex);        if ~isempty(inputData.cov)            covMatrix(end+1:end+numSubs,:,:)=inputData.cov.covMatrix;            covNq(end+1:end+numSubs)=inputData.cov.Nq;        end;        if theSession ==1            gavData(:,:,theFileCells,:,:,:,:)=inputData.data(:,:,cellIndex,:,:,:,:);        else            gavData(:,:,theFileCells,end+1:end+numSubs,:,:,:)=inputData.data(:,:,cellIndex,:,:,:,:);        end;                if ~isempty(inputData.impedances.channels)            impCount=impCount+1;            EPdata.impedances.channels=EPdata.impedances.channels+inputData.impedances.channels;        end;        if ~isempty(inputData.impedances.ground)            impGrdCount=impGrdCount+1;            EPdata.impedances.ground=EPdata.impedances.ground+inputData.impedances.ground;        end;    end;    numSubs=totNumSubs;        if impCount    	EPdata.impedances.channels=EPdata.impedances.channels/impCount;    end;    if impGrdCount        EPdata.impedances.ground=EPdata.impedances.ground/impGrdCount;    end;        %compute the grand average        EPdata.data=zeros(numChans,max(numPoints,1),numCells,1,numFacs,max(numFreqs,1),max(numRels,1));    EPdata.noise=zeros(numChans,max(numPoints,1),numCells,1,numFacs);    EPdata.std=zeros(numChans,max(numPoints,1),numCells,1,numFacs,max(numFreqs,1));    EPdata.stdCM=zeros(numChans,max(numPoints,1),numCells,1,numFacs,max(numFreqs,1));    EPdata.trialSpecs=cell(numCells,length(inputData.trialSpecNames),1);    if ~isempty(covMatrix)        %assume cov matrix is different so need to figure out new covariance matrix as well as the new effective sample size for the new combination        %add together cov matrices weighted by their sample size, per MNE manual 2.7.3 p.90.        EPdata.cov.covMatrix=zeros(1,numChans,numChans);        for iSub=1:numSubs            EPdata.cov.covMatrix=EPdata.cov.covMatrix+covMatrix(iSub,:,:)*covNq(iSub);        end;        EPdata.cov.Nq=sum(covNq);        EPdata.cov.covMatrix=EPdata.cov.covMatrix/EPdata.cov.Nq;    else        EPdata.cov=[];    end;    for theCell = 1:numCells        theSubs=[1:numSubs];        badSubs=(avgNum(:,theCell)<0);        theGoodSubs=theSubs(~badSubs);        if isempty(theGoodSubs) %if no good subjects for this cell, fill out values and move on            EPdata.avgNum(1,theCell)=-1;            EPdata.subNum(1,theCell)=-1;            EPdata.covNum(1,theCell)=-1;            EPdata.data(:,:,theCell,1,:)=zeros(numChans,max(numPoints,1),1,1,numFacs,max(numFreqs,1),max(numRels,1));            EPdata.noise(:,:,theCell,1,:)=zeros(numChans,max(numPoints,1),1,1,numFacs);            EPdata.std(:,:,theCell,1,:)=zeros(numChans,max(numPoints,1),1,1,numFacs,max(numFreqs,1));            EPdata.stdCM(:,:,theCell,1,:)=zeros(numChans,max(numPoints,1),1,1,numFacs,max(numFreqs,1));            disp(['Warning: The cell ' EPdata.cellNames{theCell} ' has zero trials.']);            continue        end;        EPdata.avgNum(1,theCell)=sum(avgNum(theGoodSubs,theCell));                %per p.128 of the 3.7.2 MNE manual, 1/Leff=Sigma weight-squared/L        EPdata.covNum(1,theCell)=sum(covNum(theGoodSubs,theCell).^-1)^-1;                EPdata.subNum(1,theCell)=sum(subNum(theGoodSubs,theCell));        switch methodName            case 'Mean'                for theChan = 1:numChans                    chanGoodSubs=theGoodSubs(~isnan(EPdata.analysis.badChans(theGoodSubs,theCell,theChan)));                    numChanGoodSubs=length(chanGoodSubs);                    if numChanGoodSubs==0 %if the channel is bad for all the available good subjects                        EPdata.data(theChan,:,theCell,1,:,:)=zeros(1,max(numPoints,1),1,1,numFacs,numFreqs,max(numRels,1));                        EPdata.std(theChan,:,theCell,1,:,:)=zeros(1,max(numPoints,1),1,1,numFacs,numFreqs);                        EPdata.noise(theChan,:,theCell,1,:)=zeros(1,max(numPoints,1),1,1,numFacs);                        EPdata.analysis.badChans(1,theCell,theChan)=NaN;                    else                        EPdata.analysis.badChans(1,theCell,theChan)=sum(EPdata.analysis.badChans(chanGoodSubs,theCell,theChan),1);                        for theFactor = 1:numFacs                            EPdata.data(theChan,:,theCell,1,theFactor,:,:)=mean(gavData(theChan,:,theCell,chanGoodSubs,theFactor,:,:),4);                            for theSample = 1:max(numPoints,1)                                for theFreq = 1:max(numFreqs,1)                                    EPdata.std(theChan,theSample,theCell,1,theFactor,theFreq)=std(squeeze(gavData(theChan,theSample,theCell,chanGoodSubs,theFactor,theFreq)));                                end;                            end                        end;                        if isempty(EPdata.freqNames)                            noiseData=zeros(1,max(numPoints,1),1,1,1,max(numFreqs,1));                            theSigns=ones(numChanGoodSubs,1);                            if numChanGoodSubs > 1                                theSigns(2:2:end)=-1;                            end;                            for theSub=1:numChanGoodSubs                                noiseData=noiseData+mean(theSigns(theSub)*gavData(theChan,:,theCell,chanGoodSubs(theSub),theFactor,:,:),4);                            end;                            EPdata.noise(theChan,:,theCell,1,theFactor)=noiseData/numChanGoodSubs;                        end;                    end;                end;            case 'Median'                for theChan = 1:numChans                    chanGoodSubs=theGoodSubs(~isnan(EPdata.analysis.badChans(theGoodSubs,theCell,theChan)));                    numChanGoodSubs=length(chanGoodSubs);                    if numChanGoodSubs==0 %if the channel is bad for all the available good subjects                        EPdata.data(theChan,:,theCell,1,:)=zeros(1,max(numPoints,1),1,1,numFacs,max(numFreqs,1),max(numRels,1));                        EPdata.std(theChan,:,theCell,1,:)=zeros(1,max(numPoints,1),1,1,numFacs,max(numFreqs,1));                        EPdata.noise(theChan,:,theCell,1,:)=zeros(1,max(numPoints,1),1,1,numFacs);                        EPdata.analysis.badChans(1,theCell,theChan)=NaN;                    else                        EPdata.analysis.badChans(1,theCell,theChan)=sum(EPdata.analysis.badChans(chanGoodSubs,theCell,theChan),1);                        for theFactor = 1:numFacs                            EPdata.data(theChan,:,theCell,1,theFactor,:,:)=median(gavData(theChan,:,theCell,chanGoodSubs,theFactor,:,:),4);                            for theSample = 1:max(numPoints,1)                                for theFreq = 1:max(numFreqs,1)                                    EPdata.std(theChan,theSample,theCell,1,theFactor,theFreq)=std(squeeze(gavData(theChan,theSample,theCell,chanGoodSubs,theFactor,theFreq)));                                end;                            end                        end;                        if isempty(EPdata.freqNames)                            noiseData=zeros(1,max(numPoints,1),1,1,1,max(numFreqs,1));                            theSigns=ones(numChanGoodSubs,1);                            if numChanGoodSubs > 1                                theSigns(2:2:end)=-1;                            end;                            for theSub=1:numChanGoodSubs                                noiseData=noiseData+mean(theSigns(theSub)*gavData(theChan,:,theCell,chanGoodSubs(theSub),theFactor,:),4);                            end;                            EPdata.noise(theChan,:,theCell,1,theFactor)=noiseData/numChanGoodSubs;                        end;                    end;                end;            case 'Trimmed_Mean'                for theChan = 1:numChans                    chanGoodSubs=theGoodSubs(~isnan(EPdata.analysis.badChans(theGoodSubs,theCell,theChan)));                    numChanGoodSubs=length(chanGoodSubs);                    if numChanGoodSubs==0 %if the channel is bad for all the available good subjects                        EPdata.data(theChan,:,theCell,1,:)=zeros(1,max(numPoints,1),1,1,numFacs,max(numFreqs,1),max(numRels,1));                        EPdata.std(theChan,:,theCell,1,:)=zeros(1,max(numPoints,1),1,1,numFacs,max(numFreqs,1));                        EPdata.noise(theChan,:,theCell,1,:)=zeros(1,max(numPoints,1),1,1,numFacs,max(numFreqs,1));                        EPdata.analysis.badChans(1,theCell,theChan)=NaN;                    else                        EPdata.analysis.badChans(1,theCell,theChan)=sum(EPdata.analysis.badChans(chanGoodSubs,theCell,theChan),1);                        trimSubs=floor(numChanGoodSubs*trimLevel);                        numTrimmedSubs=length(trimSubs+1:numChanGoodSubs-trimSubs);                        theSigns=ones(numTrimmedSubs,1);                        if numTrimmedSubs > 1                            if rand() > .5                                theSigns(2:2:end)=-1;                            else                                theSigns(1:2:end)=-1;                            end;                        end;                        for theSample = 1:max(numPoints,1)                            for theFactor = 1:numFacs                                for theFreq = 1:max(numFreqs,1)                                    for theRel = 1:max(numRels,1)                                        sortedValues=sort(squeeze(gavData(theChan,theSample,theCell,chanGoodSubs,theFactor,theFreq,theRel))); %how to make this work with relationship data? ***                                        EPdata.data(theChan,theSample,theCell,1,theFactor,theFreq,theRel)=mean(sortedValues(trimSubs+1:numTrimmedSubs-trimSubs));                                        if isempty(EPdata.freqNames)                                            EPdata.noise=mean(theSigns.*sortedValues(trimSubs+1:numTrimmedSubs-trimSubs));                                        end;                                        EPdata.std=std(gavData(theChan,theSample,theCell,1,theFactor,theFreq));                                    end;                                end;                            end;                        end;                    end;                end;            otherwise                msg{1}=['Error: The averaging method ' averagingMethod ' is not recognized.'];                [msg]=ep_errorMsg(msg);                return        end;        %generate the averaged trial specs        for iSpec=1:length(inputData.trialSpecNames)            theSpec=find(strcmp(inputData.trialSpecNames{iSpec},EPdata.trialSpecNames));            if length(theSpec) > 1                theSpec=theSpec(1); %if there are multiple specs with the same name, match to the first one.            end;            if ischar(trialSpecs{theCell,theSpec,1}) && all(strcmp(trialSpecs{theCell,theSpec,1},trialSpecs(theCell,theSpec,:)))                EPdata.trialSpecs{theCell,theSpec,1}=trialSpecs{1,theSpec,1};            else                theSpecs=squeeze(trialSpecs(theCell,theSpec,:));                theStrSpecs=find(cellfun(@ischar,theSpecs));                for iStrSpec=1:length(theStrSpecs)                    theStrSpec=theStrSpecs(iStrSpec);                    theSpecs{theStrSpec}=str2double(theSpecs{theStrSpec});                end;                EPdata.trialSpecs{theCell,theSpec,1}=mean(cell2mat(theSpecs));            end;        end;          end;    %generate stdCM    for iChan=1:numChans        for iSample = 1:max(numPoints,1)            for iFactor = 1:numFacs                for iFreq = 1:max(numFreqs,1)                    for iRel = 1:max(numRels,1)                        grandMean=0;                        for iSub=1:numSubs                            for iCell=1:numCells                                if (avgNum(iSub,iCell)>-1)                                    grandMean=grandMean+inputData.data(iChan,iSample,iCell,iSub,iFactor,iFreq,iRel);                                end;                            end;                        end;                        CMdata=nan(numSubs,numCells);                        for iSub=1:numSubs                            goodCells=find(avgNum(iSub,:)>-1);                            CMdata(iSub,goodCells)=squeeze((inputData.data(iChan,iSample,goodCells,iSub,iFactor,iFreq,iRel))-mean(squeeze(inputData.data(iChan,iSample,goodCells,iSub,iFactor,iFreq,iRel)))+grandMean);                        end;                        for iCell=1:numCells                            CMcol=CMdata(:,iCell);                            numCMcol=length(find(~isnan(CMcol)));                            EPdata.stdCM(iChan,iSample,iCell,1,iFactor,iFreq,iRel)=std(CMcol(~isnan(CMcol)))*sqrt(numCMcol/(numCMcol-1));                        end;                    end;                end;            end;        end;    end;    EPdata.analysis.blinkTrial=sum(EPdata.analysis.blinkTrial,1);    EPdata.analysis.saccadeTrial=sum(EPdata.analysis.saccadeTrial,1);    saccadeOnset=EPdata.analysis.saccadeOnset;    EPdata.analysis.saccadeOnset=zeros(1,length(EPdata.analysis.saccadeTrial));    for i=1:length(EPdata.analysis.saccadeTrial)        if EPdata.analysis.saccadeTrial(i) == 0            EPdata.analysis.saccadeOnset(i)=0;        else            EPdata.analysis.saccadeOnset(i)=sum(saccadeOnset(:,i))/EPdata.analysis.saccadeTrial(i); %compute average saccade onset        end;    end;    EPdata.analysis.moveTrial=sum(EPdata.analysis.moveTrial,1);    EPdata.analysis.badTrials=sum(EPdata.analysis.badTrials,1);    EPdata.analysis.badChans=EPdata.analysis.badChans(1,:,:);    else    msg{1}=['Error: The data type ' dataType ' is not recognized.'];    [msg]=ep_errorMsg(msg);    returnend;if ~isempty(inputData.freqNames) && ~any(strcmp(averagingMethod,{'Frequency-Coherence','Frequency-Phase Lock'}))    %assume all the input files were comparable since this function checks for that.    EPdata.noise=[]; %+/- noise estimate does not work for FFT data since all the power values will be positive.end;if strcmp(averagingMethod,'Frequency-Coherence')    EPdata.noise=[];    EPdata.std=[];end;%ensure fields are in standard order.[EPfieldNames]=ep_fieldNames;modelEPdata=[];for i=1:length(EPfieldNames)    modelEPdata.(EPfieldNames{i})=[];end;if ~isequal(EPfieldNames,fieldnames(EPdata))    EPdata = orderfields(EPdata, modelEPdata);end;[err]=ep_checkEPfile(EPdata);disp('Finished averaging.');