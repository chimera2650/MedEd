function ep_transformData(inputFiles,inputFormat,fileType,outputFormat,referenceMethod,transform,domainName,methodName,dataMode)%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% ep_transformData(inputFiles,inputFormat,fileType,outputFormat,referenceMethod,transform,domainName,methodName,dataMode)% Rereferences, baseline corrects data, filters, and performs spectral analysis on files.% Will refuse to operate on a factor file as it would be invalid.  The PCA results are affected by whether the% data are baseline corrected or how it is referenced so such operations should be applied prior to the PCA.%%	Reads in specified data files, rereferences them and baseline corrects them.%   Saves the resulting output data.%%Inputs%   inputFiles: cell array of file names to correct.  Assumes active directory if path not specified.  (default: will ask for files)%   inputFormat: input file format.%   fileType: input file type.%   outputFormat: output file format.%   referenceMethod: Type of referencing: 'none','average','traditional'.%   transform%       refChan1: First channel used for traditional referencing.  Zero for not used.%       refChan2: Second channel used for traditional referencing.  Zero for not used.%       baselineStart: Left side of sample starting baseline period in msec.  Empty if no baseline correction%       baselineEnd: Right side of sample ending baseline period in msec.  Empty if no baseline correction%       preStim: The number of msec the start of the epoch is positioned with respect to the stimulus (pos. means before stimulus).%       smoothing: Frequency smoothing for frequency domain analysis.%       cfgFilter: configuration settings for filtering.%   domainName: Domain of analysis: 'Time','Frequency','Time-Frequency'.%   methodName: Method used to carry out transformation.%   dataMode: Data collection mode to which to apply transforms (EEG, MEG, pupil, ECG, ANS)%%Outputs%	Writes transformed file.%% History:%% by Joseph Dien (7/20/09)% jdien07@mac.com%% bugfix 1/27/10 JD% Update baseline field when using Postprocess function to baseline correct data.%% modified 2/16/10 JD% analysis fields no longer optional.% Eliminated chantype field for implicit channels.%% bugfix 2/27/10 JD% Eliminated updating of baseline field.  The part of the segment used for baseline correction may not necessarily% correspond to the prestimulus period.%% bugfix 5/26/10 JD% Fixed crash when rereferencing and there are no implicit channels.%% modified 2/15/12 JD% Added support for frequency and time-frequency analysis%% modified 1/25/12 JD% Eliminated REF channel type and added reference field to keep track of original and current reference scheme.%% modified 2/22/12 JD% Noise and std fields no longer optional.  Now set to empty if not used.%% modified 2/23/12 JD% Adds suffix number if file already exists rather than overwriting.%% modified 6/6/12 JD% Added prestim field.%% bugfix 8/4/12 JD% Fixed overwriting existing file if the output file format differed from the input file format.%% modified 8/6/12 JD% Added suport for coherence and phase locking measures.%% bugfix 11/4/12 JD% Fixed not updating reference type to REG or AVG when referencing.%% modified 1/11/13 JD% Added option to do internal calculations of frequency data in either amplitude or power form.%% modified & bugfix 1/15/13 JD% Added frequency filtering (low pass, high pass, bandpass, bandstop, notch).% Fixed not changing prestimulus period when reference set to "none."% Added detrend option.%% bugfix 2/4/13 JD% Fixed running baseline correction even on frequency domain data even though baseline fields are grayed out.% % modified 9/25/13 JD% Restricted rereferencing to EEG channels.%% bugfix 10/10/13 JD% Update history field.%% modified 11/13/13 JD% Filtering will not cross boundaries.%% bugfix 11/22/13 JD% Fixed frequency domain transform of continuous data not generating proper recTime field, resulting in later crashes.%% modified 4/18/14 JD% Allows choosing either Hanning or multi-taper methods for spectral measures.% Eliminated upper bound to smoothing as no longer seems to apply.%% modified 6/9/14 JD% Transforms can be applied to non-EEG channel types and which data mode can be specified.%% bugfix 6/9/14 JD% Fixed crash when filtering continuous data and there are no boundary events present.%% modified 7/8/14 JD% Changed filter parameters to allow for full range of FieldTrip filter% settings by using using config as the input variable.%% modified 8/12/14 JD% Added support for PARE-corrected average reference.%% bugfix 8/12/14 JD% Set std field to empty rather than trying to rereference.%% modified 8/31/14 JD% Added support for adding additional keys information to events in continuous data and trial specs in single-trial% data.%% modified 9/17/14 JD% Adding event output for files that don't support events.%% modified 10/16/14 JD% Passes screen size to ep_readData call.%% bugfix 12/12/14 JD% Fixed crash when frequency transforming and there are non EEG channels% present.%% bugfix 1/7/14 JD% Fixed losing electrode coordinates when filtering data from an mff file.%% modified 7/4/15 JD% Performs average reference prior to performing PARE correction.%% bugfix 8/31/15 JD% Changed the frequency bins so that the first one starts at the frequency% resolution (e.g., 2hz if the bins are 2Hz wide) rather than always at 1.% Fixed crash when signal processing toolbox is installed and using% multi-taper method for time-frequency transform.%% bugfix 9/28/15 JD% Transform function not applying electrode coordinate rotation and text% file preference settings.%% modified 1/15/16 JD% Amplitude FFT data are represented in complex form.%% bugfix 1/22/16 JD% Fixed crash when performing frequency transform on continuous data files.%% modified 3/8/16 JD% Eliminated support for .power field.%% bugfix & modified 10/10/16 JD% Fixed crash when performing time-frequency transform with dpss multi-taper on continuous data or segments longer than .5 seconds and default smoothing of one second.% Fixed time-frequency transform being applied only to first one second of continuous data.% Time-frequency transform no longer drops non-EEG/MEG channels.% Event times now updated to new sample times when performing TFT with Transform Data funcion.%% modified 11/5/16 JD% Added support for reading and writing subject spec text files.%% bugfix & modified 6/19/17 JD% Fixed crash when performing time-frequency transform on single-trial data files.% When performing time-frequency transform on continuous data files, lops off data at ends in increments of one second to that edit epochs still align properly.% Previously would either crash or the edit epochs would end up misaligned by half of the T-F window (which was .5 seconds by default).% Also, since the T-F transform reaches into the adjoining epochs, if they were bad data then the current epoch is also marked as being bad (both for trial and for channels).% Allow baseline correction to be applied to TFT data.%% modified 2/11/18 JD% Added support for stdCM field.%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%     Copyright (C) 1999-2018  Joseph Dien%%     This program is free software: you can redistribute it and/or modify%     it under the terms of the GNU General Public License as published by%     the Free Software Foundation, either version 3 of the License, or%     (at your option) any later version.%%     This program is distributed in the hope that it will be useful,%     but WITHOUT ANY WARRANTY; without even the implied warranty of%     MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the%     GNU General Public License for more details.%%     You should have received a copy of the GNU General Public License%     along with this program.  If not, see <http://www.gnu.org/licenses/>.%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%global EPmaincfg=[];refChan1=transform.refChan1;refChan2=transform.refChan2;baselineStart=transform.baselineStart;baselineEnd=transform.baselineEnd;preStim=transform.preStim;smoothing=transform.smoothing;doDetrend=transform.detrend;textPrefs.firstRow=EPmain.preferences.general.firstRow;textPrefs.lastRow=EPmain.preferences.general.lastRow;textPrefs.firstCol=EPmain.preferences.general.firstCol;textPrefs.lastCol=EPmain.preferences.general.lastCol;textPrefs.orientation=EPmain.preferences.general.orientation;if isempty(inputFiles)    [inputFiles, activeDirectory]=ep_getFilesUI(inputFormat);    if inputFiles{1}==0        msg{1}='No filenames selected. You have to click on a name';        [msg]=ep_errorMsg(msg);        return    end    for theFile=1:size(inputFiles,2)        inputFiles{theFile}=[activeDirectory inputFiles{theFile}];    end;else    files=dir;    for theFile=1:size(inputFiles,2)        [activeDirectory, name, ext] = fileparts(inputFiles{theFile});        if isempty(activeDirectory)            activeDirectory=pwd;            inputFiles{theFile}=[activeDirectory filesep inputFiles{theFile}];        end;        if ~exist(inputFiles{theFile},'file')            msg{1}=['Error: The file ' inputFiles{theFile} ' is not in the directory.'];            [msg]=ep_errorMsg(msg);            return        end;    end;end;inputFiles=inputFiles';sessionNum = size(inputFiles,1);readArg{1}='format';readArg{2}=inputFormat;readArg{3}='screenSize';readArg{4}=EPmain.scrsz;readArg{5}='FontSize';readArg{6}=EPmain.fontsize;readArg{7}='textPrefs';readArg{8}=textPrefs;readArg{9}='elecPrefs';readArg{10}=EPmain.preferences.general.rotateHead;if ~strcmp(inputFormat,'ep_mat')    readArg{end+1}='type';    readArg{end+1}=fileType;end;SMIsuffix=EPmain.preferences.general.SMIsuffix;if ~isempty(SMIsuffix)    readArg{end+1}='SMIsuffix';    readArg{end+1}=SMIsuffix;end;specSuffix=EPmain.preferences.general.specSuffix;if ~isempty(specSuffix)    readArg{end+1}='specSuffix';    readArg{end+1}=specSuffix;end;subjectSpecSuffix=EPmain.preferences.general.subjectSpecSuffix;if ~isempty(subjectSpecSuffix)    readArg{end+1}='subjectSpecSuffix';    readArg{end+1}=subjectSpecSuffix;end;BVheader=EPmain.preferences.general.BVheader;if ~isempty(BVheader)    readArg{end+1}='BVheader';    readArg{end+1}=BVheader;end;%assume the first session file is representative of the rest.Name=deblank(inputFiles{1});thisReadArg=readArg;thisReadArg{end+1}='file';%[pathstr, fileName, ext]=fileparts(Name);thisReadArg{end+1}=Name;thisReadArg{end+1}='silent';thisReadArg{end+1}='on';data=ep_readData(thisReadArg);if isempty(data)    msg{1}=['Error: The file ' inputFiles{1} ' was not read successfully.'];    [msg]=ep_errorMsg(msg);    returnend;[data]=ep_stripAdds(data);if isempty(data.eloc)    msg{1}=['Error: The file ' inputFiles{1} ' has no information on channel locations.  .ced file needed.'];    [msg]=ep_errorMsg(msg);    returnend;if isempty(data.data)    msg{1}=['Error: The file ' inputFiles{1} ' had no data left to correct after additions were removed.'];    [msg]=ep_errorMsg(msg);    returnend;if ~strcmp(referenceMethod,'none') && ~isempty(data.freqNames)    msg{1}=['Error: The file ' inputFiles{1} ' cannot be rereferenced as it has already been frequency transformed.'];    [msg]=ep_errorMsg(msg);    returnend;if strcmp(domainName,{'Time-Frequency','Frequency'})    if ~isempty(ismember(inpuData.chanTypes,{'EEG','REG'})) && ~isempty(ismember(inpuData.chanTypes,{'MGM','MGA','MGP'}))        disp('EP Toolkit must spectrally analyze both EEG and MEG channels if present and so will do so.');    end;    if length(find(ismember(inpuData.chanTypes,{'EEG','REG','MGM','MGA','MGP'}))) ~= length(inpuData.chanTypes)        disp('Channel types other than EEG and MEG will be dropped when performing spectral analysis upon file.');    end;    end;%Check to make sure the files all have the same number of channels.if sessionNum > 1    disp('Checking files for consistency.');end;for theFile=2:sessionNum    Name2=deblank(inputFiles{theFile});    thisReadArg2=readArg;    thisReadArg2{end+1}='file';    %[pathstr, fileName, ext]=fileparts(Name2);    thisReadArg2{end+1}=Name2;    thisReadArg2{end+1}='silent';    thisReadArg2{end+1}='on';    thisReadArg2{end+1}='ced';    thisReadArg2{end+1}=data.ced; %assume they all have the same channel coordinates    thisReadArg2{end+1}='montage';    thisReadArg2{end+1}=data.montage; %assume they all have the same montage    thisReadArg2{end+1}='eloc';    thisReadArg2{end+1}=data.eloc; %assume they all have the same channel coordinates    SMIsuffix=EPmain.preferences.general.SMIsuffix;    if ~isempty(SMIsuffix)        thisReadArg2{end+1}='SMIsuffix';        thisReadArg2{end+1}=SMIsuffix;    end;    specSuffix=EPmain.preferences.general.specSuffix;    if ~isempty(specSuffix)        thisReadArg2{end+1}='specSuffix';        thisReadArg2{end+1}=specSuffix;    end;    subjectSpecSuffix=EPmain.preferences.general.subjectSpecSuffix;    if ~isempty(subjectSpecSuffix)        thisReadArg2{end+1}='subjectSpecSuffix';        thisReadArg2{end+1}=subjectSpecSuffix;    end;    BVheader=EPmain.preferences.general.BVheader;    if ~isempty(BVheader)        thisReadArg2{end+1}='BVheader';        thisReadArg2{end+1}=BVheader;    end;        data2=ep_readData(thisReadArg2);    [data2]=ep_stripAdds(data2);    if (length(data.chanNames) ~= length(data2.chanNames))        msg{1}=['Error: The file ' inputFiles{theFile} ' has a different set of channels.'];        [msg]=ep_errorMsg(msg);        return    end;    if ~strcmp(referenceMethod,'none') && ~isempty(data2.freqNames)        msg{1}=['Error: The file ' inputFiles{theFile} ' cannot be rereferenced as it has already been frequency transformed.'];        [msg]=ep_errorMsg(msg);        return    end;end;%Start processing filesfor file=1:length(inputFiles)    tic    Name=deblank(inputFiles{file});    thisReadArg=readArg;    thisReadArg{end+1}='file';    thisReadArg{end+1}=Name;    thisReadArg{end+1}='silent';    thisReadArg{end+1}='on';    thisReadArg{end+1}='ced';    thisReadArg{end+1}=data.ced; %assume they all have the same channel coordinates so doesn't have to keep asking the user for the coordinates    thisReadArg{end+1}='montage';    thisReadArg{end+1}=data.montage; %assume they all have the same montage    thisReadArg{end+1}='eloc';    thisReadArg{end+1}=data.eloc; %assume they all have the same channel coordinates        Name=deblank(inputFiles{file});    [pathstr, fileName, ext]=fileparts(Name);    disp(['Working on #' num2str(file) ': ' fileName '.']);    inputData=ep_readData(thisReadArg);        if length(inputData.facNames) > 1        msg{1}=['Error: The file ' fileName ' is a factor file.'];        [msg]=ep_errorMsg(msg);        return    end;        if strcmp(inputData.dataType,'continuous')        theSegment = 'one second epoch';    else        theSegment = 'trial';    end;        numChans=length(inputData.chanNames);    EEGchans=find(strcmp('EEG',inputData.chanTypes));    EEGREGchans=find(ismember(inputData.chanTypes,{'EEG','REG'}));    numEEGchans=length(EEGchans);    numPoints=length(inputData.timeNames);    numCells=length(unique(inputData.cellNames));    numWaves=length(inputData.cellNames);    numSubs=length(inputData.subNames);    numFreqs=length(inputData.freqNames);    numFacs=size(inputData.data,5);    numCMBfacs=size(inputData.facData,5);    suffix=[];        switch dataMode        case 'EEG'            modeChans=find(ismember(inputData.chanTypes,{'EEG','REG'}));        case 'MEG'            modeChans=find(ismember(inputData.chanTypes,{'MGM','MGA','MGP'}));        case 'pupil'            modeChans=find(strcmp('PPL',inputData.chanTypes));        case 'ECG'            modeChans=find(strcmp('ECG',inputData.chanTypes));        case 'ANS'            modeChans=find(strcmp('ANS',inputData.chanTypes));        otherwise            disp('Oops: programmer error.');            return    end;            %Change prestim period        if ~isempty(preStim)        inputData.timeNames=(((0:length(inputData.timeNames)-1)+inputData.baseline)*(1000/inputData.Fs))';        inputData.baseline=preStim/(1000/inputData.Fs);        inputData.timeNames=(((0:length(inputData.timeNames)-1)-inputData.baseline)*(1000/inputData.Fs))';    end;        if ~strcmp(referenceMethod,'none')        %make implicit reference channel explicit        if ~isempty(inputData.implicit)            theRef=find(strcmp({inputData.implicit.type},'REF'));        else            theRef=[];        end;        if length(theRef) == 1 %can't make implicit reference explicit if there is more than one such ref site            inputData.data(end+1,:,:,:,:)=zeros(1,numPoints,numWaves,numSubs,numFacs);            if ~isempty(inputData.facData)                inputData.facData(end+1,:,:,:,:)=zeros(1,numPoints,numWaves,numSubs,numCMBfacs);            end;            if ~isempty(inputData.noise)                inputData.noise(end+1,:,:,:,:)=zeros(1,numPoints,numWaves,numSubs,numCMBfacs);            end;            if ~isempty(inputData.std)                inputData.std(end+1,:,:,:,:)=zeros(1,numPoints,numWaves,numSubs,numCMBfacs);            end;            if ~isempty(inputData.stdCM)                inputData.stdCM(end+1,:,:,:,:)=zeros(1,numPoints,numWaves,numSubs,numCMBfacs);            end;            inputData.chanNames{end+1}=inputData.implicit(theRef).labels;            inputData.chanTypes{end+1}='EEG';            theEloc=inputData.implicit(theRef);            inputData.eloc(end+1)=theEloc;            inputData.implicit=inputData.implicit([1:theRef-1 theRef+1:end]);            inputData.analysis.badChans(:,:,end+1)=zeros(numSubs,numWaves);                                    numChans=numChans+1;        end;                %rereference data        switch referenceMethod            case 'Average'                referenceData=mean(inputData.data(EEGchans,:,:,:,:,:),1);                for iChan=1:length(EEGREGchans)                    theChan=EEGREGchans(iChan);                    inputData.data(theChan,:,:,:,:)=inputData.data(theChan,:,:,:,:)-referenceData;                end;                if ~isempty(inputData.facData)                    referenceData=mean(inputData.facData(EEGchans,:,:,:,:,:),1);                    for iChan=1:length(EEGREGchans)                        theChan=EEGREGchans(iChan);                        inputData.facData(theChan,:,:,:,:)=inputData.facData(theChan,:,:,:,:)-referenceData;                    end;                end;                if ~isempty(inputData.noise)                    referenceData=mean(inputData.noise(EEGchans,:,:,:,:,:),1);                    for iChan=1:length(EEGREGchans)                        theChan=EEGREGchans(iChan);                        inputData.noise(theChan,:,:,:,:)=inputData.noise(theChan,:,:,:,:)-referenceData;                    end;                end;                inputData.std=[]; %variance is non-linear measure so can't determine                inputData.stdCM=[]; %variance is non-linear measure so can't determine                inputData.reference.type='AVG';                suffix=[suffix 'r'];            case 'Traditional'                refChans=[];                if ~isempty(refChan1)                    if (refChan1 > 0) && (refChan1 <= numChans)                        refChans=[refChans refChan1];                        inputData.reference.current(1)=refChan1;                    end;                end;                if ~isempty(refChan2)                    if (refChan2 > 0) && (refChan2 <= numChans)                        refChans=[refChans refChan2];                        inputData.reference.current(2)=refChan2;                    end;                end;                if isempty(refChans)                    msg{1}=['Error: Reference channels ' num2str(refChan1) ' and ' num2str(refChan2) ' invalid.'];                    [msg]=ep_errorMsg(msg);                    return                end;                inputData.reference.type='REG';                referenceData=mean(inputData.data(refChans,:,:,:,:),1);                for iChan=1:length(EEGREGchans)                    theChan=EEGREGchans(iChan);                    inputData.data(theChan,:,:,:,:)=inputData.data(theChan,:,:,:,:)-referenceData;                end;                if ~isempty(inputData.facData)                    referenceData=mean(inputData.facData(refChans,:,:,:,:),1);                    for iChan=1:length(EEGREGchans)                        theChan=EEGREGchans(iChan);                        inputData.facData(theChan,:,:,:,:)=inputData.facData(theChan,:,:,:,:)-referenceData;                    end;                end;                if ~isempty(inputData.noise)                    referenceData=mean(inputData.noise(refChans,:,:,:,:),1);                    for iChan=1:length(EEGREGchans)                        theChan=EEGREGchans(iChan);                        inputData.noise(theChan,:,:,:,:)=inputData.noise(theChan,:,:,:,:)-referenceData;                    end;                end;                inputData.std=[]; %variance is non-linear measure so can't determine                inputData.stdCM=[]; %variance is non-linear measure so can't determine                suffix=[suffix 'r'];            case 'CSD'                if strcmp(inputData.reference.type,'CSD')                    msg{1}=['Error: The file ' fileName ' is already a CSD file.'];                    [msg]=ep_errorMsg(msg);                    return                end;                if any(strcmp('REG',inputData.chanTypes))                    disp(['Stripping out regional channels as they will not CSD properly.']);                end;                [inputData]=ep_stripAdds(inputData,{'SGLchan','SGLcell','CMBcell','RAW','AVG','GAV','SGLfac','CMBfac'});                disp('Using FieldTrip function ft_scalpcurrentdensity to perform CSD.');                numChans=length(inputData.chanNames);                switch dataMode                    case 'EEG'                        modeChans=find(ismember(inputData.chanTypes,{'EEG','REG'}));                    case 'MEG'                        modeChans=find(ismember(inputData.chanTypes,{'MGM','MGA','MGP'}));                    case 'pupil'                        modeChans=find(strcmp('PPL',inputData.chanTypes));                    case 'ECG'                        modeChans=find(strcmp('ECG',inputData.chanTypes));                    case 'ANS'                        modeChans=find(strcmp('ANS',inputData.chanTypes));                    otherwise                        disp('Oops: programmer error.');                        return                end;                inputData.std=[]; %CSD is non-linear measure so can't determine                inputData.stdCM=[]; %CSD is non-linear measure so can't determine                inputData.noise=[]; %CSD is non-linear measure so can't determine                inputData.reference.type='CSD';                inputData.reference.current=[];                cfg=[];                cfg.method='spline';                cfg.trials='all';                cfg.elec.pnt=zeros(numEEGchans,3);                for chan=1:numEEGchans                    cfg.elec.label{chan}=inputData.chanNames{chan};                    cfg.elec.pnt(chan,1)=inputData.eloc(chan).X;                    cfg.elec.pnt(chan,2)=inputData.eloc(chan).Y;                    cfg.elec.pnt(chan,3)=inputData.eloc(chan).Z;                end;                outputData=zeros(numEEGchans,numPoints,numWaves,numSubs,numFacs,numFreqs);                                fprintf('%60s\n',' ' );                for theTrial=1:numWaves                    if strcmp(inputData.dataType,'continuous')                        whichTrial=[];                        disp('Applying CSD to entire data length.');                    else                        whichTrial=theTrial;                        fprintf('%s%-60s',repmat(sprintf('\b'),1,60),sprintf('%s%4d of %4d',['Applying CSD to ' theSegment '# '], theTrial, numWaves))                    end;                                        for theSubject=1:numSubs                        for theFactor = 1:numFacs                            try                                evalc('[csdData] = ft_scalpcurrentdensity(cfg, ep_ep2ft(ep_selectData(inputData,{EEGchans,[],whichTrial,theSubject,theFactor,[]})));');                            catch                                msg{1}=['Error: CSD did not work.  One possibility is that this is a Mac and the Developer package has not been installed from the installation disk.  See tutorial.'];                                [msg]=ep_errorMsg(msg);                                return                            end;                             if isfield(csdData,'trial')                                 tempData=csdData.trial{1};                                outputData(EEGchans,:,theTrial,theSubject,theFactor,1) = csdData.trial{1};                             elseif isfield(csdData,'avg')                                outputData(EEGchans,:,theTrial,theSubject,theFactor,1) = csdData.avg;                             else                                msg{1}=['Error: CSD did not work.'];                                [msg]=ep_errorMsg(msg);                                return                             end;                            if ~isempty(setdiff([1:numChans],EEGREGchans)) %put non-EEG channels back in.                                tempData=ep_selectData(inputData,{setdiff([1:numChans],EEGREGchans),[],whichTrial,theSubject,theFactor,[]});                                outputData(setdiff([1:numChans],EEGREGchans),:,theTrial,theSubject,theFactor,1) = tempData.data;                            end;                        end;                    end;                end;                fprintf('%60s\n',' ' );                inputData.data=outputData;                suffix=[suffix 'c'];            case 'PARE'%                 %first drop electrodes without coordinates%                 disp('Dropping channels without electrode coordinates and regional channels.');%                  hasLoc=[];%                 for iChan=1:length(EEGchans)%                     if ~isempty(inputData.eloc(EEGchans(iChan)).theta)%                         hasLoc(end+1)=iChan;%                     end;%                 end;%                 EEGchans=EEGchans(hasLoc);%                 %                 if isempty(EEGchans)%                     msg{1}=['Error: The EEG channels have no electrode coordinates.'];%                     [msg]=ep_errorMsg(msg);%                     done%                     return%                 end;%                 %                 [inputData]=ep_selectData(inputData,{EEGchans,[],[],[],[],[]});                                %next average reference the data                referenceData=mean(inputData.data(EEGchans,:,:,:,:,:),1);                for iChan=1:length(EEGREGchans)                    theChan=EEGREGchans(iChan);                    inputData.data(theChan,:,:,:,:)=inputData.data(theChan,:,:,:,:)-referenceData;                end;                if ~isempty(inputData.facData)                    referenceData=mean(inputData.facData(EEGchans,:,:,:,:,:),1);                    for iChan=1:length(EEGREGchans)                        theChan=EEGREGchans(iChan);                        inputData.facData(theChan,:,:,:,:)=inputData.facData(theChan,:,:,:,:)-referenceData;                    end;                end;                if ~isempty(inputData.noise)                    referenceData=mean(inputData.noise(EEGchans,:,:,:,:,:),1);                    for iChan=1:length(EEGREGchans)                        theChan=EEGREGchans(iChan);                        inputData.noise(theChan,:,:,:,:)=inputData.noise(theChan,:,:,:,:)-referenceData;                    end;                end;                                %finally apply the PARE correction                nSides=10;                [sphereCoords, elecInSphere]=ep_sphereHead(nSides, inputData.eloc);                disp('Applying PARE.  This is a very slow process.');                for iFactor=1:numFacs                    if numFacs > 1                        disp(['Factor #' num2str(iFactor) ' of ' num2str(numFacs)]);                    end;                    for iSub=1:numSubs                        if numSubs > 1                            disp(['Subject #' num2str(iSub) ' of ' num2str(numSubs)]);                        end;                        fprintf('%60s\n',' ' );                        for iCell=1:numWaves                            if numWaves > 1                                disp(['Cell #' num2str(iCell) ' of ' num2str(numWaves)]);                            end;                            fprintf('%60s\n',' ' );                            for iPoint=1:numPoints                                fprintf('%s%-60s',repmat(sprintf('\b'),1,60),sprintf('%s%4d of %4d',['Applying PARE to point # '], iPoint, numPoints))                                theData=squeeze(inputData.data(EEGchans,iPoint,iCell,iSub,iFactor,:,:));                                sphereValues=ep_interpolateHead(theData, elecInSphere, sphereCoords);                                referenceData=mean(mean(sphereValues));                                inputData.data(EEGREGchans,iPoint,iCell,iSub,iFactor,:,:)=inputData.data(EEGREGchans,iPoint,iCell,iSub,iFactor,:,:)-referenceData;                                for iChan=1:length(EEGREGchans)                                    theChan=EEGREGchans(iChan);                                    inputData.data(theChan,:,:,:,:)=inputData.data(theChan,:,:,:,:)-referenceData;                                end;                                if ~isempty(inputData.facData)                                    theData=squeeze(inputData.facData(EEGchans,iPoint,iCell,iSub,iFactor));                                    sphereValues=ep_interpolateHead(theData, elecInSphere, sphereCoords);                                    sphereValues=sphereValues(:);                                    sphereValues=sphereValues(nSides+1:end-nSides);                                    refValue=mean(sphereValues);                                    inputData.facData(EEGREGchans,iPoint,iCell,iSub,iFactor)=inputData.facData(EEGREGchans,iPoint,iCell,iSub,iFactor)-referenceData;                                end;                                if ~isempty(inputData.noise)                                    theData=squeeze(inputData.noise(EEGchans,iPoint,iCell,iSub,iFactor));                                    sphereValues=ep_interpolateHead(theData, elecInSphere, sphereCoords);                                    referenceData=mean(mean(sphereValues));                                    inputData.noise(EEGREGchans,iPoint,iCell,iSub,iFactor)=inputData.noise(EEGREGchans,iPoint,iCell,iSub,iFactor)-referenceData;                                end;                                inputData.std=[]; %variance is non-linear measure so can't determine                                inputData.stdCM=[]; %variance is non-linear measure so can't determine                            end;                            fprintf('%60s\n',' ' );                        end;                     end;                end;                inputData.reference.type='PAR';                suffix=[suffix 'r'];            otherwise                msg{1}=['Error: Reference method ' referenceMethod ' not recognized.'];                [msg]=ep_errorMsg(msg);                return        end;    end;            %detrend data    if doDetrend        if ~isempty(inputData.freqNames) && strcmp(dataMode,'EEG')            msg{1}=['Error: The file ' fileName ' is already an FFT file.  Detrending cannot be performed upon it'];            [msg]=ep_errorMsg(msg);            return        else            fprintf('%60s\n',' ' );            for theTrial=1:numWaves                fprintf('%s%-60s',repmat(sprintf('\b'),1,60),sprintf('%s%4d of %4d',['Applying detrending to ' theSegment '# '], theTrial, numWaves))                for theSubject=1:numSubs                    for theFactor = 1:numFacs                        theData=inputData.data(modeChans,:,theTrial,theSubject,theFactor);                        theData=detrend(theData')';                        inputData.data(modeChans,:,theTrial,theSubject,theFactor)=theData;                    end;                end;            end;            fprintf('%60s\n',' ' );            suffix=[suffix 'd'];        end;    end;        %baseline correct data%     if (~isempty(baselineStart) && ~isempty(baselineEnd)) && ~any(strcmp(domainName,{'Frequency','Time-Frequency'}))    if (~isempty(baselineStart) && ~isempty(baselineEnd)) && ~strcmp(domainName,'Frequency')        if isnumeric(baselineStart) && isnumeric(baselineEnd)            if (baselineEnd >= inputData.timeNames(1)) && (baselineStart <= inputData.timeNames(end))                baseline=find((inputData.timeNames >= baselineStart)&(inputData.timeNames < baselineEnd));                if isempty(baseline)                    msg{1}=['Error: Baseline period invalid.  No time points within baseline specified.'];                    [msg]=ep_errorMsg(msg);                    return                else                    for iChan=1:length(modeChans)                        theChan=modeChans(iChan);                        baselineData=mean(inputData.data(theChan,baseline,:,:,:),2);                        for thePoint=1:numPoints                            inputData.data(theChan,thePoint,:,:,:)=inputData.data(theChan,thePoint,:,:,:)-baselineData;                        end;                    end;                    if ~isempty(inputData.facData)                        for iChan=1:length(modeChans)                            theChan=modeChans(iChan);                            baselineData=mean(inputData.facData(theChan,baseline,:,:,:),2);                            for thePoint=1:numPoints                                inputData.facData(theChan,thePoint,:,:,:)=inputData.facData(theChan,thePoint,:,:,:)-baselineData;                            end;                        end;                    end                    if ~isempty(inputData.noise)                        for iChan=1:length(modeChans)                            theChan=modeChans(iChan);                            baselineData=mean(inputData.noise(theChan,baseline,:,:,:),2);                            for thePoint=1:numPoints                                inputData.noise(theChan,thePoint,:,:,:)=inputData.noise(theChan,thePoint,:,:,:)-baselineData;                            end;                        end;                    end                    suffix=[suffix 'b'];                end;            else                msg{1}=['Error: Baseline period invalid.  Note that Prestim should be positive for prior to event.'];                [msg]=ep_errorMsg(msg);                return            end;        else            msg{1}=['Error: Baseline period invalid.'];            [msg]=ep_errorMsg(msg);            return        end;    end;        %filter data    if ~isempty(transform.cfgFilter)        inputData=ep_filterData(inputData,transform.cfgFilter,modeChans);        suffix=[suffix 'f'];    end;        %spectral analysis of data    spectralChans=find(ismember(inputData.chanTypes,{'MGM','MGA','MGP','EEG','REG'}));    spectralChans=setdiff(spectralChans,find(ismember(inputData.chanNames,{'Hsaccade','Vsaccade'})));    nonSpecChans=setdiff([1:numChans],spectralChans);    switch domainName        case 'Time'            outputData=inputData.data;        case 'Frequency'            if ~isempty(inputData.freqNames)                msg{1}=['Error: The file ' fileName ' is already an FFT file.'];                [msg]=ep_errorMsg(msg);                return            end;            disp('Using FieldTrip function ft_freqanalysis to perform spectral analysis.');            cfg=[];            cfg.method='mtmfft';            cfg.output='fourier';                        switch methodName                case 'Hanning'                    cfg.taper='hanning'; %Fieldtrip recommends Hanning for frequencies below 30Hz                case 'multi-taper'                    if ~isempty(which('dpss'))                        cfg.taper='dpss';                        if smoothing < (inputData.Fs/numPoints)                            disp(['Increasing smoothing to minimum value allowed for dpss taper: ' num2str(inputData.Fs/numPoints)]);                            smoothing=(inputData.Fs/numPoints);                        end;                        %                         if numPoints/(numPoints*(smoothing/inputData.Fs)) >= (numPoints/2)                        %                             disp(['Decreasing smoothing to maximum value allowed for dpss taper: ' num2str(2*(inputData.Fs/numPoints)-.1)]);                        %                             smoothing=2*(inputData.Fs/numPoints)-.1;                        %                         end;                        cfg.tapsmofrq=smoothing;                    else                        cfg.taper='hanning';                        disp('Signal Processing Toolkit not installed so taper defaulting to Hanning');                    end;            end;            if strcmp(inputData.dataType,'continuous')                deltaT=min(numPoints/inputData.Fs,1); %time window in seconds                numWaves=max(1,floor(numPoints/inputData.Fs));                epochLength=[1:min(inputData.Fs,numPoints)];            else                deltaT=numPoints/inputData.Fs; %time window in seconds                epochLength=[];            end;            deltaF=1/deltaT; %frequency resolution            cfg.foi=[deltaF:deltaF:inputData.Fs/2];            cfg.pad='nextpow2';            cfg.feedback='no';                        inputData=ep_selectData(inputData,{spectralChans,[],[],[],[],[]});            outputData=zeros(size(inputData.data,1),1,numWaves,numSubs,numFacs,length(cfg.foi));                        fprintf('%60s\n',' ' );            for theTrial=1:numWaves                fprintf('%s%-60s',repmat(sprintf('\b'),1,60),sprintf('%s%4d of %4d',['Applying Fourier transform to ' theSegment '# '], theTrial, numWaves))                for theSubject=1:numSubs                    for theFactor = 1:numFacs                        evalc('[freq] = ft_freqanalysis(cfg, ep_ep2ft(ep_selectData(inputData,{[],epochLength,theTrial,theSubject,theFactor,[]})));'); %amplitude spectrum                        outputData(:,1,theTrial,theSubject,theFactor,:) = freq.fourierspctrm;                    end;                end;            end;            fprintf('%60s\n',' ' );                        %             if any(find(EPtopos.totalData < -100 ))            %                 EPtopos.totalData(find(EPtopos.totalData < -100)) = -100;            %                 EPtopos.plotMVmin = -100;            %                 disp('To avoid plotting problems with -Inf values, negative numbers are being truncated at -100.');            %             end;            if strcmp(inputData.dataType,'continuous')                %turns file type into single trial data where each one second segment becomes a different trial and the                %leftover points are just dropped.                inputData.dataType='single_trial';                inputData.trialNames=[1:numWaves]';                theCellNames=cell(numWaves,1);                theCellTypes=cell(numWaves,1);                for i=1:numWaves                    theCellNames(i)=inputData.cellNames(1);                    theCellTypes(i)=inputData.cellTypes(1);                end;                inputData.cellNames=theCellNames;                inputData.cellTypes=theCellTypes;                inputData.avgNum(1,1:numWaves)=inputData.avgNum;                inputData.subNum(1,1:numWaves)=inputData.avgNum;                inputData.trialSpecs=cell(numWaves,0);                inputData.trialSpecNames=cell(0);                inputData.events=cell(1,numWaves);                inputData.recTime=[0:numWaves-1]'*inputData.Fs+1;                disp('Dropping event information since spectral analysis is eliminating time point information.');            end;            inputData.timeNames=[];            inputData.freqNames=freq.freq;            inputData.noise=[];            inputData.std=[];            inputData.stdCM=[];            suffix=[suffix 's'];                    case 'Time-Frequency'            if ~isempty(inputData.freqNames)                msg{1}=['Error: The file ' fileName ' is already an FFT file.'];                [msg]=ep_errorMsg(msg);                return            end;            disp('Using FieldTrip function ft_freqanalysis to perform spectral analysis.');            cfg=[];            cfg.method='mtmconvol';            cfg.output='fourier';            deltaT=min(.5,(numPoints/inputData.Fs)); %time window in seconds, no more than 500 ms            switch methodName                case 'Hanning'                    cfg.taper='hanning'; %Fieldtrip recommends Hanning for frequencies below 30Hz                case 'multi-taper'                    if ~isempty(which('dpss'))                        cfg.taper='dpss';                                                if smoothing < (1/deltaT)                            smoothing=1/deltaT;                            disp(['Increasing smoothing to minimum value allowed for dpss taper: ' num2str(smoothing)]);                        end;                        if numPoints/(numPoints*(smoothing/inputData.Fs)) >= (numPoints/2)                            disp(['Decreasing smoothing to maximum value allowed for dpss taper: ' num2str(2*(inputData.Fs/numPoints)-.1)]);                            smoothing=2*(inputData.Fs/numPoints)-.1;                        end;                        cfg.tapsmofrq=smoothing;                    else                        cfg.taper='hanning';                        disp('Signal Processing Toolkit not installed so taper defaulting to Hanning');                    end;            end;            cfg.pad='nextpow2';            cfg.feedback='no';            cfg.keeptrials='yes';            cfg.keeptapers='yes';            resT=50; %50 ms sliding window            deltaF=1/deltaT; %frequency resolution            %cfg.foi          = deltaF:deltaF:50; %50 ms sliding window            cfg.foi=[deltaF:deltaF:inputData.Fs/2];            cfg.t_ftimwin    = ones(1,length(cfg.foi)).*deltaT;            cfg.tapsmofrq=ones(1,length(cfg.foi))*smoothing;                        spectralData=ep_selectData(inputData,{spectralChans,[],[],[],[],[]});                        if strcmp(inputData.dataType,'continuous')                %continuous data has the problem that half the deltaT is lopped off each end, resulting in the .analysis edit epochs being misaligned.                %will therefore lop off more off each end so that exactly one second is gone and the original epochs can remain aligned.                %a separate issue is that since the T-F transform goes into the adjoining epochs, bad data markings should also propagate as the previously good epoch will now be contaminated by bad data.                dropSamps=(ceil(deltaT)*inputData.Fs)+1;                cfg.toi=(inputData.timeNames(dropSamps):resT:inputData.timeNames(numPoints-dropSamps))/1000;                numPoints2=length(cfg.toi);                outputData=zeros(numChans,numPoints2,numWaves,numSubs,numFacs,length(cfg.foi));                disp('Applying wavelet transform to entire continuous dataset')                for theFactor = 1:numFacs                    evalc('[freq] = ft_freqanalysis(cfg, ep_ep2ft(ep_selectData(spectralData,{[],[],[],1,theFactor,[]})));'); %amplitude spectrum                    for theTime=1:numPoints2                        outputData(spectralChans,theTime,1,1,theFactor,:) = squeeze(freq.fourierspctrm(1,:,:,theTime));                    end;                    for iChan=1:length(nonSpecChans)                        theChan=nonSpecChans(iChan);                        outputData(theChan,:,1,1,theFactor,:)=repmat(interp1(inputData.timeNames+(inputData.baseline*(1000/inputData.Fs)),inputData.data(theChan,:,1,1,theFactor,:)',cfg.toi*1000,'linear','extrap')',1,1,length(cfg.foi));                    end;                end;                sampleConversion=(1000/inputData.Fs)/resT;                for iEvent=1:length(inputData.events{1})                    inputData.events{1}(iEvent).sample=ceil(inputData.events{1}(iEvent).sample*sampleConversion)-dropSamps;                end;                inputData.events{1}(find(([inputData.events{1}.sample]<1)|([inputData.events{1}.sample]>numPoints2)))=[];                badTrialList=find(inputData.analysis.badTrials);                for iTrial=1:length(badTrialList)                    theTrial=badTrialList(iTrial);                    if theTrial>1                        inputData.analysis.badTrials(1,theTrial-1)=1;                    end;                    if theTrial<length(inputData.analysis.badTrials)                        inputData.analysis.badTrials(1,theTrial+1)=1;                    end;                end;                newBadChans=inputData.analysis.badChans;                for iTrial=1:size(inputData.analysis.badChans,2)                    if iTrial>1                        newBadChans(1,iTrial-1,find(inputData.analysis.badChans(1,iTrial,:)==-1))=-1;                    end;                    if theTrial<length(inputData.analysis.badTrials)                        newBadChans(1,iTrial+1,find(inputData.analysis.badChans(1,iTrial,:)==-1))=-1;                    end;                end;                inputData.analysis.badChans=newBadChans;                firstEpoch=2;                lastEpoch=floor(numPoints2/(1000/resT))+1;                inputData.analysis.blinkTrial=inputData.analysis.blinkTrial(1,firstEpoch:lastEpoch);                inputData.analysis.saccadeTrial=inputData.analysis.saccadeTrial(1,firstEpoch:lastEpoch);                inputData.analysis.saccadeOnset=inputData.analysis.saccadeOnset(1,firstEpoch:lastEpoch);                inputData.analysis.moveTrial=inputData.analysis.moveTrial(1,firstEpoch:lastEpoch);                inputData.analysis.badTrials=inputData.analysis.badTrials(1,firstEpoch:lastEpoch);                inputData.analysis.badChans=inputData.analysis.badChans(1,firstEpoch:lastEpoch,:);            else                cfg.toi=(inputData.timeNames(ceil(deltaT*inputData.Fs*.5)):resT:inputData.timeNames(numPoints-ceil(deltaT*inputData.Fs*.5)))/1000;                outputData=zeros(numChans,length(cfg.toi),numWaves,numSubs,numFacs,length(cfg.foi));                fprintf('%60s\n',' ' );                for theTrial=1:numWaves                    fprintf('%s%-60s',repmat(sprintf('\b'),1,60),sprintf('%s%4d of %4d',['Applying wavelet transform to ' theSegment '# '], theTrial, numWaves))                    for theSubject=1:numSubs                        for theFactor = 1:numFacs                            evalc('[freq] = ft_freqanalysis(cfg, ep_ep2ft(ep_selectData(spectralData,{[],[],theTrial,theSubject,theFactor,[]})));'); %amplitude spectrum                            for theTime=1:length(cfg.toi)                                outputData(spectralChans,theTime,theTrial,theSubject,theFactor,:) = squeeze(freq.fourierspctrm(1,:,:,theTime));                            end;                            for iChan=1:length(nonSpecChans)                                theChan=nonSpecChans(iChan);                                outputData(theChan,:,theTrial,theSubject,theFactor,:)=repmat(interp1(inputData.timeNames+(inputData.baseline*(1000/inputData.Fs)),inputData.data(theChan,:,theTrial,theSubject,theFactor,:)',cfg.toi*1000,'linear','extrap')',1,1,length(cfg.foi));                            end;                            sampleConversion=(1000/inputData.Fs)/resT;                            for iEvent=1:length(inputData.events{theSubject,theTrial})                                inputData.events{theSubject,theTrial}(iEvent).sample=ceil(inputData.events{theSubject,theTrial}(iEvent).sample*sampleConversion);                            end;                        end;                    end;                end;                fprintf('%60s\n',' ' );            end;                        %firstGood=min(find(isfinite(squeeze(mean(outputData(:,:,1,1,1,1),1)))));            %lastGood=max(find(isfinite(squeeze(mean(outputData(:,:,1,1,1,1),1)))));            inputData.Fs=1000/resT;            inputData.timeNames=cfg.toi*1000;             inputData.timeNames=inputData.timeNames(:);            inputData.baseline=floor(-inputData.timeNames(1)/resT); %when baseline falls within the epoch, shift to left side of epoch            %inputData.baseline=((inputData.baseline*(1000/inputData.Fs))/50);            inputData.freqNames=freq.freq;            inputData.noise=[];            inputData.std=[];            inputData.stdCM=[];            suffix=[suffix 'w'];    end;        %calculate the .cov field    if strcmp(inputData.dataType,'single_trial') && isempty(inputData.cov) && (strcmp(referenceMethod,'CSD') || any(strcmp(domainName,{'Frequency','Time-Frequency'})))        goodChans=setdiff([1:numChans],any(isnan(squeeze(inputData.analysis.badChans(1,:,:))))); %if channel entirely bad in any of the cells, then leave out of cov calculation        covData=[];        EEGchans=find(strcmp('EEG',inputData.chanTypes));        goodChans=intersect(EEGchans,goodChans);        for iCell=1:size(inputData.data,3)            if ~any(inputData.analysis.badChans(1,iCell,:) < 0) && ~inputData.analysis.badTrials(1,iCell)                theData=squeeze(inputData.data(goodChans,:,iCell,1,:,:));                if inputData.baseline                    theData=theData-diag(squeeze(mean(theData(:,1:min(inputData.baseline,size(theData,2))),2)))*ones(length(goodChans),size(theData,2)); %baseline the data prior to calculating the cov matrix                end;                for iPoint=1:size(theData,2)                    theData(:,iPoint)=theData(:,iPoint)-mean(theData(:,iPoint),1); %average reference prior to cov calculation                end;                covData=[covData, theData];            end;        end;        Nq=size(covData,2);        inputData.cov.covMatrix=zeros(1,length(inputData.chanNames),length(inputData.chanNames));        inputData.cov.covMatrix(1,goodChans,goodChans)=(covData*covData')./Nq; %per MNE recommended procedure, the cov is calculated as an SSCP matrix where the variables have been baseline corrected for each epoch.        inputData.cov.Nq=Nq; %degrees of freedom, for weighting cov matrices when later combined.        if strcmp(inputData.dataType,'single_trial')            inputData.covNum=ones(1,size(outputData,3));        end;    end;        inputData.data=outputData;    %     if any(any(any(any(any(any(isnan(inputData.data)))))))%         disp(['Warning: Non-numbers were generated for the file ' inputFiles{file} ' so the output file will not be saved.']);%         suffix=[];%     end;        inputData.history{end+1} = {'ep_transformData',inputFiles,inputFormat,fileType,outputFormat,referenceMethod,transform,domainName};        if ~isempty(suffix)        [pathstr, name, ext] = fileparts(inputFiles{file});        [fileSuffix,formatName]=ep_fileExtensions(outputFormat);                sameName=1;        theNumber=0;        fileNameSuffix=[pathstr filesep name '_' suffix fileSuffix];        while sameName            sameName=0;            if exist(fileNameSuffix,'file')                sameName=1;            end;            if sameName                theNumber=theNumber+1;                fileNameSuffix=[pathstr filesep name '_' suffix '-' num2str(theNumber) fileSuffix];            end;        end;        [err]=ep_writeData(inputData,fileNameSuffix,EPmain.preferences.general.specSuffix,EPmain.preferences.general.subjectSpecSuffix,outputFormat);    end;    disp(['The subject took ' sprintf('%5.2f',toc/60) ' minutes to process.']);end;